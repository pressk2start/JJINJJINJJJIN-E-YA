# -*- coding: utf-8 -*-
import os, time, math, requests, statistics, traceback, threading, csv, sys, json, random, copy
from datetime import datetime, timedelta, timezone
from collections import deque, OrderedDict
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlencode

import uuid
import hashlib
import hmac
import jwt

# ğŸ”§ PyJWT íŒ¨í‚¤ì§€ ê²€ì¦ (ë™ëª…ì´ì¸ íŒ¨í‚¤ì§€ í˜¼ë™ ë°©ì§€)
try:
    _jwt_ver = getattr(jwt, "__version__", "unknown")
    assert hasattr(jwt, "encode") and callable(jwt.encode), "jwt.encode ì—†ìŒ"
    print(f"[JWT] PyJWT v{_jwt_ver} ë¡œë“œë¨")
except Exception as e:
    print(f"[JWT_ERR] PyJWT íŒ¨í‚¤ì§€ ë¬¸ì œ: {e}")
    print("[JWT_ERR] pip install PyJWT ë¡œ ì„¤ì¹˜ í•„ìš”")
    sys.exit(1)


def rnd():
    return random.random()  # â† ì´ ì¤„ì´ 4ì¹¸(ìŠ¤í˜ì´ìŠ¤) ë“¤ì—¬ì“°ê¸° ë˜ì–´ì•¼ í•¨

def fmt6(x):
    """
    ìˆ«ìë¥¼ ë³´ê¸° ì¢‹ê²Œ í‘œì‹œ:
    - ì •ìˆ˜ëŠ” ì†Œìˆ˜ì  ì—†ì´
    - ì†Œìˆ˜ì ì´ ìˆëŠ” ê²½ìš° ìµœëŒ€ 6ìë¦¬ê¹Œì§€ í‘œì‹œ
    """
    if isinstance(x, (int, float)):
        if abs(x - int(x)) < 1e-6:
            return f"{int(x):,}"
        else:
            s = f"{x:,.6f}".rstrip('0').rstrip('.')
            return s
    return str(x)

# =========================
# ì„¤ì • (24ì‹œê°„ ë‹¨íƒ€ ìµœì í™” + Bot-aware, 3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry)
# =========================
TOP_N = 60
SCAN_INTERVAL = 6
COOLDOWN = 480
PARALLEL_WORKERS = 12

# ==== Exit Control (anti-whipsaw) ====
WARMUP_SEC = 5  # ì§„ì… í›„ 5ì´ˆ ì›œì—…
HARD_STOP_DD = 0.015  # -1.5% ê¸‰ë½ ì‹œ ì¦‰ì‹œ ì»· (strict ê¸°ì¤€)
EXIT_DEBOUNCE_SEC = 8  # ì²­ì‚° ì‹ í˜¸ ì§€ì† í™•ì¸ ì‹œê°„
EXIT_DEBOUNCE_N = 4  # ì—°ì† NíšŒ ì¡°ê±´ ì¶©ì¡± í•„ìš”

# ğŸ”§ í†µí•© ì²´í¬í¬ì¸íŠ¸: íŠ¸ë ˆì¼ë§/ì–‡ì€ìˆ˜ìµ/Plateau ë°œë™ ê¸°ì¤€
# ğŸ”§ ë™ì í™”: ìˆ˜ìˆ˜ë£Œ + ìŠ¬ë¦¬í”¼ì§€ + ìµœì†Œì•ŒíŒŒ ê¸°ë°˜
PROFIT_CHECKPOINT_BASE = 0.0025  # ê¸°ë³¸ê°’ 0.25% (í´ë°±ìš©)
PROFIT_CHECKPOINT_MIN_ALPHA = 0.0010  # ìµœì†Œ ì•ŒíŒŒ 0.10%
# ğŸ”§ FIX: entry/exit ìŠ¬ë¦½ ë¶„ë¦¬ (TPì—ì„œ exitë§Œ ì •í™•íˆ ë°˜ì˜)
_ENTRY_SLIP_HISTORY = deque(maxlen=50)  # ì§„ì… ìŠ¬ë¦¬í”¼ì§€
_EXIT_SLIP_HISTORY = deque(maxlen=50)   # ì²­ì‚° ìŠ¬ë¦¬í”¼ì§€
_SLIP_HISTORY = deque(maxlen=50)  # ğŸ”§ í•˜ìœ„í˜¸í™˜ìš© (ì ì§„ ì œê±° ì˜ˆì •)

def _get_trimmed_mean(slip_deque, default=0.0008):
    """ìŠ¬ë¦½ dequeì—ì„œ trimmed mean ê³„ì‚° (ìƒí•˜ìœ„ 10% ì œê±°)"""
    if len(slip_deque) >= 10:
        sorted_slip = sorted(slip_deque)
        trim_n = max(1, len(sorted_slip) // 10)
        trimmed = sorted_slip[trim_n:-trim_n] if trim_n > 0 else sorted_slip
        return statistics.mean(trimmed) if trimmed else default
    elif len(slip_deque) >= 5:
        return statistics.median(slip_deque)
    return default

def get_dynamic_checkpoint():
    """ìˆ˜ìˆ˜ë£Œ + ìŠ¬ë¦¬í”¼ì§€(trimmed mean) + ìµœì†Œì•ŒíŒŒ ê¸°ë°˜ ë™ì  ì²´í¬í¬ì¸íŠ¸"""
    # ğŸ”§ CRITICAL FIX: ì•ˆì „í•œ ì „ì—­ ì°¸ì¡° (NameError ë°©ì§€)
    fee = globals().get("FEE_RATE", 0.001)
    # ğŸ”§ FIX: entry/exit ë¶„ë¦¬ ì‚¬ìš© (ì •í™•í•œ ì™•ë³µ ì¶”ì •)
    avg_entry_slip = _get_trimmed_mean(_ENTRY_SLIP_HISTORY, 0.0005)
    avg_exit_slip = _get_trimmed_mean(_EXIT_SLIP_HISTORY, 0.0008)
    est_roundtrip_slip = max(0.0005, avg_entry_slip) + max(0.0005, avg_exit_slip)
    # ì™•ë³µ ìˆ˜ìˆ˜ë£Œ(0.1%) + ì™•ë³µìŠ¬ë¦¬í”¼ì§€ + ìµœì†Œì•ŒíŒŒ(0.1%)
    dynamic_cp = fee + est_roundtrip_slip + PROFIT_CHECKPOINT_MIN_ALPHA
    # ìµœì†Œ 0.28%, ìµœëŒ€ 0.50% (ì™•ë³µ ìŠ¬ë¦¬í”¼ì§€ ë°˜ì˜ìœ¼ë¡œ ìƒí–¥)
    return max(0.0028, min(0.0050, dynamic_cp))

def get_expected_exit_slip_pct():
    """TP íŒë‹¨ìš© ì˜ˆìƒ ì²­ì‚° ìŠ¬ë¦½ (exitë§Œ ì‚¬ìš©, %)"""
    return _get_trimmed_mean(_EXIT_SLIP_HISTORY, 0.001) * 100.0

# í•˜ìœ„ í˜¸í™˜ìš©
PROFIT_CHECKPOINT = PROFIT_CHECKPOINT_BASE

# ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¡œì§ (ì§„ì… í›„ ì¼ì •ì‹œê°„ íš¡ë³´ ì‹œ ë¯¸ë‹ˆíŠ¸ë ˆì¼ë§ìœ¼ë¡œ íƒˆì¶œ)
# ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: íš¡ë³´ í—ˆìš© ì‹œê°„ ìƒí–¥ â†’ ë” ì˜¤ë˜ ê¸°ë‹¤ë¦¬ë©° í° ìˆ˜ìµ ì¶”êµ¬
SIDEWAYS_TIMEOUT = 90       # íš¡ë³´ íŒì • ì‹œê°„ (ì´ˆ) - 60â†’90 (ìµì ˆí‚¤ìš°ê¸°)

# ğŸ”§ ìŠ¤í¬ë˜ì¹˜ ê·œì¹™ (ì´ˆë°˜ ê°œì„  ì—†ìœ¼ë©´ ë¹ ë¥¸ íƒˆì¶œ)
# ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: ì´ˆë°˜ íƒˆì¶œ ê¸°ì¤€ ì™„í™” â†’ ë” ì˜¤ë˜ í™€ë”©
SCRATCH_TIMEOUT_SEC = 30    # 30ì´ˆ ë‚´ ê°œì„  ì—†ìœ¼ë©´ íƒˆì¶œ ê²€í†  (20â†’30 ìµì ˆí‚¤ìš°ê¸°)
SCRATCH_MIN_GAIN = 0.0004   # ìµœì†Œ +0.04% ì´ìƒ ìƒìŠ¹í•´ì•¼ ìœ ì§€ (0.06%â†’0.04% ì™„í™”)

# ğŸ”§ MFE ê¸°ë°˜ ë¶€ë¶„ìµì ˆ (ê²½ë¡œë³„ ë™ì  íƒ€ê²Ÿ) - ìµì ˆí‚¤ìš°ê¸° ì „ëµ
# ì‹ í˜¸ ê°•ë„ì— ë”°ë¼ ëª©í‘œ MFE ë„ë‹¬ ì‹œ 50% ë¶€ë¶„ìµì ˆ
# ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: MFE ëª©í‘œ ìƒí–¥ â†’ ë” í° ìˆ˜ìµ í™•ë³´ í›„ ë¶€ë¶„ìµì ˆ
# ğŸ”§ MFE íƒ€ê²Ÿ ì•ë‹¹ê¸°ê¸°: ë¹ ë¥¸ ë¶€ë¶„ìµì ˆë¡œ ìŠ¹ë¥  ì•ˆì •í™”
MFE_PARTIAL_TARGETS = {
    "ğŸ”¥ì í™”": 0.006,              # 0.8% â†’ 0.6% MFE ì‹œ 50% ìµì ˆ
    "ê°•ëŒíŒŒ (EMAâ†‘+ê³ ì â†‘)": 0.005,  # 0.7% â†’ 0.5% MFE ì‹œ 50% ìµì ˆ
    "EMAâ†‘": 0.004,                 # 0.6% â†’ 0.4% MFE ì‹œ 50% ìµì ˆ
    "ê³ ì â†‘": 0.004,                # 0.5% â†’ 0.4% MFE ì‹œ 50% ìµì ˆ
    "ê±°ë˜ëŸ‰â†‘": 0.003,              # 0.4% â†’ 0.3% MFE ì‹œ 50% ìµì ˆ
    "ê¸°ë³¸": 0.004,                 # 0.5% â†’ 0.4% MFE ê¸°ë³¸ê°’
}
MFE_PARTIAL_RATIO = 0.5  # ë¶€ë¶„ìµì ˆ ë¹„ìœ¨ (50%)

# íŠ¸ë ˆì¼ë§ ì†ì ˆ ì„¤ì • - ìµì ˆí‚¤ìš°ê¸° ì ìš©
# ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: íŠ¸ë ˆì¼ ê°„ê²© ì™„í™” â†’ ì¡°ê¸° ì´íƒˆ ë°©ì§€
TRAIL_ATR_MULT = 0.9  # ATR ê¸°ë°˜ ì—¬ìœ í­ (0.8â†’0.9 ì™„í™”)
TRAIL_DISTANCE_MIN_BASE = 0.0025  # ê¸°ë³¸ ìµœì†Œ íŠ¸ë ˆì¼ ê°„ê²© 0.25% (0.2%â†’0.25%)

def get_trail_distance_min():
    """ğŸ”§ íŠ¸ë ˆì¼ ê°„ê²©ì„ ì†ì ˆí­(DYN_SL_MIN)ê³¼ ì—°ë™ - íœ©ì˜ ì»· ê°ì†Œ"""
    # ğŸ”§ CRITICAL FIX: ì•ˆì „í•œ ì „ì—­ ì°¸ì¡° (DYN_SL_MINì€ line 2171ì—ì„œ ì •ì˜ë¨)
    dyn_sl = globals().get("DYN_SL_MIN", 0.004)
    # ğŸ”§ FIX: EXIT_PROFILE ë°˜ì˜ê°’ ì‚¬ìš© (BASE ëŒ€ì‹  TRAIL_DISTANCE_MIN ì°¸ì¡°)
    base = globals().get("TRAIL_DISTANCE_MIN", TRAIL_DISTANCE_MIN_BASE)
    # ì†ì ˆí­ì˜ 60%ë¥¼ íŠ¸ë ˆì¼ ìµœì†Œ ê°„ê²©ìœ¼ë¡œ (0.4% * 0.6 = 0.24%)
    return max(base, dyn_sl * 0.6)

# í•˜ìœ„ í˜¸í™˜ìš©
TRAIL_DISTANCE_MIN = TRAIL_DISTANCE_MIN_BASE

# === ìˆ˜ìˆ˜ë£Œ ì„¤ì • (ì™•ë³µ 0.1% ë°˜ì˜) ===
# ğŸ”§ FIX: ë³€ìˆ˜ëª… ëª…í™•í™” - ì™•ë³µ/í¸ë„ í˜¼ë™ ë°©ì§€
FEE_RATE_ROUNDTRIP = 0.001   # ì™•ë³µ 0.1% (0.05% ë§¤ìˆ˜ + 0.05% ë§¤ë„)
FEE_RATE_ONEWAY = FEE_RATE_ROUNDTRIP / 2  # í¸ë„ 0.05%
FEE_RATE = FEE_RATE_ROUNDTRIP  # í•˜ìœ„ í˜¸í™˜ìš©

# === í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ ì „ì—­ ì„¤ì • (âœ… ì¤‘ë³µ ì œê±°, ì¼ì›í™”) ===
USE_5M_CONTEXT = True         # 5ë¶„ ì»¨í…ìŠ¤íŠ¸ í™œì„±í™”
POSTCHECK_ENABLED = False     # ì´ˆì… ë‹¨ê³„ í¬ìŠ¤íŠ¸ì²´í¬ ë¹„í™œì„±í™”
EARLY_FLOW_MIN_KRWPSEC = 24_000  # ì´ˆê¸° ê±°ë˜ì†ë„ (22k~26k ì ˆì¶©)

# --- í™˜ê²½ë³€ìˆ˜(.env ì§€ì›) ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

# ==== Exit Profile (gentle/ balanced / strict) ====
EXIT_PROFILE = os.getenv("EXIT_PROFILE", "strict").lower()

# ğŸ”§ CRITICAL FIX: _apply_exit_profile() í˜¸ì¶œ ì „ ê¸°ë³¸ê°’ ì„ ì–¸ (NameError ë°©ì§€)
SPIKE_RECOVERY_WINDOW = 3
SPIKE_RECOVERY_MIN_BUY = 0.58
CTX_EXIT_THRESHOLD = 3


def _apply_exit_profile():
    """
    í”„ë¡œíŒŒì¼ë³„ ì²­ì‚° ë¯¼ê°ë„ ì„¸íŒ…
    - gentle  : ëŠìŠ¨(íœ©ì˜ ë‚´ì„±â†‘, ìˆ˜ìµ ìµœëŒ€í™” ì§€í–¥)
    - balanced: ê¸°ë³¸ê°’(í˜„ì¬ ë„¤ ì„¸íŒ… ê¸°ì¤€)
    - strict  : ì—„ê²©(ë³´ìˆ˜ì , ì†ì‹¤ì¶•ì†Œ ì§€í–¥)
    """
    global WARMUP_SEC, HARD_STOP_DD, EXIT_DEBOUNCE_SEC, EXIT_DEBOUNCE_N
    global TRAIL_ATR_MULT, TRAIL_DISTANCE_MIN
    global SPIKE_RECOVERY_WINDOW, SPIKE_RECOVERY_MIN_BUY
    global CTX_EXIT_THRESHOLD

    prof = EXIT_PROFILE

    if prof == "gentle":
        WARMUP_SEC = 14
        HARD_STOP_DD = 0.024
        EXIT_DEBOUNCE_SEC = 10
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 1.0
        TRAIL_DISTANCE_MIN = 0.0025  # 0.25% ê°„ê²©
        SPIKE_RECOVERY_WINDOW = 4
        SPIKE_RECOVERY_MIN_BUY = 0.56
        CTX_EXIT_THRESHOLD = 4

    elif prof == "strict":
        # ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: strictë„ íŠ¸ë ˆì¼ ì™„í™” (ì¡°ê¸° ì´íƒˆ ë°©ì§€)
        WARMUP_SEC = 5  # 3â†’5 (ì•½ê°„ ì—¬ìœ )
        HARD_STOP_DD = 0.015  # -1.2% â†’ -1.5% (ì†ì ˆ ì™„í™”)
        EXIT_DEBOUNCE_SEC = 5
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 0.8  # 0.7â†’0.8 (ì™„í™”)
        TRAIL_DISTANCE_MIN = 0.002  # 0.15% â†’ 0.2% (ì™„í™”)
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.60
        CTX_EXIT_THRESHOLD = 3  # 2â†’3 (ì™„í™”)

    else:  # balanced (í˜„ì¬ ê°’ì— ê·¼ì ‘) - ìµì ˆí‚¤ìš°ê¸° ì ìš©
        WARMUP_SEC = 14  # 12â†’14 (ì•½ê°„ ì—¬ìœ )
        HARD_STOP_DD = 0.025  # 0.022 â†’ 0.025 (ì†ì ˆ ì™„í™”)
        EXIT_DEBOUNCE_SEC = 10
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 0.9  # 0.8â†’0.9 (ì™„í™”)
        TRAIL_DISTANCE_MIN = 0.0025  # 0.2% â†’ 0.25% (ì™„í™”)
        SPIKE_RECOVERY_WINDOW = 4
        SPIKE_RECOVERY_MIN_BUY = 0.55
        CTX_EXIT_THRESHOLD = 4  # 3â†’4 (ì™„í™”)


_apply_exit_profile()

TG_TOKEN = os.getenv("TELEGRAM_TOKEN") or os.getenv("TG_TOKEN") or ""

# ğŸ“Œ ì—¬ëŸ¬ ëª…ì—ê²Œ ë³´ë‚´ê¸°ìš© chat_id ëª©ë¡
_raw_chats = (
    os.getenv("TG_CHATS")  # ìƒˆë¡œ ì“¸ ì¶”ì²œ í‚¤: "id1,id2,-100xxx"
    or os.getenv("TELEGRAM_CHAT_ID")  # ì˜ˆì „ ë‹¨ì¼ í‚¤ë„ í˜¸í™˜
    or os.getenv("TG_CHAT") or "")

CHAT_IDS = []
for part in _raw_chats.split(","):
    part = part.strip()
    if not part:
        continue
    try:
        CHAT_IDS.append(int(part))
    except Exception:
        print(f"[WARN] ì˜ëª»ëœ chat_id ê°’ ë¬´ì‹œë¨: {part}")

print("[DEBUG] CHAT_IDS =", CHAT_IDS)  # ì‹¤í–‰ ì‹œ í•œ ë²ˆ ì°í˜€ì„œ í™•ì¸ìš©

# =========================
# ğŸ”¥ ì í™” ê°ì§€ (Ignition Detection) ì „ì—­ ë³€ìˆ˜
# =========================
_IGNITION_LAST_SIGNAL = {}  # {market: timestamp_ms} ë§ˆì§€ë§‰ ì í™” ì‹ í˜¸ ì‹œê°
_IGNITION_BASELINE_TPS = {}  # {market: tps} ì¢…ëª©ë³„ í‰ì‹œ í‹±/ì´ˆ
_IGNITION_LOCK = threading.Lock()

# =========================
# ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì… ëª¨ë“œ (Retest Entry Mode)
# =========================
# ì¥ì´ˆ ê¸‰ë“± â†’ ì²« ì–‘ë´‰ íŒ¨ìŠ¤ â†’ ë˜ëŒë¦¼ í›„ ì§€ì§€ í™•ì¸ ì‹œ ì§„ì…
RETEST_MODE_ENABLED = True           # ë¦¬í…ŒìŠ¤íŠ¸ ëª¨ë“œ í™œì„±í™”
RETEST_PEAK_MIN_GAIN = 0.015         # ìµœì†Œ 1.5% ê¸‰ë“± ì‹œ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ë“±ë¡
RETEST_PULLBACK_MIN = 0.003          # ìµœì†Œ 0.3% ë˜ëŒë¦¼ í•„ìš” (ê³ ì  ëŒ€ë¹„)
RETEST_PULLBACK_MAX = 0.020          # ìµœëŒ€ 2.0% ë˜ëŒë¦¼ê¹Œì§€ í—ˆìš©
RETEST_BOUNCE_MIN = 0.002            # ìµœì†Œ 0.2% ë°˜ë“± í™•ì¸
RETEST_TIMEOUT_SEC = 180             # 3ë¶„ ë‚´ ë¦¬í…ŒìŠ¤íŠ¸ ì—†ìœ¼ë©´ ì œê±°
RETEST_SUPPORT_EMA = 20              # EMA ì§€ì§€ í™•ì¸ìš©
RETEST_MORNING_HOURS = (8, 10)       # ì¥ì´ˆ ì‹œê°„ëŒ€ (08:00~10:00)

# ë¦¬í…ŒìŠ¤íŠ¸ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸: {market: {"peak_price", "peak_ts", "pullback_low", "state", "pre"}}
# state: "watching" â†’ "pullback" â†’ "bounce" â†’ "ready"
_RETEST_WATCHLIST = {}
_RETEST_LOCK = threading.Lock()

# =========================
# ğŸ” í”„ë¡œì„¸ìŠ¤ ê°„ ì¤‘ë³µ ì§„ì… ë°©ì§€ (íŒŒì¼ë½ + ë©”ëª¨ë¦¬ë½)
# =========================
# ğŸ”§ FIX: ë½ì— ì†Œìœ ì(ìŠ¤ë ˆë“œ ID) ì¶”ì  ì¶”ê°€ - reentrant ë²„ê·¸ ìˆ˜ì •
# í˜•ì‹: { market: (timestamp, owner_thread_ident) }
_MEMORY_ENTRY_LOCKS = {}  # ë©”ëª¨ë¦¬ ê¸°ë°˜ ë½ (ìŠ¤ë ˆë“œ ê°„)
_MEMORY_LOCK = threading.Lock()  # ë©”ëª¨ë¦¬ ë½ ë³´í˜¸ìš©

def _entry_lock_path(market: str) -> str:
    return f"/tmp/bot_entry_{market.replace('-', '_')}.lock"

def _try_acquire_entry_lock(market: str, ttl_sec: int = 60, reentrant: bool = False) -> bool:
    """ë½ íšë“ ì‹œë„. ì„±ê³µí•˜ë©´ True, ì´ë¯¸ ë½ ìˆìœ¼ë©´ False

    ğŸ”§ FIX: ì›ìì  íŒŒì¼ ìƒì„± (O_CREAT | O_EXCL) + ë©”ëª¨ë¦¬ ë½ ì´ì¤‘ ë³´í˜¸
    ğŸ”§ FIX: reentrant=TrueëŠ” **ê°™ì€ ìŠ¤ë ˆë“œ**ì—ì„œë§Œ ì¬ì§„ì… í—ˆìš© (ì†Œìœ ì ì¶”ì )
    """
    current_owner = threading.current_thread().ident

    # 1ï¸âƒ£ ë©”ëª¨ë¦¬ ë½ ë¨¼ì € ì²´í¬ (ê°™ì€ í”„ë¡œì„¸ìŠ¤ ë‚´ ìŠ¤ë ˆë“œ ê°„)
    with _MEMORY_LOCK:
        if market in _MEMORY_ENTRY_LOCKS:
            lock_ts, lock_owner = _MEMORY_ENTRY_LOCKS[market]
            if time.time() - lock_ts < ttl_sec:
                # ğŸ”§ FIX: reentrant ëª¨ë“œëŠ” **ê°™ì€ ìŠ¤ë ˆë“œ(ì†Œìœ ì)**ì¼ ë•Œë§Œ True
                if reentrant and lock_owner == current_owner:
                    return True
                return False
        # ğŸ”§ FIX: (íƒ€ì„ìŠ¤íƒ¬í”„, ì†Œìœ ì) íŠœí”Œë¡œ ì €ì¥
        _MEMORY_ENTRY_LOCKS[market] = (time.time(), current_owner)

    # 2ï¸âƒ£ íŒŒì¼ ë½ (í”„ë¡œì„¸ìŠ¤ ê°„)
    path = _entry_lock_path(market)
    try:
        # ê¸°ì¡´ ë½ íŒŒì¼ì´ ìˆìœ¼ë©´ TTL ì²´í¬
        if os.path.exists(path):
            if (time.time() - os.path.getmtime(path)) < ttl_sec:
                # ë©”ëª¨ë¦¬ ë½ ë¡¤ë°±
                with _MEMORY_LOCK:
                    _MEMORY_ENTRY_LOCKS.pop(market, None)
                return False
            # TTL ë§Œë£Œëœ ë½ íŒŒì¼ ì œê±°
            try:
                os.remove(path)
            except Exception:
                pass

        # ì›ìì  íŒŒì¼ ìƒì„± ì‹œë„ (O_CREAT | O_EXCL = ì´ë¯¸ ì¡´ì¬í•˜ë©´ ì‹¤íŒ¨)
        fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
        os.write(fd, str(time.time()).encode())
        os.close(fd)
        return True
    except FileExistsError:
        # ë‹¤ë¥¸ ìŠ¤ë ˆë“œ/í”„ë¡œì„¸ìŠ¤ê°€ ë¨¼ì € ìƒì„±í•¨
        with _MEMORY_LOCK:
            _MEMORY_ENTRY_LOCKS.pop(market, None)
        return False
    except Exception:
        with _MEMORY_LOCK:
            _MEMORY_ENTRY_LOCKS.pop(market, None)
        return False

def _release_entry_lock(market: str):
    """ë½ í•´ì œ (íŒŒì¼ ì‚­ì œ + ë©”ëª¨ë¦¬ ë½ í•´ì œ)"""
    # ë©”ëª¨ë¦¬ ë½ í•´ì œ
    with _MEMORY_LOCK:
        _MEMORY_ENTRY_LOCKS.pop(market, None)

    # íŒŒì¼ ë½ í•´ì œ
    path = _entry_lock_path(market)
    try:
        if os.path.exists(path):
            os.remove(path)
    except Exception:
        pass


def cleanup_stale_entry_locks(max_age_sec=300):
    """ì˜¤ë˜ëœ ì—”íŠ¸ë¦¬ ë½íŒŒì¼ ì •ë¦¬ (ê¸°ë³¸ 5ë¶„)"""
    try:
        nowt = time.time()
        cleaned = 0
        for name in os.listdir("/tmp"):
            if not name.startswith("bot_entry_"):
                continue
            path = f"/tmp/{name}"
            try:
                if nowt - os.path.getmtime(path) > max_age_sec:
                    os.remove(path)
                    cleaned += 1
            except Exception:
                pass
        if cleaned > 0:
            print(f"[LOCK_CLEAN] {cleaned}ê°œ ì˜¤ë˜ëœ ë½íŒŒì¼ ì •ë¦¬ë¨")
    except Exception as e:
        print(f"[LOCK_CLEAN_ERR] {e}")


from contextlib import contextmanager

@contextmanager
def entry_lock(market: str, ttl_sec: int = 60, reentrant: bool = False):
    """ì—”íŠ¸ë¦¬ ë½ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € - ì•ˆì „í•œ ë½ íšë“/í•´ì œ

    ğŸ”§ reentrant=True: ì¬ì§„ì… ëª¨ë“œ (ì´ë¯¸ ë½ì„ ê°€ì§€ê³  ìˆìœ¼ë©´ True, í•´ì œ ì•ˆ í•¨)
    """
    got = _try_acquire_entry_lock(market, ttl_sec=ttl_sec, reentrant=reentrant)
    try:
        yield got
    finally:
        # ğŸ”§ FIX: reentrant ëª¨ë“œì—ì„œëŠ” ë½ í•´ì œ ì•ˆ í•¨ (ì›ë˜ íšë“í•œ ê³³ì—ì„œ í•´ì œ)
        if got and not reentrant:
            _release_entry_lock(market)


def get_available_krw(accounts) -> float:
    """KRW ê°€ìš©ì”ê³  ê³„ì‚° (locked ë°˜ì˜)"""
    for a in accounts:
        if a.get("currency") == "KRW":
            bal = float(a.get("balance", "0") or 0)
            locked = float(a.get("locked", "0") or 0)
            return max(0.0, bal - locked)
    return 0.0


# =========================
# ğŸ”¥ ì—…ë¹„íŠ¸ Private API (ì£¼ë¬¸/ì”ê³ /í¬ì§€ì…˜ ê´€ë¦¬)
# =========================
# import uuid, hashlib, jwt  # ìƒë‹¨(8-11ì¤„)ì—ì„œ ì´ë¯¸ importë¨
# from urllib.parse import urlencode  # ìƒë‹¨(6ì¤„)ì—ì„œ ì´ë¯¸ importë¨

UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY", "")
UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY", "")

# ğŸ”§ ë³´ì•ˆ: í‚¤ ê¸¸ì´ ë¡œê¹…ì€ ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ
if os.getenv("DEBUG_KEYS") == "1":
    print(
        "[UPBIT_KEYS] access_len=",
        len(UPBIT_ACCESS_KEY),
        "secret_len=",
        len(UPBIT_SECRET_KEY),
    )

# AUTO_TRADE = 1 ì´ë©´ ì‹¤ì œ ì£¼ë¬¸, 0ì´ë©´ ì•Œë¦¼ + ëª¨ë‹ˆí„°ë§ë§Œ
AUTO_TRADE = os.getenv("AUTO_TRADE", "0") == "1"
RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.003"))  # ê³„ì¢Œì˜ 0.3% ë¦¬ìŠ¤í¬

print(f"[BOT_MODE] AUTO_TRADE={AUTO_TRADE}, RISK_PER_TRADE={RISK_PER_TRADE}")

# === ê³µê²© ëª¨ë“œ / í”¼ë¼ë¯¸ë”© ì„¤ì • ===
AGGRESSIVE_MODE = os.getenv("AGGRESSIVE_MODE", "1") == "1"

# ì†Œì•¡ ì„ ì§„ì… + ì¶”ë§¤ êµ¬ì¡° (ì†Œì•¡ í”„ë¡œë¸Œê°€ ë” ì•ˆì •ì )
USE_PYRAMIDING = os.getenv("USE_PYRAMIDING", "1") == "1"

# RISK_PER_TRADEë¥¼ ìª¼ê°œì„œ ì‚¬ìš© (seed + add)
# ì˜ˆ: RISK_PER_TRADE=0.003, SEED=0.55, ADD=0.55 ë©´ ëŒ€ëµ 1.1ë°° ì •ë„ ë¦¬ìŠ¤í¬ ì‚¬ìš©
SEED_RISK_FRACTION = float(os.getenv("SEED_RISK_FRACTION", "0.55"))
ADD_RISK_FRACTION = float(os.getenv("ADD_RISK_FRACTION", "0.55"))

# ì¶”ë§¤ íŠ¸ë¦¬ê±° ì¡°ê±´
PYRAMID_ADD_MIN_GAIN = float(os.getenv("PYRAMID_ADD_MIN_GAIN", "0.008"))  # +0.8% ì´ìƒì—ì„œ ì¶”ë§¤
PYRAMID_ADD_FLOW_MIN_BUY = float(os.getenv("PYRAMID_ADD_FLOW_MIN_BUY", "0.60"))  # ë§¤ìˆ˜ë¹„
PYRAMID_ADD_FLOW_MIN_KRWPSEC = float(os.getenv("PYRAMID_ADD_FLOW_MIN_KRWPSEC", "35000"))  # KRW/s
PYRAMID_ADD_COOLDOWN_SEC = int(os.getenv("PYRAMID_ADD_COOLDOWN_SEC", "12"))  # ì¶”ë§¤ ê°„ ìµœì†Œ ê°„ê²©(ì´ˆ)


# í˜„ì¬ ì—´ë¦° í¬ì§€ì…˜ ê¸°ë¡ìš©
# ì˜ˆ: { "KRW-BTC": {"entry_price":..., "volume":..., "stop":..., "sl_pct":..., "state":"open"} }
OPEN_POSITIONS = {}
_POSITION_LOCK = threading.Lock()  # í¬ì§€ì…˜ ì ‘ê·¼ ë½
_CLOSING_MARKETS = set()  # ğŸ”§ FIX: ì¤‘ë³µ ì²­ì‚° ë°©ì§€ìš© (ì²­ì‚° ì§„í–‰ ì¤‘ ë§ˆì¼“ í‘œì‹œ)

def mark_position_closed(market, reason=""):
    """
    ğŸ”§ FIX: í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ ë§ˆí‚¹ (ì¤‘ë³µ ì²­ì‚° ë°©ì§€ í•µì‹¬)
    - state='closed' ë§ˆí‚¹ í›„ OPEN_POSITIONSì—ì„œ ì œê±°
    - ì´ë¯¸ closedë©´ False ë°˜í™˜ (ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€)
    """
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(market)
        if not pos:
            return False
        # ì´ë¯¸ closedë©´ ì¬ì²˜ë¦¬ ë°©ì§€
        if pos.get("state") == "closed":
            return False
        pos["state"] = "closed"
        pos["closed_at"] = time.time()
        pos["closed_reason"] = reason
        OPEN_POSITIONS.pop(market, None)
    return True

MAX_POSITIONS = int(os.getenv("MAX_POSITIONS", "5"))  # ğŸ”§ ìµœëŒ€ ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ (ì´ ë…¸ì¶œ í•œë„)

# ğŸ”§ FIX: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¤‘ë³µ ë°©ì§€
# ğŸ”§ FIX: ident ëŒ€ì‹  ìŠ¤ë ˆë“œ ê°ì²´ ì €ì¥ (is_alive() ì²´í¬ ê°€ëŠ¥)
_ACTIVE_MONITORS = {}  # { "KRW-BTC": threading.Thread }
_MONITOR_LOCK = threading.Lock()

# ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™”
_LAST_ORPHAN_SYNC = 0
ORPHAN_SYNC_INTERVAL = 30  # 30ì´ˆë§ˆë‹¤ ì²´í¬
_ORPHAN_HANDLED = set()    # ì´ë¯¸ ì²˜ë¦¬í•œ ìœ ë ¹ í¬ì§€ì…˜ (ì„¸ì…˜ ë‚´ ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€)
_PREV_SYNC_MARKETS = set() # ì´ì „ ë™ê¸°í™”ì—ì„œ ë°œê²¬ëœ ë§ˆì¼“ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)
_RECENT_BUY_TS = {}        # ğŸ”§ ìµœê·¼ ë§¤ìˆ˜ ì‹œê°„ ì¶”ì  (ìœ ë ¹ ì˜¤íƒ ë°©ì§€)

# ğŸ”” ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ì¿¨íƒ€ì„ (ë¹„ë§¤ë§¤ ì•Œë¦¼ìš©)
REMONITOR_COOLDOWN_SEC = 300  # 5ë¶„
REMONITOR_LAST_ALERT = {}

# =========================
# ğŸ“ˆ ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹
# =========================
from collections import deque as _deque_for_risk  # ê¸°ì¡´ dequeì™€ ë³„ë„ alias

TRADE_HISTORY = _deque_for_risk(maxlen=30)  # ìµœê·¼ 30ê°œ ê±°ë˜ ê¸°ë¡

# ğŸ”§ í¬ë¦¬í‹°ì»¬ í•«í”½ìŠ¤: streak ì „ì—­ë³€ìˆ˜ ìƒë‹¨ ì„ ì–¸ (NameError ë°©ì§€)
_lose_streak = 0              # ì—°ì† íŒ¨ë°° ìˆ˜
_win_streak = 0               # ì—°ì† ìŠ¹ë¦¬ ìˆ˜


def record_trade(market: str, pnl_pct: float):
    """
    ê±°ë˜ ê²°ê³¼ ê¸°ë¡
    ğŸ”§ FIX: ì†Œìˆ˜ ë‹¨ìœ„ë¡œ í†µì¼ (ì˜ˆ: +0.023 = +2.3%)
    - pnl_pct: ì†Œìˆ˜ ë‹¨ìœ„ ìˆ˜ìµë¥  (ì˜ˆ: +0.023, -0.015)
    - update_trade_result()ì™€ ë™ì¼í•œ ë‹¨ìœ„ ì‚¬ìš©
    ğŸ”§ FIX: streakë„ ì—¬ê¸°ì„œ ì¼ì›í™” (update_trade_result ëˆ„ë½/ì¤‘ë³µ ìŠ¤í‚µ ì˜í–¥ ì œê±°)
    """
    global _lose_streak, _win_streak
    is_win = pnl_pct > 0

    TRADE_HISTORY.append({
        "market": market,
        "pnl": pnl_pct,
        "win": is_win,
        "time": time.time(),
    })

    # ğŸ”§ FIX: streakë„ ì—¬ê¸°ì„œ ìµœì‹ í™” (ì‚¬ì´ì§• ì•ˆì •ì„±)
    if is_win:
        _lose_streak = 0
        _win_streak += 1
    else:
        _lose_streak += 1
        _win_streak = 0


def get_adaptive_risk() -> float:
    """
    ìµœê·¼ ìŠ¹ë¥  + streak ê¸°ë°˜ RISK_PER_TRADE ê°€ë³€ ì¡°ì •
    - íˆìŠ¤í† ë¦¬ 10ê±´ ë¯¸ë§Œ: ê¸°ë³¸ê°’ (streakë§Œ ì ìš©)
    - winrate < 30% : ë¦¬ìŠ¤í¬ 0.5ë°°
    - winrate >= 50%: ë¦¬ìŠ¤í¬ 1.2ë°°
    - ğŸ”§ ì—°íŒ¨ 3íšŒ ì´ìƒ: ë¦¬ìŠ¤í¬ 0.85ë°° (ë°©ì–´ì )
    - ğŸ”§ ì—°ìŠ¹ 3íšŒ ì´ìƒ: ë¦¬ìŠ¤í¬ 1.15ë°° (ê³µê²©ì )
    """
    global _lose_streak, _win_streak  # ğŸ”§ ì „ì—­ ì°¸ì¡° ëª…ì‹œ
    base_risk = RISK_PER_TRADE

    # ìŠ¹ë¥  ê¸°ë°˜ ì¡°ì •
    if len(TRADE_HISTORY) >= 10:
        wins = sum(1 for t in TRADE_HISTORY if t.get("win"))
        win_rate = wins / len(TRADE_HISTORY)

        if win_rate < 0.30:
            base_risk = RISK_PER_TRADE * 0.5
        elif win_rate >= 0.50:
            base_risk = RISK_PER_TRADE * 1.2

    # ğŸ”§ FIX: streak ê¸°ë°˜ ì¶”ê°€ ì¡°ì • (ì—°íŒ¨ ì‹œ ì¤„ì´ê³ , ì—°ìŠ¹ ì‹œ ëŠ˜ë¦¼)
    if _lose_streak >= 3:
        base_risk *= 0.85  # ì—°íŒ¨ 3íšŒ â†’ ë¦¬ìŠ¤í¬ 15% ê°ì†Œ
    elif _win_streak >= 3:
        base_risk *= 1.15  # ì—°ìŠ¹ 3íšŒ â†’ ë¦¬ìŠ¤í¬ 15% ì¦ê°€

    # ğŸ”§ FIX: ë¦¬ìŠ¤í¬ ìƒí•œ (ì—°ìŠ¹ ì‹œì—ë„ ê³¼ë„í•œ ë¦¬ìŠ¤í¬ ë°©ì§€)
    # - ìµœëŒ€ ê¸°ë³¸ê°’ì˜ 1.5ë°° ë˜ëŠ” ì ˆëŒ€ê°’ 5% ì¤‘ ì‘ì€ ê°’
    MAX_RISK_MULTIPLIER = 1.5
    MAX_RISK_ABSOLUTE = 0.05  # 5%
    base_risk = min(base_risk, RISK_PER_TRADE * MAX_RISK_MULTIPLIER, MAX_RISK_ABSOLUTE)

    return base_risk

def _make_auth_headers(query: dict = None):
    payload = {
        'access_key': UPBIT_ACCESS_KEY,
        'nonce': str(uuid.uuid4()),
    }
    if query:
        q = urlencode(query).encode()
        m = hashlib.sha512()
        m.update(q)
        payload['query_hash'] = m.hexdigest()
        payload['query_hash_alg'] = 'SHA512'
    # ğŸ”§ FIX: ì•Œê³ ë¦¬ì¦˜ ì§€ì • + PyJWT v1/v2 í˜¸í™˜ ë””ì½”ë”©
    jwt_token = jwt.encode(payload, UPBIT_SECRET_KEY, algorithm="HS256")
    if isinstance(jwt_token, bytes):  # PyJWT v1 ëŒ€ë¹„
        jwt_token = jwt_token.decode("utf-8")
    return {"Authorization": f"Bearer {jwt_token}"}


def upbit_private_get(path, params=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    headers = _make_auth_headers(params or {})
    _throttle()
    r = SESSION.get(url, headers=headers, params=params, timeout=timeout)
    r.raise_for_status()
    return r.json()


def upbit_private_post(path, body=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    body = body or {}
    headers = _make_auth_headers(body)
    _throttle()
    r = SESSION.post(url, headers=headers, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()


def get_order_result(uuid_str, timeout_sec=10.0):
    """
    ì£¼ë¬¸ uuid ë¡œ ìµœì¢… ì²´ê²° ê²°ê³¼ ì¡°íšŒ
    - done / cancel ìƒíƒœê°€ ë˜ê±°ë‚˜ timeout ë  ë•Œê¹Œì§€ polling
    ğŸ”§ FIX: waitì—ì„œ ì¢…ë£Œí•˜ë©´ ì²´ê²° ì „ì— ëŠê¹€ â†’ done/cancelë§Œ ì¢…ë£Œ
    """
    deadline = time.time() + timeout_sec
    last = None
    while time.time() < deadline:
        try:
            od = upbit_private_get("/v1/order", {"uuid": uuid_str})
            last = od
            state = od.get("state")
            # ğŸ”§ FIX: done/cancelì—ì„œë§Œ ì¢…ë£Œ, waitëŠ” ê³„ì† ëŒ€ê¸°
            if state in ("done", "cancel"):
                break
        except Exception as e:
            last = None
        time.sleep(0.25)
    return last


def get_account_info():
    """ì—…ë¹„íŠ¸ ê³„ì¢Œ(ì”ê³ ) ì¡°íšŒ"""
    try:
        return upbit_private_get("/v1/accounts")
    except Exception as e:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨:", e)
        return []


def calc_position_size(entry_price, stop_price, total_equity, risk_pct):
    """
    ì†ì ˆê°€ ê¸°ì¤€ìœ¼ë¡œ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    - total_equity * risk_pct ë§Œí¼ë§Œ ìµœëŒ€ ì†ì‹¤ í—ˆìš©
    """
    # ğŸ”§ CRITICAL: ë¹„ì •ìƒ entry_price ê°€ë“œ (ë¶„ëª¨ 0 ë°©ì§€)
    if entry_price is None or entry_price <= 0:
        return 0.0

    risk_krw = total_equity * risk_pct
    # ğŸ”§ FIX: DYN_SL_MINê³¼ ë™ê¸°í™” (ê³¼ìœ„í—˜ ë°©ì§€)
    min_sl_pct = DYN_SL_MIN  # ì „ì—­ ì†ì ˆí­ê³¼ ì¼ì¹˜

    # ğŸ”§ FIX: stop_priceê°€ Noneì´ê±°ë‚˜ entry_price ì´ìƒì´ë©´ ë³´ì •
    if stop_price is None or stop_price <= 0 or stop_price >= entry_price:
        stop_price = entry_price * (1 - min_sl_pct)

    per_unit_loss = max(entry_price - stop_price,
                        entry_price * min_sl_pct)

    # ğŸ”§ CRITICAL: ë¶„ëª¨ ì•ˆì „ ê°€ë“œ
    if per_unit_loss <= 0:
        return 0.0

    qty = risk_krw / per_unit_loss
    return max(qty, 0.0)


def place_market_buy(market, krw_amount):
    """KRW ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ìˆ˜ (ord_type=price)"""
    krw_amount = int(krw_amount)
    # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ê°€ë“œ (400 ì—ëŸ¬ ë°©ì§€)
    if krw_amount < 5000:
        print(f"[BUY_ERR] {market} ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë‹¬: {krw_amount}ì› < 5000ì›")
        return None
    body = {
        "market": market,
        "side": "bid",
        "ord_type": "price",
        "price": str(krw_amount)
    }
    return upbit_private_post("/v1/orders", body)


def place_market_sell(market, volume, price_hint=None):
    """
    ìˆ˜ëŸ‰ ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ë„
    ğŸ”§ FIX: ìˆ˜ëŸ‰ ì •ë°€ë„ ë³´ì • + ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ í•­ìƒ ì²´í¬
    """
    # ìˆ˜ëŸ‰ ì •ë°€ë„ ë³´ì • (8ìë¦¬ê¹Œì§€, ì—…ë¹„íŠ¸ í‘œì¤€)
    volume = round(float(volume), 8)

    # ğŸ”§ FIX: price_hint ì—†ìœ¼ë©´ í˜„ì¬ê°€ ì¡°íšŒ (ìµœì†Œê¸ˆì•¡ ì²´í¬ ìš°íšŒ ë°©ì§€)
    if price_hint is None:
        try:
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
            price_hint = cur_js[0].get("trade_price", 0) if cur_js else 0
        except Exception:
            price_hint = 0

    # ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ (5,000ì›)
    if price_hint and price_hint > 0:
        est_value = volume * price_hint
        if est_value < 5000:
            raise ValueError(f"ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë‹¬: {est_value:.0f}ì› < 5000ì›")

    body = {
        "market": market,
        "side": "ask",
        "ord_type": "market",
        "volume": f"{volume:.8f}"  # ì†Œìˆ˜ì  8ìë¦¬ ê³ ì •
    }
    return upbit_private_post("/v1/orders", body)

def get_actual_balance(market):
    """ì‹¤ì œ ë³´ìœ ëŸ‰ ì¡°íšŒ (ì°Œêº¼ê¸° ë°©ì§€ìš©)"""
    try:
        currency = market.replace("KRW-", "")
        accounts = get_account_info()
        for a in accounts:
            if a.get("currency") == currency:
                return float(a.get("balance", "0"))
        return 0.0
    except:
        return 0.0

def get_balance_with_locked(market, retries=2):
    """
    ì‹¤ì œ ë³´ìœ ëŸ‰ + ì£¼ë¬¸ ëŒ€ê¸°ëŸ‰ ì¡°íšŒ (ì²­ì‚° ì™„ë£Œ íŒì •ìš©)
    ğŸ”§ FIX: API ì˜¤ë¥˜ ì‹œ ì¬ì‹œë„ (ë‹¨ë°œ ì¡°íšŒë¡œ 0 ì˜¤íŒ â†’ ìœ ë ¹ ì˜¤íƒ ë°©ì§€)
    - retries: ì¬ì‹œë„ íšŸìˆ˜ (ê¸°ë³¸ 2íšŒ = ì´ 3íšŒ ì‹œë„)
    """
    currency = market.replace("KRW-", "")
    last_err = None
    for attempt in range(retries + 1):
        try:
            accounts = get_account_info()
            if accounts:
                for a in accounts:
                    if a.get("currency") == currency:
                        balance = float(a.get("balance", "0"))
                        locked = float(a.get("locked", "0"))
                        return balance + locked
                # ê³„ì • ëª©ë¡ì—ì„œ ì°¾ì§€ ëª»í•¨ = ì§„ì§œ 0
                return 0.0
            # accountsê°€ ë¹„ì–´ìˆìœ¼ë©´ API ì˜¤ë¥˜ì¼ ìˆ˜ ìˆìŒ â†’ ì¬ì‹œë„
            last_err = "accounts empty"
        except Exception as e:
            last_err = str(e)
        # ì¬ì‹œë„ ì „ ì§§ì€ ëŒ€ê¸°
        if attempt < retries:
            time.sleep(0.5)
    # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ â†’ -1 ë°˜í™˜ (0ê³¼ êµ¬ë¶„, í˜¸ì¶œë¶€ì—ì„œ ì²˜ë¦¬)
    print(f"[BALANCE_ERR] {market} ì”ê³  ì¡°íšŒ ì‹¤íŒ¨ ({retries+1}íšŒ ì‹œë„): {last_err}")
    return -1.0  # ğŸ”§ -1 = ì¡°íšŒ ì‹¤íŒ¨ (0 = ì§„ì§œ ì—†ìŒê³¼ êµ¬ë¶„)

def sell_all(market):
    """ì‹¤ì œ ë³´ìœ ëŸ‰ ì „ëŸ‰ ë§¤ë„ (1ì› ì°Œêº¼ê¸° ë°©ì§€)"""
    actual = get_actual_balance(market)
    if actual <= 0:
        print(f"[SELL_ALL] {market} ë³´ìœ ëŸ‰ ì—†ìŒ")
        return None
    # ğŸ”§ í˜„ì¬ê°€ ì¡°íšŒ
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
        cur_price = cur_js[0].get("trade_price", 0) if cur_js else 0
    except Exception:
        cur_price = None
    print(f"[SELL_ALL] {market} ì‹¤ì œ ë³´ìœ ëŸ‰ {actual:.8f} ì „ëŸ‰ ë§¤ë„")
    # ğŸ”§ FIX: ë§¤ë„ ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ ë“±)
    try:
        return place_market_sell(market, actual, price_hint=cur_price)
    except Exception as e:
        print(f"[SELL_ALL_ERR] {market}: {e}")
        # ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œì´ë©´ ì†Œì•¡ ì”ì—¬ë¡œ ê°„ì£¼
        if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
            print(f"[SELL_ALL] {market} ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ì†Œì•¡ ì”ì—¬ ë³´ìœ ")
        return None


def sync_orphan_positions():
    """
    ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™”
    - ì—…ë¹„íŠ¸ì— ì”ê³ ê°€ ìˆì§€ë§Œ OPEN_POSITIONSì— ì—†ëŠ” í¬ì§€ì…˜ ê°ì§€
    - ê°ì§€ëœ í¬ì§€ì…˜ì„ OPEN_POSITIONSì— ì¶”ê°€í•˜ê³  ëª¨ë‹ˆí„°ë§ ì‹œì‘
    - ì„¸ì…˜ ë‚´ 1íšŒë§Œ ì²˜ë¦¬ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€)
    """
    global _LAST_ORPHAN_SYNC, _PREV_SYNC_MARKETS

    now = time.time()
    if now - _LAST_ORPHAN_SYNC < ORPHAN_SYNC_INTERVAL:
        return  # ì•„ì§ ë™ê¸°í™” ì‹œê°„ ì•ˆë¨
    _LAST_ORPHAN_SYNC = now

    try:
        accounts = get_account_info()
        if not accounts:
            print("[ORPHAN_SYNC] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë¹„ì–´ìˆìŒ")
            return

        # ğŸ”§ í˜„ì¬ ì”ê³  ìˆëŠ” ë§ˆì¼“ ìˆ˜ì§‘ (ì²­ì‚°ëœ ê±´ _ORPHAN_HANDLEDì—ì„œ ì œê±°)
        current_markets = set()

        for acc in accounts:
            currency = acc.get("currency", "")
            if currency == "KRW":
                continue

            balance = float(acc.get("balance", "0"))
            avg_buy_price = float(acc.get("avg_buy_price", "0"))

            # ìµœì†Œ ê¸ˆì•¡ ì´ìƒë§Œ (ì°Œêº¼ê¸° ì œì™¸)
            if balance * avg_buy_price < 5000:
                continue

            market = f"KRW-{currency}"
            current_markets.add(market)

            # ì´ë¯¸ ì²˜ë¦¬í•œ ìœ ë ¹ í¬ì§€ì…˜ì´ë©´ ìŠ¤í‚µ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€)
            if market in _ORPHAN_HANDLED:
                continue

            with _POSITION_LOCK:
                if market in OPEN_POSITIONS:
                    continue  # ì´ë¯¸ ì¶”ì  ì¤‘

            # ğŸ”§ FIX: ì´ì „ ë™ê¸°í™”ì— ì—†ë˜ ë§ˆì¼“ì€ ìŠ¤í‚µ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)
            # ì²˜ìŒ ë°œê²¬ëœ ì”ê³ ëŠ” ì •ìƒ ë§¤ìˆ˜ì¼ ê°€ëŠ¥ì„± â†’ ë‹¤ìŒ ì‚¬ì´í´ê¹Œì§€ ëŒ€ê¸°
            if market not in _PREV_SYNC_MARKETS:
                print(f"[ORPHAN] {market} ì‹ ê·œ ë°œê²¬ â†’ ë‹¤ìŒ ì‚¬ì´í´ê¹Œì§€ ëŒ€ê¸° (ì˜¤íƒ ë°©ì§€)")
                continue

            # ğŸ”§ FIX: ìµœê·¼ 5ë¶„ ë‚´ ë§¤ìˆ˜ ì£¼ë¬¸ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ (ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ì˜¤íƒ ë°©ì§€)
            # - í•œ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë§¤ìˆ˜, ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì—ì„œ sync ì‹œ ì˜¤íƒ ë°œìƒ ê°€ëŠ¥
            # - ì—…ë¹„íŠ¸ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒë¡œ ì‹¤ì œ ë§¤ìˆ˜ ì—¬ë¶€ í™•ì¸
            skip_recent_buy = False
            try:
                recent_orders = upbit_private_get("/v1/orders", {
                    "market": market,
                    "state": "done",
                    "limit": 5
                })
                if recent_orders:
                    for order in recent_orders:
                        if order.get("side") == "bid":  # ë§¤ìˆ˜ ì£¼ë¬¸
                            # created_at ì˜ˆ: "2024-01-01T12:00:00+09:00"
                            created_str = order.get("created_at", "")
                            if created_str:
                                try:
                                    from datetime import datetime, timezone, timedelta
                                    # ISO í˜•ì‹ íŒŒì‹±
                                    order_time = datetime.fromisoformat(created_str.replace("Z", "+00:00"))
                                    now_utc = datetime.now(timezone.utc)
                                    age_sec = (now_utc - order_time).total_seconds()
                                    if age_sec < 300:  # 5ë¶„ ì´ë‚´ ë§¤ìˆ˜
                                        print(f"[ORPHAN] {market} ìµœê·¼ ë§¤ìˆ˜ ì£¼ë¬¸ ë°œê²¬ ({age_sec:.0f}ì´ˆ ì „) â†’ ìŠ¤í‚µ")
                                        skip_recent_buy = True
                                        break  # for loop íƒˆì¶œ
                                except Exception as parse_err:
                                    print(f"[ORPHAN] {market} ì£¼ë¬¸ì‹œê°„ íŒŒì‹± ì—ëŸ¬: {parse_err}")
            except Exception as orders_err:
                print(f"[ORPHAN] {market} ì£¼ë¬¸ë‚´ì—­ ì¡°íšŒ ì—ëŸ¬: {orders_err}")
                # ì¡°íšŒ ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë¡œì§ëŒ€ë¡œ ì§„í–‰

            if skip_recent_buy:
                continue  # ğŸ”§ ë‹¤ìŒ ë§ˆì¼“ìœ¼ë¡œ (ìœ ë ¹ ê°ì§€ ìŠ¤í‚µ)

            # ğŸ”§ FIX: ë´‡ ë‚´ë¶€ ìµœê·¼ ë§¤ìˆ˜ ì²´í¬ (300ì´ˆ ë‚´ ë§¤ìˆ˜ë©´ ìœ ë ¹ ì•„ë‹˜)
            # 120ì´ˆ â†’ 300ì´ˆë¡œ ì¦ê°€: ì •ìƒ ë§¤ìˆ˜ ì§í›„ ìœ ë ¹ ì˜¤íƒ ë°©ì§€ ê°•í™”
            last_buy_ts = _RECENT_BUY_TS.get(market, 0)
            if now - last_buy_ts < 300:
                print(f"[ORPHAN] {market} ìµœê·¼ ë§¤ìˆ˜ ({now - last_buy_ts:.0f}ì´ˆ ì „) â†’ ìœ ë ¹ ì•„ë‹˜, ìŠ¤í‚µ")
                continue

            # ğŸ”¥ ìœ ë ¹ í¬ì§€ì…˜ ë°œê²¬! (2ì‚¬ì´í´ ì—°ì† ì¡´ì¬ + OPEN_POSITIONSì— ì—†ìŒ)
            print(f"[ORPHAN] {market} ìœ ë ¹ í¬ì§€ì…˜ ë°œê²¬! ì”ê³ ={balance:.4f} í‰ë‹¨={avg_buy_price:.2f}")

            # í˜„ì¬ê°€ ì¡°íšŒ
            try:
                cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
                cur_price = cur_js[0].get("trade_price", avg_buy_price) if cur_js else avg_buy_price
            except:
                cur_price = avg_buy_price

            # ìˆ˜ìµë¥  ê³„ì‚°
            pnl_pct = ((cur_price / avg_buy_price) - 1.0) * 100 if avg_buy_price > 0 else 0

            # ğŸ”§ FIX: OPEN_POSITIONSì— ì¶”ê°€ ì „ í•œë²ˆ ë” í™•ì¸ (race condition ë°©ì§€)
            with _POSITION_LOCK:
                if market in OPEN_POSITIONS:
                    # ì´ë¯¸ ë‹¤ë¥¸ ê³³(ë©”ì¸ ë£¨í”„)ì—ì„œ ì¶”ê°€ë¨ â†’ ìŠ¤í‚µ
                    print(f"[ORPHAN] {market} ì´ë¯¸ OPEN_POSITIONSì— ìˆìŒ (race ë°©ì§€) â†’ ìŠ¤í‚µ")
                    continue
                OPEN_POSITIONS[market] = {
                    "state": "open",
                    "entry_price": avg_buy_price,
                    "volume": balance,
                    "entry_mode": "orphan",  # ìœ ë ¹ í¬ì§€ì…˜ í‘œì‹œ
                    "ts": now,
                    "orphan_detected": True,
                }

            # í…”ë ˆê·¸ë¨ ì•Œë¦¼
            tg_send(
                f"ğŸ‘» ìœ ë ¹ í¬ì§€ì…˜ ê°ì§€!\n"
                f"â€¢ {market}\n"
                f"â€¢ í‰ë‹¨: {fmt6(avg_buy_price)}ì›\n"
                f"â€¢ í˜„ì¬ê°€: {fmt6(cur_price)}ì› ({pnl_pct:+.2f}%)\n"
                f"â€¢ ìˆ˜ëŸ‰: {balance:.6f}\n"
                f"â†’ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (ATR ì†ì ˆ ì ìš©)"
            )

            # ğŸ”§ ì²˜ë¦¬ ì™„ë£Œ í‘œì‹œ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€) - ë¨¼ì € í‘œì‹œ
            _ORPHAN_HANDLED.add(market)

            # ğŸ”§ ì¦‰ì‹œ ì†ì ˆ ì²´í¬ (ì´ë¯¸ ì†ì ˆì„  ì´í•˜ë©´ ë°”ë¡œ ì²­ì‚°)
            # DYN_SL_MAX = 0.6%, í˜„ì¬ ì†ì‹¤ì´ ê·¸ ì´ìƒì´ë©´ ì¦‰ì‹œ ì²­ì‚°
            if pnl_pct <= -0.6:
                print(f"[ORPHAN] {market} ì´ë¯¸ ì†ì ˆì„  ì´í•˜ ({pnl_pct:.2f}%) â†’ ì¦‰ì‹œ ì²­ì‚°")
                try:
                    close_auto_position(market, f"ìœ ë ¹í¬ì§€ì…˜ ì†ì ˆ | ê°ì§€ ì¦‰ì‹œ {pnl_pct:.2f}%")
                except Exception as e:
                    print(f"[ORPHAN_CLOSE_ERR] {market}: {e}")
                    # ğŸ”§ ì²­ì‚° ì‹¤íŒ¨ ì‹œ OPEN_POSITIONSì—ì„œ ì œê±° (ë‹¤ìŒ ë™ê¸°í™”ì—ì„œ ì¬ì‹œë„)
                    with _POSITION_LOCK:
                        OPEN_POSITIONS.pop(market, None)
                    _ORPHAN_HANDLED.discard(market)
            else:
                # ğŸ”§ FIX: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¤‘ë³µ ë°©ì§€ + ì£½ì€ ìŠ¤ë ˆë“œ ê°ì§€
                with _MONITOR_LOCK:
                    existing_thread = _ACTIVE_MONITORS.get(market)
                    if existing_thread is not None:
                        # ğŸ”§ FIX: ìŠ¤ë ˆë“œê°€ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸ (is_alive)
                        if isinstance(existing_thread, threading.Thread) and existing_thread.is_alive():
                            print(f"[ORPHAN_SKIP] {market} ì´ë¯¸ ëª¨ë‹ˆí„°ë§ ì¤‘ â†’ ìŠ¤ë ˆë“œ ìƒì„± ìŠ¤í‚µ")
                            continue
                        # ì£½ì€ ìŠ¤ë ˆë“œë©´ ì •ë¦¬í•˜ê³  ìƒˆë¡œ ì‹œì‘
                        print(f"[ORPHAN_CLEANUP] {market} ì£½ì€ ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ ì •ë¦¬")
                        _ACTIVE_MONITORS.pop(market, None)

                # ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
                def _orphan_monitor(m, entry_price):
                    try:
                        # ë”ë¯¸ pre ìƒì„±
                        dummy_pre = {
                            "price": entry_price,
                            "ob": {"depth_krw": 10_000_000},
                            "tape": {"buy_ratio": 0.5, "krw": 0, "n": 0, "krw_per_sec": 0},
                        }
                        remonitor_until_close(m, entry_price, dummy_pre, tight_mode=False)
                    except Exception as e:
                        print(f"[ORPHAN_ERR] {m} ëª¨ë‹ˆí„°ë§ ì—ëŸ¬: {e}")
                        # ğŸ”§ FIX: ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ŒëŒ + ì”ê³  í™•ì¸ í›„ ì •ë¦¬
                        try:
                            actual = get_balance_with_locked(m)
                            # ğŸ”§ FIX: -1 = ì¡°íšŒ ì‹¤íŒ¨ â†’ í¬ì§€ì…˜ ìœ ì§€ (ì˜¤íƒ ë°©ì§€)
                            if actual < 0:
                                tg_send(f"âš ï¸ {m} ìœ ë ¹í¬ì§€ì…˜ ì˜¤ë¥˜ (ì”ê³  ì¡°íšŒ ì‹¤íŒ¨)\nâ€¢ ì˜ˆì™¸: {e}\nâ€¢ í¬ì§€ì…˜ ìœ ì§€")
                            elif actual <= 1e-12:
                                tg_send(f"âš ï¸ {m} ìœ ë ¹í¬ì§€ì…˜ ì˜¤ë¥˜ (ì´ë¯¸ ì²­ì‚°ë¨)\nâ€¢ ì˜ˆì™¸: {e}")
                                with _POSITION_LOCK:
                                    OPEN_POSITIONS.pop(m, None)
                                _ORPHAN_HANDLED.discard(m)
                            else:
                                tg_send(f"ğŸš¨ {m} ìœ ë ¹í¬ì§€ì…˜ ì˜¤ë¥˜ â†’ ì²­ì‚° ì‹œë„\nâ€¢ ì˜ˆì™¸: {e}")
                                close_auto_position(m, f"ìœ ë ¹ëª¨ë‹ˆí„°ë§ì˜ˆì™¸ | {e}")
                        except:
                            tg_send(f"ğŸš¨ {m} ìœ ë ¹í¬ì§€ì…˜ ì˜¤ë¥˜\nâ€¢ ì˜ˆì™¸: {e}")
                    finally:
                        # ğŸ”§ FIX: ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ ì‹œ í™œì„± ëª©ë¡ì—ì„œ ì œê±°
                        with _MONITOR_LOCK:
                            _ACTIVE_MONITORS.pop(m, None)

                t = threading.Thread(target=_orphan_monitor, args=(market, avg_buy_price), daemon=True)
                t.start()
                # ğŸ”§ FIX: ìŠ¤ë ˆë“œ ê°ì²´ ì €ì¥ (ident ëŒ€ì‹ )
                with _MONITOR_LOCK:
                    _ACTIVE_MONITORS[market] = t
                print(f"[ORPHAN] {market} ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘")

        # ğŸ”§ ì²­ì‚°ëœ í¬ì§€ì…˜ì€ _ORPHAN_HANDLEDì—ì„œ ì œê±° (ì¬ë§¤ìˆ˜ ì‹œ ë‹¤ì‹œ ê°ì§€ ê°€ëŠ¥)
        closed_markets = _ORPHAN_HANDLED - current_markets
        for m in closed_markets:
            _ORPHAN_HANDLED.discard(m)

        # ğŸ”§ ë‹¤ìŒ ì‚¬ì´í´ì„ ìœ„í•´ í˜„ì¬ ë§ˆì¼“ ì €ì¥ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)
        _PREV_SYNC_MARKETS = current_markets.copy()

    except Exception as e:
        print(f"[ORPHAN_SYNC_ERR] {e}")


# =========================
# ì»· ë¡œê¹… (ìœ„ì¹˜ ì´ë™: final_price_guardì—ì„œ ì‚¬ìš©)
# =========================
DEBUG_CUT = True           # ì „ì²´ ì»· ë¡œê·¸ (Trueë©´ ëª¨ë“  ì»· ì¶œë ¥)
DEBUG_NEAR_MISS = True     # ì´ˆì… ì‹ í˜¸ ì™”ëŠ”ë° gateì—ì„œ ì»·ëœ ê²½ìš°ë§Œ ì¶œë ¥
CUT_COUNTER = {
    k: 0
    for k in [
        "SURGE_LOW", "VOL_LOW", "SPREAD_HIGH", "PRICE_LOW", "ZSC_LOW",
        "VWAP_GAP_LOW", "UPTICK_FAIL", "FAKE_PUMP", "TICKS_LOW", "TURN_LOW",
        "BUY_WEAK", "BUY_WEAK_MANYT", "FRESH_FAIL", "BIDASK_WEAK",
        "IGNITION_OK", "BOT_PINGPONG", "BOT_WASH", "BOTACC_OK", "WICK_SPIKE",
        "ATR_OVERSHOOT", "EMA15M_DOWN", "BUY_DECAY", "EARLY_OK",
        "EARLY_LIGHT_FAIL", "PEAK_CHASE", "POSTCHECK_DROP", "MEGA_PASS",
        "SCORE_LOW", "SPREAD_EXTREME", "PROBE_TICK", "NO_SIGNAL",
        "STAGE1_GATE", "IGNITION_FAIL", "ENTRY_LOCK_FAIL", "PRICE_GUARD_FAIL"
    ]
}


def cut(reason, detail, near_miss=False):
    CUT_COUNTER[reason] = CUT_COUNTER.get(reason, 0) + 1
    # DEBUG_CUT: ì „ì²´ ë¡œê·¸, DEBUG_NEAR_MISS: ì´ˆì… ì‹ í˜¸ í›„ ì»·ë§Œ
    if DEBUG_CUT or (DEBUG_NEAR_MISS and near_miss):
        now_str = now_kst().strftime("%H:%M:%S")
        print(f"[FILTER][{now_str}] {reason:<16} | {detail}")


def cut_summary():
    parts = [
        f"{k}:{v}" for k, v in sorted(
            CUT_COUNTER.items(), key=lambda x: x[1], reverse=True) if v > 0
    ]
    if parts:
        print(f"[CUT_SUMMARY] {' , '.join(parts)}")


def final_price_guard(m, initial_price, max_drift=None, ticks=None):
    """
    ì£¼ë¬¸ ì§ì „ ê°€ê²© ì¬í™•ì¸ (ë™ì  ì„ê³„ì¹˜)
    - initial_price: ì‹ í˜¸ ë°œìƒ ì‹œ ê¸°ì¤€ ê°€ê²© (pre['price'])
    - max_drift: ì‹ í˜¸ê°€ ëŒ€ë¹„ í—ˆìš© ìƒìŠ¹ë¥  (Noneì´ë©´ ë™ì  ê³„ì‚°)
    - ticks: ë³€ë™ì„± ê³„ì‚°ìš© í‹± ë°ì´í„°
    - AGGRESSIVE_MODE=True ì¸ ê²½ìš°, max_drift~max_drift+1.2% êµ¬ê°„ì€
      'ì¶”ê²© ì§„ì…'ìœ¼ë¡œ ì†Œì•¡/í”¼ë¼ë¯¸ë”© ê¸°ë°˜ ì§„ì… í—ˆìš©
    """
    try:
        js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        if not js:
            print(f"[GUARD] {m} í‹°ì»¤ ì¡°íšŒ ì‹¤íŒ¨ â†’ ê°€ë“œ ìŠ¤í‚µ")
            return True, initial_price

        current_price = js[0].get("trade_price", initial_price)
        drift = (current_price / initial_price - 1.0)

        # ğŸ”§ ë™ì  ì„ê³„ì¹˜: ë³€ë™ì„± + ì¥ì„¸ ë°˜ì˜ (ì‹ í˜¸â†’ì£¼ë¬¸ ì§§ì€ êµ¬ê°„)
        if max_drift is None:
            pstd = price_band_std(ticks or [], sec=10) if ticks else None
            pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬
            r = relax_knob()  # 0~1.5
            # ğŸ”§ 0.5% ê¸°ì¤€ (ì§§ì€ ìˆœê°„ 0.5% ì›€ì§ì„ì´ë©´ ì¶©ë¶„)
            base = 0.005 if not AGGRESSIVE_MODE else 0.006
            # ğŸ”§ ì•¼ê°„(0~6ì‹œ) ì¶”ê²© í—ˆìš©í­ +0.1% ì™„í™”
            hour = now_kst().hour
            if 0 <= hour < 6:
                base += 0.001
            dyn = base + min(0.004, pstd * 0.5) + r * 0.002
            thr = dyn
        else:
            thr = max_drift

        if drift > thr:
            # í‰ì†Œë¼ë©´ ê³ ì  ì¶”ê²©ìœ¼ë¡œ ì»·
            # í•˜ì§€ë§Œ ê³µê²© ëª¨ë“œë©´ ì¼ì • êµ¬ê°„ê¹Œì§€ëŠ” í—ˆìš©
            # ğŸ”§ FIX: ì¶”ê²© í—ˆìš©í­ 0.5%â†’0.3% ì¶•ì†Œ (ê¸°ëŒ€ê°’ ê°œì„ )
            if AGGRESSIVE_MODE and drift <= (thr + 0.003):
                print(
                    f"[GUARD][AGGR] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% <= dyn+0.3% "
                    f"â†’ ê³µê²© ëª¨ë“œ: ì¶”ê²© ì§„ì… í—ˆìš©"
                )
                return True, current_price

            # ì´ ì´ìƒì€ ì§„ì§œ ë„ˆë¬´ íŠ„ ê±°ë¼ ì»· (signal_skipì—ì„œ ë¡œê·¸ ì²˜ë¦¬)
            return False, current_price

        # ğŸ”§ FIX: í•˜ë°© ê¸‰ë½ ì»· (í˜ì´í¬ ë¸Œë ˆì´í¬ ë°©ì§€)
        down_thr = max(0.005, thr * 0.8)  # ğŸ”§ 0.5% ë˜ëŠ” ìƒë‹¨ì˜ 80%
        if drift < -down_thr:
            # ê¸‰ë½ ì»· (signal_skipì—ì„œ ë¡œê·¸ ì²˜ë¦¬)
            return False, current_price

        return True, current_price

    except Exception as e:
        print(f"[GUARD_ERR] {m}: {e} â†’ 1íšŒ ì¬ì‹œë„")
        # ğŸ”§ FIX: API ì‹¤íŒ¨ ì‹œ 1íšŒ ì¬ì‹œë„ (ë„¤íŠ¸ì›Œí¬ ìˆœê°„ ì¥ì• ë¡œ ê¸°íšŒì†ì‹¤ ë°©ì§€)
        # - ê¸°ì¡´: ë¬´ì¡°ê±´ ì°¨ë‹¨ â†’ ì¢‹ì€ ì‹ í˜¸ë„ ë‚ ë¦´ ìˆ˜ ìˆìŒ
        # - ê°œì„ : 0.3ì´ˆ í›„ 1íšŒ ì¬ì‹œë„, ê·¸ë˜ë„ ì‹¤íŒ¨ë©´ ì°¨ë‹¨
        try:
            time.sleep(0.3)
            js_retry = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            if js_retry:
                current_price = js_retry[0].get("trade_price", initial_price)
                drift = (current_price / initial_price - 1.0)
                # ì¬ì‹œë„ ì„±ê³µ ì‹œ ê°„ë‹¨íˆ ìƒìŠ¹ë¥ ë§Œ ì²´í¬ (ë™ì  ì„ê³„ì¹˜ëŠ” ê¸°ë³¸ê°’ ì‚¬ìš©)
                if drift <= 0.006:  # 0.6% ì´í•˜ë©´ í†µê³¼
                    print(f"[GUARD_RETRY_OK] {m} ì¬ì‹œë„ ì„±ê³µ (drift={drift*100:.2f}%)")
                    return True, current_price
                else:
                    print(f"[GUARD_RETRY_FAIL] {m} ì¬ì‹œë„ ì„±ê³µí–ˆìœ¼ë‚˜ ê¸‰ë“± (drift={drift*100:.2f}%)")
                    return False, current_price
        except Exception as e2:
            print(f"[GUARD_RETRY_ERR] {m}: {e2}")
        return False, initial_price

# =========================
# ğŸ”¥ ìë™ ë§¤ìˆ˜ ì§„ì…
# =========================
def open_auto_position(m, pre, dyn_stop, eff_sl_pct):
    """
    ì´ˆì…Â·ê³µê²©ëª¨ë“œ ëŒ€ì‘ ìë™ ë§¤ìˆ˜ ì§„ì…
    """
    # ğŸ” DEBUG: ìë™ë§¤ìˆ˜ ì§„ì… ì‹œì‘ ë¡œê·¸
    print(f"[AUTO_ENTRY] {m} ì‹œì‘ (AUTO_TRADE={AUTO_TRADE})")

    def signal_skip(reason):
        """ì´ˆì…ì‹ í˜¸ í›„ ë§¤ìˆ˜ ìŠ¤í‚µ ë¡œê·¸ (near_miss ì¶œë ¥ìš©)"""
        if DEBUG_NEAR_MISS:
            now_str = now_kst().strftime("%H:%M:%S")
            print(f"[SIGNAL_SKIP][{now_str}] {m} | {reason}")

    if not AUTO_TRADE:
        signal_skip("AUTO_TRADE=False (í™˜ê²½ë³€ìˆ˜ AUTO_TRADE=1 í•„ìš”)")
        return

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        signal_skip("API í‚¤ ë¯¸ì„¤ì •")
        return

    # ğŸ” í”„ë¡œì„¸ìŠ¤ ê°„ ì¤‘ë³µ ì§„ì… ë°©ì§€ (íŒŒì¼ë½+ë©”ëª¨ë¦¬ë½ ì»¨í…ìŠ¤íŠ¸)
    # ğŸ”§ FIX: reentrant=False (í˜¸ì¶œ ì „ ë½ í•´ì œë¨ â†’ ì—¬ê¸°ì„œ íšë“/í•´ì œ ì™„ê²°)
    with entry_lock(m, ttl_sec=90, reentrant=False) as got_lock:
        if not got_lock:
            signal_skip("entry_lock íšë“ ì‹¤íŒ¨")
            return

        # ğŸ”§ pending ìƒíƒœ ì›ìí™” (ë½ ì•ˆì—ì„œë§Œ ì¡°ì‘)
        with _POSITION_LOCK:
            existing = OPEN_POSITIONS.get(m)
            if existing:
                if not existing.get("pre_signal"):
                    signal_skip("ì´ë¯¸ í¬ì§€ì…˜ ë³´ìœ ì¤‘")
                    return
            active_count = sum(1 for p in OPEN_POSITIONS.values() if p.get("state") == "open")
            if active_count >= MAX_POSITIONS:
                signal_skip(f"ìµœëŒ€ í¬ì§€ì…˜ {MAX_POSITIONS}ê°œ ë„ë‹¬")
                tg_send_mid(f"âš ï¸ {m} ì‹ ê·œ ì§„ì… ëŒ€ê¸° (ìµœëŒ€ {MAX_POSITIONS}ê°œ í¬ì§€ì…˜ ë³´ìœ  ì¤‘)")
                # ğŸ”§ FIX: pending ìƒíƒœì¸ ê²½ìš°ì—ë§Œ ì œê±° (ë‹¤ë¥¸ ìƒíƒœ ë³´í˜¸)
                if existing and existing.get("state") == "pending":
                    OPEN_POSITIONS.pop(m, None)
                return
            if not existing:
                OPEN_POSITIONS[m] = {"state": "pending"}

        signal_price = pre.get("price")
        if not signal_price:
            signal_skip("pre['price'] ì—†ìŒ")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì…ëª¨ë“œ ë°˜ì˜ ===
        entry_mode = pre.get("entry_mode", "confirm")

        if entry_mode == "probe":
            entry_fraction = 0.10   # ğŸ”§ 10%ë¡œ ì¶•ì†Œ (ì†Œì•¡ íƒìƒ‰)
            mode_emoji = "ğŸ§­"
        elif entry_mode == "half":
            entry_fraction = 0.50   # ğŸ”§ 50% ì‚¬ì´ì¦ˆ (ì¤‘ê°„ íšŒì „ìœ¨)
            mode_emoji = "âš¡"
        elif entry_mode == "confirm":
            entry_fraction = 1.0    # ì „ì²´ ê¸ˆì•¡ (í™•ì • ì§„ì…)
            mode_emoji = "ğŸ”¥"
        else:
            entry_fraction = 1.0
            mode_emoji = "ğŸ¤–"

        # ========================================
        # ğŸš€ Pre-break ì „ìš© 2ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬
        # ========================================
        filter_type = pre.get("filter_type", "")
        if filter_type == "prebreak" and PREBREAK_POSTCHECK_SEC > 0:
            print(f"[PREBREAK] {m} â†’ {PREBREAK_POSTCHECK_SEC}ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ ì‹œì‘")
            time.sleep(PREBREAK_POSTCHECK_SEC)

            # í‹± ì¬ì¡°íšŒ
            ticks_recheck = get_recent_ticks(m, 100)
            if not ticks_recheck:
                signal_skip("PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: í‹± ì—†ìŒ")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            t15_recheck = micro_tape_stats_from_ticks(ticks_recheck, 15)

            # ë§¤ìˆ˜ë¹„/ê±°ë˜ì†ë„ ì¬í™•ì¸
            if t15_recheck["buy_ratio"] < PREBREAK_BUY_MIN * 0.9:  # 10% ì—¬ìœ 
                signal_skip(f"PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: ë§¤ìˆ˜ë¹„ í•˜ë½ ({t15_recheck['buy_ratio']:.0%})")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            if t15_recheck["krw_per_sec"] < PREBREAK_KRW_PER_SEC_MIN * 0.7:  # 30% ì—¬ìœ 
                signal_skip(f"PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: ê±°ë˜ì†ë„ í•˜ë½ ({t15_recheck['krw_per_sec']/1000:.0f}K)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            print(f"[PREBREAK] {m} í¬ìŠ¤íŠ¸ì²´í¬ í†µê³¼ â†’ ì§„ì… ì§„í–‰")

        # â˜… ë™ì  ê°€ê²© ê°€ë“œ (ë³€ë™ì„± + ì¥ì„¸ ë°˜ì˜)
        # ticks ì „ë‹¬ë¡œ ë™ì  ì„ê³„ì¹˜ ê³„ì‚°
        ok_guard, current_price = final_price_guard(m, signal_price, ticks=pre.get("ticks"))
        if not ok_guard:
            drift_pct = (current_price / signal_price - 1) * 100
            signal_skip(f"ê°€ê²©ê°€ë“œ ì‹¤íŒ¨ (ì‹ í˜¸ê°€â†’í˜„ì¬ê°€ {drift_pct:+.2f}%)")
            tg_send(
                f"âš ï¸ <b>ì§„ì… ì·¨ì†Œ</b> {m}\n"
                f"â€¢ ì‹ í˜¸ê°€: {fmt6(signal_price)}ì›\n"
                f"â€¢ í˜„ì¬ê°€: {fmt6(current_price)}ì›\n"
                f"â€¢ ìƒìŠ¹ë¥ : {drift_pct:.2f}%\n"
                f"â€¢ ì‚¬ìœ : ê°€ê²© ê¸‰ë“± (ì´ˆì… ì¶”ê²© ìœ„í—˜)"
            )
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === ê³„ì¢Œ & ì£¼ë¬¸ê¸ˆì•¡ ê³„ì‚° ===
        accounts = get_account_info()
        if not accounts:
            signal_skip("ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # ğŸ”§ FIX: locked ë°˜ì˜í•œ ê°€ìš©ì”ê³  ê³„ì‚°
        krw_bal = get_available_krw(accounts)

        if krw_bal < 6000:
            signal_skip(f"KRW ë¶€ì¡± ({krw_bal:,.0f}ì›)")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        entry_price = current_price

        # ğŸ”§ FIX (A): í˜„ì¬ê°€ ê¸°ì¤€ìœ¼ë¡œ SL ì¬ê³„ì‚° (ì‹ í˜¸ê°€ì™€ í˜„ì¬ê°€ ì°¨ì´ ë³´ì •)
        # - ê¸°ì¡´: dyn_stopì€ ì‹ í˜¸ ì‹œì  ê°€ê²© ê¸°ì¤€ â†’ í˜„ì¬ê°€ë¡œ ì§„ì… ì‹œ ì†ì ˆí­ ë¶ˆì¼ì¹˜
        # - ê°œì„ : final_price_guard í†µê³¼ í›„ í˜„ì¬ê°€ ê¸°ì¤€ìœ¼ë¡œ dynamic_stop_loss ì¬ê³„ì‚°
        c1_for_sl = pre.get("c1")
        signal_type = pre.get("signal_type", None)
        if c1_for_sl:
            new_stop, new_sl_pct, sl_info = dynamic_stop_loss(entry_price, c1_for_sl, signal_type, entry_price)
            stop_price = new_stop
            eff_sl_pct = new_sl_pct
            print(f"[SL_RECALC] {m} í˜„ì¬ê°€ ê¸°ì¤€ SL ì¬ê³„ì‚°: {eff_sl_pct*100:.2f}% (stop={fmt6(stop_price)})")
        else:
            # c1 ì—†ìœ¼ë©´ ê¸°ì¡´ dyn_stop ì‚¬ìš© (í´ë°±)
            stop_price = dyn_stop
            print(f"[SL_RECALC] {m} c1 ì—†ìŒ â†’ ê¸°ì¡´ SL ì‚¬ìš©")

        # âœ… ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë™ì  ë¦¬ìŠ¤í¬
        adaptive_risk = get_adaptive_risk()

        # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… êµ¬ì¡° ===
        risk_to_use = adaptive_risk * SEED_RISK_FRACTION if USE_PYRAMIDING else adaptive_risk
        risk_to_use *= entry_fraction  # probeëŠ” ë¦¬ìŠ¤í¬ ì¶•ì†Œ ë°˜ì˜

        base_qty = calc_position_size(
            entry_price,
            stop_price,
            krw_bal,
            risk_to_use,
        )

        krw_to_use = base_qty * entry_price

        # ğŸ”§ FIX: ê°€ìš©ì”ê³  ì´ˆê³¼ ë°©ì§€ (ì•ŒíŠ¸ 1ì¢…ëª© ê³¼ì§‘ì¤‘ ë°©ì§€)
        MAX_POSITION_RATIO = 0.35  # ğŸ”§ 0.95â†’0.35 (ê°€ìš©ì”ê³ ì˜ 35% ìƒí•œ)
        if krw_to_use > krw_bal * MAX_POSITION_RATIO:
            print(f"[SIZE_CAP] {m} ì£¼ë¬¸ {krw_to_use:,.0f} > ê°€ìš©ì”ê³  {krw_bal:,.0f}ì˜ 35% â†’ ìº¡")
            krw_to_use = krw_bal * MAX_POSITION_RATIO

        # ğŸ”§ probeëŠ” ìµœì†Œ 7000ì›, confirmì€ 5000ì›
        min_order_krw = 7000 if entry_mode == "probe" else 5000
        if krw_to_use < min_order_krw:
            # probeì¸ë° ê¸ˆì•¡ ë¶€ì¡±í•˜ë©´ 7000ì›ìœ¼ë¡œ ê°•ì œ ì„¤ì •
            if entry_mode == "probe" and krw_bal >= 7000:
                krw_to_use = 7000
                print(f"[AUTO] probe ìµœì†Œê¸ˆì•¡ ì ìš©: {krw_to_use:,.0f}ì›")
            else:
                signal_skip(f"ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± ({krw_to_use:,.0f}ì› < {min_order_krw:,}ì›)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

        # ğŸ”§ ì²´ê²°ì¶©ê²©(impact) ê¸°ë°˜ ì‚¬ì´ì§• ëŒí¼
        # ìƒìœ„ 3í˜¸ê°€ í•©ê³„ì˜ 15% ì´ˆê³¼ ì‚¬ìš© ì‹œ ê³¼ë„ â†’ ìº¡ (ìŠ¬ë¦¬í”¼ì§€ ë°©ì§€)
        try:
            units = pre.get("ob", {}).get("raw", {}).get("orderbook_units", [])[:3]
            top3_ask_krw = sum(float(u["ask_price"]) * float(u["ask_size"]) for u in units)
        except Exception:
            top3_ask_krw = 0.0

        if top3_ask_krw > 0:
            cap = top3_ask_krw * 0.15  # ìƒìœ„ 3í˜¸ê°€ í•©ê³„ì˜ 15%
            if krw_to_use > cap:
                print(f"[IMPACT_CAP] {m} ì£¼ë¬¸ {krw_to_use:,.0f} > 15% of top3-ask {cap:,.0f} â†’ ìº¡")
                krw_to_use = int(cap)
                # ğŸ”§ FIX: confirmì´ë©´ entry_modeë¥¼ halfë¡œ ë³€ê²½ (í¬ì§€ì…˜ ì¶”ì ì— ë°˜ì˜)
                # - ê¸°ì¡´: entry_fractionë§Œ ë³€ê²½ â†’ ì´ë¯¸ ì‚¬ì´ì§• ì™„ë£Œë¼ ë¬´íš¨
                # - ë³€ê²½: entry_mode ìì²´ë¥¼ ë°”ê¿”ì„œ OPEN_POSITIONSì— ì •í™•íˆ ê¸°ë¡
                if entry_mode == "confirm":
                    entry_mode = "half"
                    print(f"[IMPACT_CAP] {m} confirm â†’ half ì „í™˜ (ì„íŒ©íŠ¸ìº¡ ì ìš©)")

        krw_to_use = int(krw_to_use)

        # ğŸ”§ FIX: ì„íŒ©íŠ¸ìº¡ í›„ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ì¬ê²€ì¦
        min_order_krw = 7000 if entry_mode == "probe" else 5000
        if krw_to_use < min_order_krw:
            if entry_mode == "probe" and krw_bal >= 7000:
                krw_to_use = 7000
                print(f"[AUTO] probe ìµœì†Œê¸ˆì•¡ ì ìš©(ì„íŒ©íŠ¸ìº¡ í›„): {krw_to_use:,.0f}ì›")
            else:
                signal_skip(f"ì„íŒ©íŠ¸ìº¡ í›„ ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± ({krw_to_use:,.0f}ì›)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

        # === ë§¤ìˆ˜ ===
        # ğŸ”§ FIX: ë§¤ìˆ˜ ì „ ë³´ìœ ëŸ‰ ì €ì¥ (ì²´ê²° ì¬ê²€ì¦ìš©)
        # - odê°€ None/timeout/executed 0ì´ì–´ë„ ì‹¤ì œ ì²´ê²°ëì„ ìˆ˜ ìˆìŒ
        # - prev_balance ëŒ€ë¹„ ì¦ê°€ ì‹œì—ë§Œ í¬ì§€ì…˜ ìƒì„± â†’ ì˜¤íƒ ë°©ì§€
        coin = m.replace("KRW-", "")
        prev_balance = 0.0
        try:
            for acc in accounts:
                if acc.get("currency") == coin:
                    prev_balance = float(acc.get("balance") or "0")
                    break
        except Exception:
            prev_balance = 0.0

        try:
            res = place_market_buy(m, krw_to_use)
            print("[AUTO_BUY_RES]", json.dumps(res, ensure_ascii=False))
            oid = res.get("uuid") if isinstance(res, dict) else None
            od = get_order_result(oid, timeout_sec=12) if oid else None
            print("[AUTO_BUY_ORDER]", json.dumps(od, ensure_ascii=False))

            if od:
                volume_filled = float(od.get("executed_volume") or "0")
            else:
                volume_filled = 0.0

            # ğŸ”§ FIX: ì²´ê²° 0ì´ë©´ ì”ê³  ì¬ê²€ì¦ (prev_balance ëŒ€ë¹„ ì¦ê°€ ì‹œì—ë§Œ ë³µêµ¬)
            # - odê°€ None/timeout/executed 0ì´ì–´ë„ ì‹¤ì œ ì²´ê²°ëì„ ìˆ˜ ìˆìŒ
            # - ì „ë©´ ì”ê³  fallback ë¶€í™œ X â†’ prev_balance ëŒ€ë¹„ ì¦ê°€ë¶„ë§Œ ì¸ì • (ì˜¤íƒ ë°©ì§€)
            if volume_filled <= 0:
                # 1íšŒ ì¬ê²€ì¦: ì”ê³ ê°€ prev_balanceë³´ë‹¤ ì¦ê°€í–ˆëŠ”ì§€ í™•ì¸
                try:
                    time.sleep(0.5)  # ì—…ë¹„íŠ¸ ì”ê³  ë°˜ì˜ ëŒ€ê¸°
                    accounts_retry = get_account_info()
                    new_balance = 0.0
                    avg_buy_price_from_acc = entry_price
                    for acc in accounts_retry:
                        if acc.get("currency") == coin:
                            new_balance = float(acc.get("balance") or "0")
                            avg_buy_price_from_acc = float(acc.get("avg_buy_price") or "0")
                            break

                    balance_diff = new_balance - prev_balance
                    if balance_diff > 1e-8:  # ì¦ê°€ë¶„ ì¡´ì¬ â†’ ì‹¤ì œ ì²´ê²°ë¨
                        volume_filled = balance_diff
                        avg_price = avg_buy_price_from_acc if avg_buy_price_from_acc > 0 else entry_price
                        print(f"[BUY_VERIFY] {m} od ì‹¤íŒ¨í–ˆìœ¼ë‚˜ ì”ê³  ì¦ê°€ í™•ì¸: {prev_balance:.8f} â†’ {new_balance:.8f} (ì²´ê²°ëŸ‰: {volume_filled:.8f})")
                        tg_send(f"ğŸ”„ {m} ì²´ê²° ì¬ê²€ì¦ ì„±ê³µ\nâ€¢ ì”ê³  ë³€í™”: {prev_balance:.6f} â†’ {new_balance:.6f}\nâ€¢ ì²´ê²°ëŸ‰: {volume_filled:.6f}")
                    else:
                        # ì¦ê°€ ì—†ìŒ â†’ ì§„ì§œ ì‹¤íŒ¨
                        signal_skip("ì²´ê²° 0 (ì”ê³  ì¬ê²€ì¦ ì‹¤íŒ¨)")
                        tg_send(f"âš ï¸ {m} ìë™ë§¤ìˆ˜ ì²´ê²° 0 (ì”ê³  ë³€í™” ì—†ìŒ) â†’ í¬ì§€ì…˜ ìƒì„± ì•ˆ í•¨")
                        with _POSITION_LOCK:
                            OPEN_POSITIONS.pop(m, None)
                        return
                except Exception as ve:
                    print(f"[BUY_VERIFY_ERR] {m} ì¬ê²€ì¦ ì‹¤íŒ¨: {ve}")
                    signal_skip(f"ì²´ê²° 0 (ì¬ê²€ì¦ ì˜ˆì™¸)")
                    tg_send(f"âš ï¸ {m} ìë™ë§¤ìˆ˜ ì²´ê²° 0 (ì¬ê²€ì¦ ì‹¤íŒ¨) â†’ í¬ì§€ì…˜ ìƒì„± ì•ˆ í•¨")
                    with _POSITION_LOCK:
                        OPEN_POSITIONS.pop(m, None)
                    return

            # í‰ê· ê°€ ê³„ì‚° (ì²´ê²° ì •ë³´ê°€ ìˆìœ¼ë©´)
            if 'avg_price' not in locals():
                trades = od.get("trades") or [] if od else []
                if trades:
                    total_krw = sum(float(tr["price"]) * float(tr["volume"]) for tr in trades)
                    total_vol = sum(float(tr["volume"]) for tr in trades)
                    avg_price = total_krw / total_vol if total_vol > 0 else entry_price
                else:
                    avg_price = float(entry_price)

        except Exception as e:
            print("[AUTO BUY ERR]", e)
            # ğŸ”§ FIX: ì˜ˆì™¸ ì‹œ ì‹¤íŒ¨ ì²˜ë¦¬ (ì”ê³  fallback ì œê±° - ì´ì „ ì”ê³  ì˜¤íŒ ë°©ì§€)
            signal_skip(f"ë§¤ìˆ˜ ì˜ˆì™¸ ({e})")
            tg_send(f"âš ï¸ ë§¤ìˆ˜ ì‹¤íŒ¨ {m}\n{e}")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === í¬ì§€ì…˜ ì €ì¥ ===
        # ğŸ”§ FIX: avg_price ê¸°ì¤€ìœ¼ë¡œ stop ì¬ê³„ì‚° (ì²´ê²° ìŠ¬ë¦½ ë°˜ì˜)
        # - ê¸°ì¡´: dyn_stopì€ ì‹ í˜¸ ì‹œì  ê°€ê²©(signal_price) ê¸°ì¤€ â†’ ì²´ê²°ê°€ì™€ ê´´ë¦¬ ë°œìƒ ê°€ëŠ¥
        # - ë³€ê²½: ì‹¤ì œ ì²´ê²°ê°€(avg_price) ê¸°ì¤€ìœ¼ë¡œ ì†ì ˆê°€ ì¬ê³„ì‚°
        adjusted_stop = avg_price * (1 - eff_sl_pct)
        with _POSITION_LOCK:
            OPEN_POSITIONS[m] = {
                "entry_price": avg_price,
                "volume": volume_filled,
                "stop": adjusted_stop,  # ğŸ”§ avg_price ê¸°ì¤€
                "sl_pct": eff_sl_pct,
                "state": "open",
                "last_add_ts": 0.0,
                "entry_mode": entry_mode,  # ğŸ”§ FIX: IMPACT_CAP ì „í™˜ ë°˜ì˜ (pre ëŒ€ì‹  ë¡œì»¬ ë³€ìˆ˜)
                "entry_ts": time.time(),  # ğŸ§  ì§„ì… ì‹œê° (í•™ìŠµìš©)
                "signal_tag": pre.get("signal_tag", "ê¸°ë³¸"),  # ğŸ”§ MFE ìµì ˆ ê²½ë¡œìš©
            }

        slip_pct = (avg_price / signal_price - 1.0) if signal_price else 0.0
        # ğŸ”§ FIX: ìŠ¬ë¦¬í”¼ì§€ ê¸°ë¡ - ì ˆëŒ“ê°’ ì‚¬ìš© (ìŒìˆ˜=ìœ ë¦¬í•œ ìŠ¬ë¦¬í”¼ì§€ë„ í¬í•¨)
        # ê¸°ì¡´: slip_pct > 0ë§Œ ê¸°ë¡ â†’ ìƒ˜í”Œ ì™œê³¡
        # ìˆ˜ì •: ì ˆëŒ“ê°’ + 1% ìº¡ (ì´ìƒì¹˜ ë°©ì§€, ì‹¤ì œ íŠ¸ë¦¼ì€ percentileë¡œ)
        slip_abs = min(0.01, abs(slip_pct))  # 1% ìº¡
        _ENTRY_SLIP_HISTORY.append(slip_abs)  # ğŸ”§ FIX: entry ì „ìš©
        _SLIP_HISTORY.append(slip_abs)  # í•˜ìœ„í˜¸í™˜

        # ì§„ì… ì‚¬ìœ  í•œ ì¤„ ìƒì„± (ë””í…Œì¼ í¬í•¨)
        kd = pre.get("killer_details", {})
        checks = kd.get("checks", {})
        thr = kd.get("thresholds", {})  # ì„ê³„ì¹˜
        score = pre.get("score", 0)
        vol_b = kd.get('vol_base', 0)
        vol_s = kd.get('vol_surge', 1)
        buy_r = kd.get('buy_ratio', 0)
        turn_r = kd.get('turn', 0)
        imb = kd.get('imbalance', 0)
        consec = kd.get('consecutive_buys', 0)


        # ğŸ”§ ëŒ€ê¸ˆ/ë°°ìˆ˜ í‘œì‹œ í¬ë§·
        if vol_b >= 1e8:
            vol_str = f"{vol_b/1e8:.1f}ì–µ"
        elif vol_b >= 1e6:
            vol_str = f"{vol_b/1e6:.0f}ë°±ë§Œ"
        else:
            vol_str = f"{vol_b/1e4:.0f}ë§Œ"
        surge_str = f"{vol_s:.1f}x" if vol_s >= 1.0 else f"{vol_s:.2f}x"

        # ğŸ”§ ì§„ì… ì‚¬ìœ : ê°’/ê¸°ì¤€ í˜•íƒœ (ì²´í¬X ì œê±°)
        signal_tag = pre.get("signal_tag", "ê¸°ë³¸")
        thr_buy = thr.get('buy', 0.7)
        thr_turn = thr.get('turn', 0.08)
        thr_imb = thr.get('imb', 0.3)

        detail_str = (f"ëŒ€ê¸ˆ{vol_str} ë°°ìˆ˜{surge_str} "
                      f"ë§¤ìˆ˜{buy_r:.0%}/{thr_buy:.0%} íšŒì „{turn_r:.0%}/{thr_turn:.0%} "
                      f"ì„ë°¸{imb:.2f}/{thr_imb}")

        # ğŸ”§ ìŠ¤ì½”ì–´ ê¸°ë°˜ ì§„ì…ëª¨ë“œ ë¼ë²¨ (probe/half/confirm)
        if entry_mode == "probe":
            mode_label = "íƒìƒ‰ì§„ì…"      # ìŠ¤ì½”ì–´ < 55, 10% ì†Œì•¡
        elif entry_mode == "half":
            mode_label = "ì¤‘ê°„ì§„ì…"      # ìŠ¤ì½”ì–´ 55~70, 50% ì‚¬ì´ì¦ˆ
        else:  # confirm
            mode_label = "í™•ì •ì§„ì…"      # ìŠ¤ì½”ì–´ >= 70, í’€ ì‚¬ì´ì¦ˆ
        entry_reason = f"{signal_tag} ({detail_str})"

        # ğŸ”§ ì‹¤ì œ ë¹„ìœ¨ ê³„ì‚° (ìµœì†Œê¸ˆì•¡ ì ìš© ì‹œ entry_fractionê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
        actual_pct = (krw_to_use / krw_bal * 100) if krw_bal > 0 else 0

        # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
        filter_type = pre.get("filter_type", "stage1_gate")
        if filter_type == "prebreak":
            path_str = "ğŸš€ì„ í–‰ì§„ì…"
        else:
            path_str = pre.get("signal_tag", "ê¸°ë³¸")

        # âœ… ì†ì ˆê°€ None ë°©ì§€
        safe_stop_str = fmt6(stop_price) if isinstance(stop_price, (int, float)) and stop_price > 0 else "ê³„ì‚°ì¤‘"

        tg_send(
            f"{mode_emoji} <b>[{mode_label}] ìë™ë§¤ìˆ˜</b> {m}\n"
            f"â€¢ ì‚¬ìœ : {entry_reason}\n"
            f"â€¢ ì‹ í˜¸ê°€: {fmt6(signal_price)}ì›\n"
            f"â€¢ ì²´ê²°ê°€: {fmt6(avg_price)}ì›\n"
            f"â€¢ ìŠ¬ë¦¬í”¼ì§€: {slip_pct*100:+.3f}%\n"
            f"â€¢ ì£¼ë¬¸ê¸ˆì•¡: {krw_to_use:,.0f}ì› ({actual_pct:.1f}%)\n"
            f"â€¢ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
            f"â€¢ ì†ì ˆê°€: {safe_stop_str}ì›\n"
            f"{link_for(m)}"
        )

        # ğŸ”§ FIX: ìµœê·¼ ë§¤ìˆ˜ ì‹œê°„ ê¸°ë¡ (ìœ ë ¹ ì˜¤íƒ ë°©ì§€)
        _RECENT_BUY_TS[m] = time.time()

        # === ğŸ§  í”¼ì²˜ ë¡œê¹… (ìë™ í•™ìŠµìš©) ===
        if AUTO_LEARN_ENABLED:
            try:
                ob = pre.get("ob", {})
                t = pre.get("tape", {})
                ticks = pre.get("ticks", [])
                imbalance = calc_orderbook_imbalance(ob) if ob else 0
                turn = t.get("krw", 0) / max(ob.get("depth_krw", 1), 1) if ob else 0

                # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°
                cons_buys = calc_consecutive_buys(ticks, 15)
                t15_stats = micro_tape_stats_from_ticks(ticks, 15)
                avg_krw = calc_avg_krw_per_tick(t15_stats)
                flow_accel = calc_flow_acceleration(ticks)

                # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ê³„ì‚°
                ia_stats = inter_arrival_stats(ticks, 30) if ticks else {"cv": 0.0}
                cv = ia_stats.get("cv", 0.0)
                pstd = price_band_std(ticks, sec=10) if ticks else None
                pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬
                overheat = flow_accel * float(pre.get("volume_surge", 1.0))
                # í‹± ì‹ ì„ ë„
                fresh_age = 0.0
                if ticks:
                    now_ms = int(time.time() * 1000)
                    last_tick_ts = ticks[0].get("timestamp", now_ms)
                    fresh_age = (now_ms - last_tick_ts) / 1000.0
                # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
                try:
                    u0 = ob.get("raw", {}).get("orderbook_units", [])[0]
                    best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
                except Exception:
                    best_ask_krw = 0.0

                # ğŸ” ê²½ë¡œ ì •ë³´: signal_tag í•˜ë‚˜ë¡œ í†µì¼
                log_trade_features({
                    "ts": now_kst_str(),
                    "market": m,
                    "entry_price": avg_price,
                    "buy_ratio": t.get("buy_ratio", 0),
                    "spread": ob.get("spread", 0),
                    "turn": turn,
                    "imbalance": imbalance,
                    "volume_surge": pre.get("volume_surge", 1.0),
                    "fresh": 1 if last_two_ticks_fresh(ticks) else 0,
                    "score": pre.get("score", 0),
                    "entry_mode": entry_mode,
                    "signal_tag": pre.get("signal_tag", "ê¸°ë³¸"),
                    "filter_type": pre.get("filter_type", "stage1_gate"),
                    # ğŸ”¥ ìƒˆ ì§€í‘œ
                    "consecutive_buys": cons_buys,
                    "avg_krw_per_tick": round(avg_krw, 0),
                    "flow_acceleration": round(flow_accel, 2),
                    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
                    "overheat": round(overheat, 2),
                    "fresh_age": round(fresh_age, 2),
                    "cv": round(cv, 2),
                    "pstd": round(pstd * 100, 4),  # % ë‹¨ìœ„
                    "best_ask_krw": int(best_ask_krw),
                })
            except Exception as e:
                print(f"[FEATURE_LOG_ERR] {e}")

        # ğŸ” ì»¨í…ìŠ¤íŠ¸ ì¢…ë£Œ ì‹œ entry_lock ìë™ í•´ì œ

def add_auto_position(m, cur_price, reason=""):
    """
    ì´ë¯¸ seed í¬ì§€ì…˜ì´ ìˆì„ ë•Œ, ê°•í•œ ì¶”ì„¸ì—ì„œ 1íšŒ ì¶”ë§¤(add) ìˆ˜í–‰
    - ADD_RISK_FRACTION ë¹„ìœ¨ë§Œí¼ RISK_PER_TRADEë¥¼ ë‹¤ì‹œ ì‚¬ìš©
    - í‰ê· ë‹¨ê°€ ì¬ê³„ì‚°
    """
    if not AUTO_TRADE:
        return False, None

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        return False, None

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            return False, None
        if pos.get("added"):
            # ì´ë¯¸ í•œ ë²ˆ ì¶”ë§¤í•œ í¬ì§€ì…˜
            return False, None
        last_add_ts = pos.get("last_add_ts", 0.0)

    now = time.time()
    if (now - last_add_ts) < PYRAMID_ADD_COOLDOWN_SEC:
        return False, None

    accounts = get_account_info()
    if not accounts:
        print("[AUTO_ADD] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
        return False, None

    # ğŸ”§ FIX: locked ë°˜ì˜í•œ ê°€ìš©ì”ê³  ê³„ì‚°
    krw_bal = get_available_krw(accounts)

    if krw_bal < 6000:
        print(f"[AUTO_ADD] KRW ë¶€ì¡±({krw_bal:,.0f}) â†’ ì¶”ë§¤ ìŠ¤í‚µ")
        return False, None

    entry_price_old = pos["entry_price"]
    stop_price = pos["stop"]

    # ì¶”ë§¤ë„ ì ì‘í˜• ë¦¬ìŠ¤í¬ ì ìš© (ì—°íŒ¨/ì—°ìŠ¹ ë°˜ì˜)
    # ğŸ”§ FIX: ì¶”ë§¤ì—ëŠ” ë¦¬ìŠ¤í¬ ìº¡ ì ìš© (ì—°ìŠ¹ ì¤‘ ê³¼ë„í•œ ë¦¬ìŠ¤í¬ í™•ëŒ€ ë°©ì§€)
    # - seedëŠ” streak ë³´ë„ˆìŠ¤ 100% ì ìš©
    # - addëŠ” ìº¡ìœ¼ë¡œ ì œí•œ (ì—°ìŠ¹ ë³´ë„ˆìŠ¤ê°€ ì¶”ë§¤ê¹Œì§€ íƒ€ë©´ DD í™•ëŒ€ ìœ„í—˜)
    adaptive = max(0.0001, get_adaptive_risk())
    add_risk_pct = max(0.0001, adaptive * ADD_RISK_FRACTION)
    add_risk_pct = min(add_risk_pct, RISK_PER_TRADE * 0.6)  # ìº¡: ê¸°ë³¸ ë¦¬ìŠ¤í¬ì˜ 60%
    qty_theoretical = calc_position_size(cur_price, stop_price, krw_bal, add_risk_pct)
    krw_to_use = qty_theoretical * cur_price

    if krw_to_use < 5000:
        print(f"[AUTO_ADD] ì£¼ë¬¸ ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ")
        return False, None

    krw_to_use = int(krw_to_use)

    print(
        f"[AUTO_ADD] {m} ì¶”ë§¤ ì‹œë„: {krw_to_use:,.0f} KRW "
        f"(ì´ë¡ ìˆ˜ëŸ‰â‰ˆ{qty_theoretical:.6f}, í˜„ì¬ê°€ {cur_price:,.0f})"
    )

    volume_filled = 0.0
    avg_price_add = cur_price

    try:
        res = place_market_buy(m, krw_to_use)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid, timeout_sec=12.0) if order_uuid else None

        if od:
            try:
                volume_filled = float(od.get("executed_volume") or "0")
            except Exception:
                volume_filled = 0.0

            trades = od.get("trades") or []
            if trades and volume_filled > 0:
                total_krw = 0.0
                total_vol = 0.0
                for tr in trades:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                    total_krw += p * v
                    total_vol += v
                if total_vol > 0:
                    avg_price_add = total_krw / total_vol
            else:
                if volume_filled > 0:
                    avg_price_add = krw_to_use / volume_filled

        if volume_filled <= 0:
            msg = f"[AUTO_ADD] {m} ì¶”ë§¤ ì²´ê²° 0 â†’ ë¬´ì‹œ"
            print(msg)
            tg_send(f"âš ï¸ {msg}")
            return False, None

    except Exception as e:
        print("[AUTO_ADD ERR]", e)
        tg_send(f"âš ï¸ <b>ì¶”ë§¤ ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")
        return False, None

    # í‰ê· ë‹¨ê°€ ê°±ì‹ 
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos:
            return False, None
        old_vol = pos.get("volume", 0.0)
        new_vol = old_vol + volume_filled
        if new_vol <= 0:
            return False, None
        new_entry_price = (entry_price_old * old_vol + avg_price_add * volume_filled) / new_vol

        pos["entry_price"] = new_entry_price
        pos["volume"] = new_vol
        pos["added"] = True
        pos["last_add_ts"] = time.time()
        pos["entry_mode"] = "confirm"  # âœ… probe â†’ confirm ìŠ¹ê²© ìë™ë°˜ì˜

        # ğŸ”§ FIX: ì¶”ë§¤ í›„ ì†ì ˆê°€ ì¬ê³„ì‚° (í‰ë‹¨ì´ ë°”ë€Œì—ˆìœ¼ë¯€ë¡œ)
        try:
            c1_for_sl = get_minutes_candles(1, m, 20)
            new_stop, new_sl_pct, _ = dynamic_stop_loss(new_entry_price, c1_for_sl)
            pos["stop"] = new_stop
            pos["sl_pct"] = new_sl_pct
        except Exception as e:
            print(f"[PYRA_STOP_ERR] ì¶”ë§¤ í›„ ì†ì ˆê°€ ê°±ì‹  ì‹¤íŒ¨: {e}")

    gain_from_old = (avg_price_add / entry_price_old - 1) * 100 if entry_price_old > 0 else 0
    tg_send(
        f"ğŸ“ˆ <b>ì¶”ë§¤ ì²´ê²°</b> {m}\n"
        f"â€¢ ì‚¬ìœ : {reason or 'ì¶”ì„¸ê°•í™”'}\n"
        f"â€¢ ê¸°ì¡´í‰ë‹¨: {fmt6(entry_price_old)}ì› â†’ ì‹ ê·œí‰ë‹¨: {fmt6(new_entry_price)}ì›\n"
        f"â€¢ ì¶”ê°€ ì²´ê²°ê°€: {fmt6(avg_price_add)}ì› (í‰ë‹¨ëŒ€ë¹„ {gain_from_old:+.2f}%)\n"
        f"â€¢ ì¶”ê°€ ìˆ˜ëŸ‰: {volume_filled:.6f} / ì´ ìˆ˜ëŸ‰: {new_vol:.6f}\n"
        f"{link_for(m)}"
    )

    return True, new_entry_price

# =========================
# ğŸ”¥ ìë™ ì²­ì‚°
# =========================
def close_auto_position(m, reason=""):
    """
    ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ ë§¤ë„ (ì°Œêº¼ê¸° ë°©ì§€ í¬í•¨)
    """
    if not AUTO_TRADE:
        print(f"[AUTO] AUTO_TRADE=0 â†’ ì²­ì‚° ìŠ¤í‚µ ({m}, reason={reason})")
        return

    # ğŸ”§ FIX: ì¤‘ë³µ ì²­ì‚° ë°©ì§€ ë½ (ë™ì‹œ ì²­ì‚° ì‹œë„ ì‹œ í•œ ìª½ë§Œ ì‹¤í–‰)
    # ğŸ”§ FIX (B): ë½ ì•ˆì—ì„œ ë³µì‚¬ë³¸ ìƒì„± â†’ ë½ í•´ì œ í›„ ë ˆì´ìŠ¤ ë°©ì§€
    with _POSITION_LOCK:
        if m in _CLOSING_MARKETS:
            print(f"[AUTO] {m} ì´ë¯¸ ì²­ì‚° ì§„í–‰ ì¤‘ â†’ ìŠ¤í‚µ (reason={reason})")
            return
        _CLOSING_MARKETS.add(m)
        pos_raw = OPEN_POSITIONS.get(m)
        pos = copy.deepcopy(pos_raw) if pos_raw else None  # ğŸ”§ FIX: ê¹Šì€ ë³µì‚¬ (nested dict ë ˆì´ìŠ¤ ë°©ì§€)

    try:
        if not pos:
            print(f"[AUTO] OPEN_POSITIONSì— {m} í¬ì§€ì…˜ ì—†ìŒ â†’ ì²­ì‚° ìŠ¤í‚µ (reason={reason})")
            # ğŸ”§ FIX: ì´ë¯¸ ì²­ì‚°ëœ í¬ì§€ì…˜ì— ëŒ€í•œ ì¤‘ë³µ ì•ŒëŒ ì œê±° (ë™ì‹œ ëª¨ë‹ˆí„°ë§ ì‹œ ë…¸ì´ì¦ˆ ë°©ì§€)
            return

        # ğŸ”§ FIX: ì‹¤ì œ ì”ê³  ë¨¼ì € ì²´í¬ (race condition ë°©ì§€ - ë™ì‹œ ëª¨ë‹ˆí„°ë§ ì‹œ ì¤‘ë³µ ì²­ì‚° ë°©ì§€)
        actual_vol = get_balance_with_locked(m)
        # ğŸ”§ FIX: -1 = ì¡°íšŒ ì‹¤íŒ¨ â†’ ì²­ì‚° ì§„í–‰í•˜ì§€ ì•ŠìŒ (ì˜¤íƒ ë°©ì§€)
        if actual_vol < 0:
            print(f"[AUTO] {m} ì”ê³  ì¡°íšŒ ì‹¤íŒ¨ â†’ ì²­ì‚° ìŠ¤í‚µ (reason={reason})")
            return
        if actual_vol <= 1e-12:
            print(f"[AUTO] {m} ì‹¤ì”ê³ =0 â†’ ì´ë¯¸ ì²­ì‚°ë¨, ìŠ¤í‚µ (reason={reason})")
            # ğŸ”§ FIX: mark_position_closedë¡œ state ë§ˆí‚¹ í›„ ì •ë¦¬
            mark_position_closed(m, f"already_zero:{reason}")
            return

        # ì‹¤ì œ ë³´ìœ ëŸ‰ ì‚¬ìš©
        vol = actual_vol

        # ğŸ”§ ì²­ì‚° ì‹œë„ ì•ŒëŒ (ì‹¤ì”ê³  í™•ì¸ í›„ì—ë§Œ ë°œì†¡)
        tg_send(f"ğŸ’£ {m} ì²­ì‚°ì‹œë„\nâ€¢ ì‚¬ìœ : {reason}\nâ€¢ ìˆ˜ëŸ‰: {vol:.4f}")

        if vol <= 0:
            print(f"[AUTO] {m} volume<=0 ({vol}) â†’ í¬ì§€ì…˜ ì œê±°ë§Œ ìˆ˜í–‰")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            # ğŸ”§ FIX: volume 0ì´ì–´ë„ ì•ŒëŒ + ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
            tg_send(f"âš ï¸ {m} ì²­ì‚° ì™„ë£Œ (ìˆ˜ëŸ‰ 0 í™•ì¸)\nâ€¢ ì‚¬ìœ : {reason}\nâ€¢ ì™¸ë¶€ ì²­ì‚° ë˜ëŠ” ì´ë¯¸ ì •ë¦¬ë¨")
            if AUTO_LEARN_ENABLED:
                try:
                    update_trade_result(m, 0, 0, 0)  # ë”ë¯¸ ê°’ìœ¼ë¡œ ì¹´ìš´íŠ¸ë§Œ
                except:
                    pass
            return

        entry_price = pos.get("entry_price", 0)

        # í˜„ì¬ê°€(ì²­ì‚° ì „ ê¸°ì¤€) ì¡°íšŒ - âœ… í¼ë¸”ë¦­ API ì‚¬ìš©
        # ğŸ”§ FIX: IndexError ë°©ì–´ (ë¹ˆ ë¦¬ìŠ¤íŠ¸ ì²´í¬)
        try:
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            cur_price = cur_js[0].get("trade_price", entry_price) if cur_js and len(cur_js) > 0 else entry_price
        except (IndexError, Exception):
            cur_price = entry_price

        # ì„  ê³„ì‚°(ëŒ€ëµ)
        ret_pct = (cur_price / entry_price -
                   1.0) * 100.0 if entry_price > 0 else 0.0
        est_entry_value = entry_price * vol
        est_exit_value = cur_price * vol
        pl_value = est_exit_value - est_entry_value

        print(
            f"[AUTO] {m} ì²­ì‚° ì‹œë„: volume={vol}, reason={reason}, PnL(ì„ ê³„ì‚°)={ret_pct:+.2f}%"
        )

        exit_price_used = cur_price  # ì‹¤ì œ ì²´ê²°ê°€ ì„±ê³µ ì‹œ êµì²´

        try:
            res = place_market_sell(m, vol, price_hint=cur_price)  # ğŸ”§ ê°€ê²© íŒíŠ¸ ì „ë‹¬
            order_uuid = res.get("uuid") if isinstance(res, dict) else None
            if order_uuid:
                od = get_order_result(order_uuid, timeout_sec=20.0)  # ğŸ”§ 12â†’20ì´ˆë¡œ ì¦ê°€
            else:
                od = None

            # ì‹¤ì œ ì²´ê²°ëŸ‰/ì²´ê²°ê°€ ê³„ì‚° (ğŸ”§ FIX: trades ì—†ì„ ë•Œ executed_volume ëŒ€ì²´ ì‚¬ìš©)
            executed = 0.0
            if od:
                trades = od.get("trades") or []
                total_krw = 0.0
                total_vol = 0.0
                for tr in trades:
                    try:
                        p = float(tr.get("price", "0"))
                        v = float(tr.get("volume", "0"))
                    except Exception:
                        continue
                    total_krw += p * v
                    total_vol += v
                executed = total_vol
                if total_vol > 0:
                    exit_price_used = total_krw / total_vol
                # ğŸ”§ FIX: trades ë°°ì—´ ì—†ì–´ë„ executed_volumeì´ ìˆìœ¼ë©´ ì²´ê²°ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                if executed <= 0:
                    try:
                        executed = float(od.get("executed_volume") or "0")
                        if executed > 0:
                            # í‰ê·  ì²´ê²°ê°€ ê³„ì‚° (ê°€ëŠ¥í•˜ë©´)
                            try:
                                avg_price = float(od.get("avg_price") or "0")
                                if avg_price > 0:
                                    exit_price_used = avg_price
                            except:
                                pass
                            print(f"[AUTO] {m} trades ì—†ìŒ, executed_volume={executed:.6f}ë¡œ ëŒ€ì²´")
                    except:
                        pass

            # ğŸ”§ FIX #1: ë¯¸ì²´ê²° ì‹œ ì”ê³  ì¬í™•ì¸ í›„ ì²˜ë¦¬ (ì§€ì—° ì²´ê²° ëŒ€ì‘ ê°•í™”)
            if executed <= 0:
                # ğŸ”§ PATCH: ìµœëŒ€ 30ì´ˆê¹Œì§€ ì”ê³ +locked=0 ì¬í™•ì¸ (ì§€ì—° ì²´ê²° ëŒ€ë¹„)
                for _retry in range(15):  # 15íšŒ x 2ì´ˆ = 30ì´ˆ
                    time.sleep(2.0)
                    actual_after = get_balance_with_locked(m)  # ğŸ”§ locked í¬í•¨
                    if actual_after <= 1e-12:
                        # ì‹¤ì”ê³ +locked 0 = ì²´ê²°ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                        with _POSITION_LOCK:
                            OPEN_POSITIONS.pop(m, None)

                        # ğŸ”§ FIX: ì§€ì—°ì²­ì‚° ì‹œ ì‹¤ì œ ì²´ê²°ê°€ ì¡°íšŒ ì‹œë„ (í•™ìŠµ ë°ì´í„° ì •í™•ë„ ê°œì„ )
                        if order_uuid:
                            try:
                                od_delayed = get_order_result(order_uuid, timeout_sec=5.0)
                                if od_delayed:
                                    delayed_avg = float(od_delayed.get("avg_price") or "0")
                                    if delayed_avg > 0:
                                        exit_price_used = delayed_avg
                                        ret_pct = (exit_price_used / entry_price - 1.0) * 100.0 if entry_price > 0 else 0.0
                                        print(f"[DELAYED] {m} ì‹¤ì œ ì²´ê²°ê°€ ì¡°íšŒ ì„±ê³µ: {delayed_avg:.0f}ì› â†’ ret={ret_pct:+.2f}%")
                            except Exception as _delayed_err:
                                print(f"[DELAYED_PRICE_ERR] {m} ì²´ê²°ê°€ ì¡°íšŒ ì‹¤íŒ¨ (ì¶”ì •ê°’ ì‚¬ìš©): {_delayed_err}")

                        tg_send(f"ğŸ§¹ <b>ìë™ì²­ì‚° ì™„ë£Œ(ì§€ì—°í™•ì¸)</b> {m}\nâ€¢ ì£¼ë¬¸ì‘ë‹µ ì§€ì—°ìœ¼ë¡œ ì”ê³ =0 í™•ì¸ í›„ ì™„ë£Œ ì²˜ë¦¬\nâ€¢ ì‚¬ìœ : {reason}")
                        # ğŸ”§ FIX: ì§€ì—°ì²­ì‚°ì—ì„œë„ record_trade ê¸°ë¡ (ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ ì¡°ì •ì— í•„ìˆ˜)
                        # ğŸ”§ FIX: ìˆ˜ìˆ˜ë£Œ ë°˜ì˜í•œ ìˆœìˆ˜ìµë¥  ì‚¬ìš©
                        net_ret_delayed = ret_pct - (FEE_RATE_ROUNDTRIP * 100.0)
                        try:
                            record_trade(m, net_ret_delayed / 100.0)  # ğŸ”§ ìˆ˜ìˆ˜ë£Œ ë°˜ì˜
                        except Exception as _e:
                            print("[DELAYED_TRADE_RECORD_ERR]", _e)
                        # ğŸ”§ í•™ìŠµ ë¡œê·¸ ì—…ë°ì´íŠ¸
                        if AUTO_LEARN_ENABLED:
                            try:
                                hold_sec = time.time() - pos.get("entry_ts", time.time())
                                mfe = pos.get("mfe_pct", 0.0)
                                mae = pos.get("mae_pct", 0.0)
                                # ğŸ”§ FIX: ìˆ˜ìˆ˜ë£Œ ë°˜ì˜í•œ ìˆœìˆ˜ìµë¥  ì‚¬ìš©
                                update_trade_result(m, exit_price_used, net_ret_delayed/100.0 if entry_price else 0, hold_sec,
                                                    added=pos.get('added', False), exit_reason=reason,
                                                    mfe_pct=mfe, mae_pct=mae,
                                                    entry_ts=pos.get("entry_ts"))
                            except Exception as _e:
                                print("[DELAYED_CLOSE_LOG_ERR]", _e)
                        return

                # 30ì´ˆ í›„ì—ë„ ì”ê³  ìˆìœ¼ë©´ â†’ í›„ì† ì›Œì»¤ë¡œ ì¶”ê°€ ê°ì‹œ
                print(f"[AUTO] {m} ì²­ì‚° ë¯¸ì²´ê²° â†’ í›„ì† ê°ì‹œ ì‹œì‘")
                tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ë¯¸ì²´ê²°</b> {m}\nì‚¬ìœ : ì²´ê²° ì§€ì—° / í›„ì† ê°ì‹œ ì§„í–‰")

                def _followup_check():
                    try:
                        for _ in range(120):  # ì¶”ê°€ 4ë¶„ ê°ì‹œ (120íšŒ x 2ì´ˆ)
                            time.sleep(2.0)
                            if get_balance_with_locked(m) <= 1e-12:  # ğŸ”§ locked í¬í•¨
                                with _POSITION_LOCK:
                                    OPEN_POSITIONS.pop(m, None)
                                tg_send(f"ğŸ§¹ <b>ìë™ì²­ì‚° ì™„ë£Œ(í›„ì†í™•ì¸)</b> {m}\nâ€¢ ì‚¬ìœ : {reason}")
                                return
                        # ğŸ”§ 4ë¶„ í›„ì—ë„ ë¯¸ì²´ê²° â†’ ê²½ê³  ì•Œë¦¼
                        tg_send(f"ğŸš¨ <b>{m} ì²­ì‚° ë¯¸ì™„ë£Œ</b>\nâ€¢ 4ë¶„ í›„ì†ê°ì‹œ ì¢…ë£Œ, ìˆ˜ë™ í™•ì¸ í•„ìš”\nâ€¢ ì‚¬ìœ : {reason}")
                    except Exception as e:
                        print("[FOLLOWUP_ERR]", e)
                        # ğŸ”§ FIX: ì˜ˆì™¸ ë°œìƒí•´ë„ ì•ŒëŒ ë°œì†¡
                        tg_send(f"ğŸš¨ <b>{m} í›„ì†ê°ì‹œ ì˜¤ë¥˜</b>\nâ€¢ ì˜ˆì™¸: {e}\nâ€¢ ìˆ˜ë™ í™•ì¸ í•„ìš”")
                threading.Thread(target=_followup_check, daemon=True).start()
                return

            # ğŸ”§ FIX #1: ë¶€ë¶„ì²´ê²° ì‹œ ì”ì—¬ëŸ‰ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            if executed < vol - 1e-10:
                remaining = max(vol - executed, 0.0)
                remaining_krw = exit_price_used * remaining
                # âœ… ì”ì—¬ê°€ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡(5000ì›) ë¯¸ë§Œì´ë©´ dust ì²˜ë¦¬
                is_dust = remaining_krw < 5000 and remaining > 1e-12
                with _POSITION_LOCK:
                    pos2 = OPEN_POSITIONS.get(m)
                    if pos2:
                        if remaining <= 1e-12:
                            # ì”ì—¬ ì—†ìŒ â†’ í¬ì§€ì…˜ ì œê±°
                            OPEN_POSITIONS.pop(m, None)
                        elif is_dust:
                            # ğŸ”§ FIX: dust ì”ì—¬ëŠ” í¬ì§€ì…˜ ì œê±° + _ORPHAN_HANDLEDì— ë“±ë¡
                            # â†’ ìœ ë ¹ìœ¼ë¡œ ê°ì§€ë˜ì§€ ì•ŠìŒ (ë¶€ë¶„ì²­ì‚° í›„ ì†ì ˆ ë°©ì§€)
                            OPEN_POSITIONS.pop(m, None)
                            _ORPHAN_HANDLED.add(m)
                            print(f"[AUTO] {m} dust ì”ì—¬ ({remaining_krw:.0f}ì›) â†’ _ORPHAN_HANDLED ë“±ë¡")
                        else:
                            pos2["volume"] = remaining
                            pos2["last_exit_ts"] = time.time()
                            OPEN_POSITIONS[m] = pos2
                print(f"[AUTO] {m} ë¶€ë¶„ì²´ê²°: {executed:.6f}/{vol:.6f} â†’ ì”ì—¬ {remaining:.6f} ({remaining_krw:.0f}ì›)")
                if remaining > 1e-12 and not is_dust:
                    tg_send(f"âš ï¸ <b>ë¶€ë¶„ì²´ê²°</b> {m}\nì²´ê²°: {executed:.6f} / ì”ì—¬: {remaining:.6f}")
                elif is_dust:
                    tg_send(f"âš ï¸ <b>ë¶€ë¶„ì²´ê²°</b> {m}\nì²´ê²°: {executed:.6f} / ì”ì—¬ {remaining:.6f} (dust, ìœ ë ¹ê°ì§€ ì œì™¸)")
                else:
                    tg_send(f"âš ï¸ <b>ë¶€ë¶„ì²´ê²°</b> {m}\nì²´ê²°: {executed:.6f} / ì”ì—¬ ë¯¸ë‹¬ â†’ ì •ë¦¬ì™„ë£Œ")
                # ë¶€ë¶„ì²´ê²°ë„ ì†ìµ ê³„ì‚°ì€ í•¨ (executed ê¸°ì¤€)
                vol = executed  # ì•„ë˜ ì†ìµ ê³„ì‚°ìš©

            # ğŸ”§ FIX #1: ì „ëŸ‰ì²´ê²° ì‹œì—ë§Œ í¬ì§€ì…˜ ì œê±°
            else:
                # ğŸ”§ FIX: mark_position_closedë¡œ state ë§ˆí‚¹ í›„ ì •ë¦¬
                mark_position_closed(m, f"full_close:{reason}")

            # ğŸ”§ FIX: ì‹¤ì œ ì²´ê²°ëŸ‰(vol=executed) ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
            est_entry_value = entry_price * vol  # âœ… executed ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
            est_exit_value = exit_price_used * vol
            pl_value = est_exit_value - est_entry_value
            gross_ret_pct = (exit_price_used / entry_price -
                             1.0) * 100.0 if entry_price > 0 else 0.0
            # ğŸ”§ FIX: ìˆ˜ìˆ˜ë£Œ ë°˜ì˜í•œ ìˆœìˆ˜ìµë¥  ê³„ì‚° (ìŠ¹ë¥ /ë¦¬ìŠ¤í¬ íŠœë‹ ì •í™•ë„ ê°œì„ )
            net_ret_pct = gross_ret_pct - (FEE_RATE_ROUNDTRIP * 100.0)  # ì™•ë³µ 0.1% ì°¨ê°
            ret_pct = gross_ret_pct  # ì•ŒëŒìš© (ê¸°ì¡´ ìœ ì§€)

            # ğŸ”§ FIX: ì²­ì‚° ìŠ¬ë¦½ ê¸°ë¡ (ì§„ì… ìŠ¬ë¦½ë§Œ ê¸°ë¡í•˜ë©´ ê³¼ì†Œì¶”ì •ë¨)
            # ğŸ”§ FIX: ìƒí•œ ìº¡ ì¶”ê°€ (0.5%) - ê°€ê²©ì´ë™ì´ ìŠ¬ë¦½ìœ¼ë¡œ ì„ì´ë©´ TP ê³¼ë„ ìƒìŠ¹
            # - cur_priceëŠ” ì£¼ë¬¸ ì§ì „ í‹°ì»¤ê°’ â†’ ì²´ê²°ê¹Œì§€ ì‹œì¥ ì´ë™ë¶„ í¬í•¨ë  ìˆ˜ ìˆìŒ
            # - ì´ìƒì¹˜ ì œì™¸ë¡œ expected_exit_slip_pct ì •í™•ë„ ê°œì„ 
            if cur_price > 0 and exit_price_used > 0:
                exit_slip = min(0.005, abs(exit_price_used / cur_price - 1.0))  # 0.5% ìº¡
                _EXIT_SLIP_HISTORY.append(exit_slip)  # ğŸ”§ FIX: exit ì „ìš©
                _SLIP_HISTORY.append(exit_slip)  # í•˜ìœ„í˜¸í™˜

            # âœ… ê±°ë˜ ê²°ê³¼ ê¸°ë¡ (ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹ì— ì‚¬ìš©)
            # ğŸ”§ FIX: net_ret_pct ì‚¬ìš© (ìˆ˜ìˆ˜ë£Œ ë°˜ì˜)
            try:
                record_trade(m, net_ret_pct / 100.0)  # ğŸ”§ ì†Œìˆ˜ ë‹¨ìœ„ + ìˆ˜ìˆ˜ë£Œ ë°˜ì˜
            except Exception as _e:
                print("[TRADE_RECORD_ERR]", _e)

            # ğŸ§  ìë™ í•™ìŠµìš© ê²°ê³¼ ì—…ë°ì´íŠ¸
            if AUTO_LEARN_ENABLED:
                try:
                    hold_sec = time.time() - pos.get("entry_ts", time.time())
                    was_added = pos.get("added", False)  # ğŸ” ì¶”ë§¤ ì—¬ë¶€
                    # ğŸ”§ MFE/MAE ì „ë‹¬ (monitor_positionì—ì„œ ì‹¤ì‹œê°„ ì €ì¥ë¨)
                    mfe = pos.get("mfe_pct", 0.0)
                    mae = pos.get("mae_pct", 0.0)
                    # ğŸ”§ FIX: net_ret_pct ì‚¬ìš© (ìˆ˜ìˆ˜ë£Œ ë°˜ì˜ëœ ì‹¤ì œ ìˆ˜ìµë¥ )
                    update_trade_result(m, exit_price_used, net_ret_pct / 100.0, hold_sec,
                                        added=was_added, exit_reason=reason,
                                        mfe_pct=mfe, mae_pct=mae,
                                        entry_ts=pos.get("entry_ts"))
                except Exception as _e:
                    print(f"[FEATURE_UPDATE_ERR] {_e}")

            result_emoji = "ğŸŸ¢" if ret_pct > 0 else "ğŸ”´"
            fee_total = (est_entry_value + est_exit_value) * FEE_RATE_ONEWAY  # í¸ë„ ìˆ˜ìˆ˜ë£Œ

            # ğŸ”§ DEBUG: ì²­ì‚° ì•ŒëŒ ë°œì†¡ ì§ì „ ë¡œê·¸
            print(f"[CLOSE_DEBUG] {m} ì²­ì‚°ì•ŒëŒ ë°œì†¡ ì§ì „ | ret={ret_pct:.2f}% vol={vol:.6f} exit_price={exit_price_used}")

            tg_send(
                f"====================================\n"
                f"{result_emoji} <b>ìë™ì²­ì‚° ì™„ë£Œ</b> {m}\n"
                f"====================================\n"
                f"ğŸ’° ìˆœì†ìµ: {pl_value:+,.0f}ì› ({ret_pct:+.2f}%)\n\n"
                f"â€¢ ì‚¬ìœ : {reason}\n"
                f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {fmt6(entry_price)}ì›\n"
                f"â€¢ ì‹¤ë§¤ë„ê°€: {fmt6(exit_price_used)}ì›\n"
                f"â€¢ ì²´ê²°ìˆ˜ëŸ‰: {vol:.6f}\n"
                f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡: {est_entry_value:,.0f}ì›\n"
                f"â€¢ ì²­ì‚°ê¸ˆì•¡: {est_exit_value:,.0f}ì›\n"
                f"â€¢ ìˆ˜ìˆ˜ë£Œ: {fee_total:,.0f}ì›\n"
                f"====================================\n"
                f"{link_for(m)}"
            )

        except Exception as e:
            print("[AUTO SELL ERR]", e)
            import traceback
            traceback.print_exc()  # ğŸ”§ DEBUG: ìƒì„¸ ì—ëŸ¬ ì¶œë ¥
            tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")

            # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ë§¤ë„ ë¶ˆê°€ ì°Œêº¼ê¸°, ë©”ëª¨ë¦¬ í¬ì§€ì…˜ë§Œ ì •ë¦¬
            # ğŸ”§ FIX: _ORPHAN_HANDLEDì— ë“±ë¡í•˜ì—¬ ìœ ë ¹ìœ¼ë¡œ ê°ì§€ë˜ì§€ ì•Šê²Œ í•¨
            if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                _ORPHAN_HANDLED.add(m)
                tg_send(f"ğŸ§¹ {m} ì²­ì‚° ì™„ë£Œ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë‹¬ dust)\nâ€¢ ì†ŒëŸ‰ ì”ì—¬ëŠ” ê±°ë˜ì†Œì— ë³´ìœ  (ìœ ë ¹ê°ì§€ ì œì™¸)")
                # ğŸ”§ FIX: ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
                if AUTO_LEARN_ENABLED:
                    try:
                        update_trade_result(m, 0, 0, 0)
                    except:
                        pass
                return

            # ğŸ”§ FIX: 400 ì—ëŸ¬ ì‹œ ì‹¤ì œ ì”ê³  í™•ì¸ â†’ 0ì´ë©´ ì¢€ë¹„ í¬ì§€ì…˜ ì œê±°
            # ğŸ”§ FIX: get_actual_balance â†’ get_balance_with_locked (locked í¬í•¨, ìœ ë ¹ ì˜¤íƒ ë°©ì§€)
            if "400" in str(e) or "Bad Request" in str(e):
                actual_check = get_balance_with_locked(m)
                if actual_check <= 1e-12:
                    print(f"[AUTO] {m} ì”ê³  0 í™•ì¸ â†’ ì¢€ë¹„ í¬ì§€ì…˜ ì œê±°")
                    tg_send(f"ğŸ—‘ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ ì™„ë£Œ (ì‹¤ì œ ì”ê³  0 í™•ì¸)")
                    with _POSITION_LOCK:
                        OPEN_POSITIONS.pop(m, None)
                    # ğŸ”§ FIX: ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
                    if AUTO_LEARN_ENABLED:
                        try:
                            update_trade_result(m, 0, 0, 0)
                        except:
                            pass
            return
    finally:
        # ğŸ”§ FIX: ì¤‘ë³µ ì²­ì‚° ë°©ì§€ ë½ í•´ì œ (ì„±ê³µ/ì‹¤íŒ¨ ìƒê´€ì—†ì´)
        with _POSITION_LOCK:
            _CLOSING_MARKETS.discard(m)


PARTIAL_PENDING_TIMEOUT = 30.0  # ğŸ”§ FIX: pending ìƒíƒœ íƒ€ì„ì•„ì›ƒ (ì´ˆ)

def safe_partial_sell(m, sell_ratio=0.5, reason=""):
    """
    ë¶€ë¶„ ì²­ì‚° ê³µìš© í•¨ìˆ˜
    - sell_ratio: 0.5 â†’ 50%, 0.3 â†’ 30% ë“±
    - partial_state + partial_tsë¡œ 1íšŒë§Œ ë¶€ë¶„ì²­ì‚°/ë¶€ë¶„ìµì ˆ í—ˆìš© (í¬ë˜ì‹œ í›„ ë´‰ì¸ ë°©ì§€)
      - None: ë¯¸ìˆ˜í–‰
      - "pending": ì§„í–‰ ì¤‘ (íƒ€ì„ì•„ì›ƒ ì‹œ ìë™ í•´ì œ)
      - "done": ì™„ë£Œ
    ë°˜í™˜: (ì„±ê³µì—¬ë¶€:bool, ë©”ì‹œì§€:str, ì²´ê²°ëŸ‰:float)
    """
    with _POSITION_LOCK:
        # ğŸ”§ FIX: ì „ëŸ‰ì²­ì‚°ê³¼ ë™ì¼í•˜ê²Œ _CLOSING_MARKETS ì²´í¬ (ë ˆì´ìŠ¤ ë°©ì§€)
        if m in _CLOSING_MARKETS:
            msg = f"[REMONITOR] {m} ì´ë¯¸ ì²­ì‚° ì§„í–‰ ì¤‘ â†’ ë¶€ë¶„ì²­ì‚° ìŠ¤í‚µ"
            print(msg)
            return False, msg, 0.0
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: í¬ì§€ì…˜ ì—†ìŒ/ìˆ˜ëŸ‰ 0"
            print(msg)
            return False, msg, 0.0

        # ğŸ”§ FIX: partial_state ê¸°ë°˜ ì²´í¬ (í¬ë˜ì‹œ í›„ ë´‰ì¸ ë°©ì§€)
        # - "done": ì´ë¯¸ ì™„ë£Œ â†’ ìŠ¤í‚µ
        # - "pending": ì§„í–‰ ì¤‘ì´ì§€ë§Œ, íƒ€ì„ì•„ì›ƒ(30ì´ˆ) ì´ˆê³¼ ì‹œ ìë™ í•´ì œ
        partial_state = pos.get("partial_state")
        partial_ts = pos.get("partial_ts", 0)

        if partial_state == "done":
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì´ë¯¸ ìˆ˜í–‰ë¨ â†’ ìŠ¤í‚µ"
            print(msg)
            return False, msg, 0.0
        elif partial_state == "pending":
            elapsed = time.time() - partial_ts
            if elapsed < PARTIAL_PENDING_TIMEOUT:
                msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì§„í–‰ ì¤‘ ({elapsed:.1f}ì´ˆ ê²½ê³¼) â†’ ìŠ¤í‚µ"
                print(msg)
                return False, msg, 0.0
            else:
                # íƒ€ì„ì•„ì›ƒ: pending ìë™ í•´ì œ (í¬ë˜ì‹œ í›„ ë³µêµ¬ ê°€ëŠ¥)
                print(f"[PARTIAL_TIMEOUT] {m} pending ìƒíƒœ {elapsed:.1f}ì´ˆ â†’ ìë™ í•´ì œ (ì¬ì‹œë„ í—ˆìš©)")
                pos["partial_state"] = None
                pos.pop("partial_ts", None)

        # ğŸ”§ FIX: ë¶€ë¶„ì²­ì‚°ë„ _CLOSING_MARKETSì— ë“±ë¡ (ì „ëŸ‰ì²­ì‚°ê³¼ ë™ì‹œ ì‹¤í–‰ ë°©ì§€)
        _CLOSING_MARKETS.add(m)
        # ğŸ”§ FIX: TOCTOU ë ˆì´ìŠ¤ ë°©ì§€ - ë½ í•´ì œ ì „ partial_state=pending ì„ ì 
        # ì£¼ë¬¸ ì‹¤íŒ¨ ì‹œ ì•„ë˜ì—ì„œ Noneìœ¼ë¡œ ë¡¤ë°±
        pos["partial_state"] = "pending"
        pos["partial_ts"] = time.time()
        current_volume = pos["volume"]
        entry_price = pos.get("entry_price", 0)

    sell_volume = current_volume * sell_ratio
    if sell_volume <= 0:
        msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: sell_volume<=0"
        print(msg)
        # ğŸ”§ FIX: ì‹¤íŒ¨ ì‹œ partial_state ë¡¤ë°±
        with _POSITION_LOCK:
            pos2 = OPEN_POSITIONS.get(m)
            if pos2:
                pos2["partial_state"] = None
                pos2.pop("partial_ts", None)
            _CLOSING_MARKETS.discard(m)  # ğŸ”§ FIX: ì²­ì‚° ë½ í•´ì œ
        return False, msg, 0.0

    # ğŸ”§ í˜„ì¬ê°€ ì¡°íšŒ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ìš©)
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        cur_price = cur_js[0].get("trade_price", entry_price) if cur_js else entry_price
    except Exception:
        cur_price = entry_price

    # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡(5000ì›) ì‚¬ì „ê²€ì¦
    MIN_ORDER_KRW = 5000
    sell_krw = sell_volume * cur_price
    remaining_volume = current_volume - sell_volume
    remaining_krw = remaining_volume * cur_price

    # ë§¤ë„ê¸ˆì•¡ ë˜ëŠ” ì”ì—¬ê¸ˆì•¡ì´ 5000ì› ë¯¸ë§Œì´ë©´ â†’ ì „ëŸ‰ì²­ì‚°ìœ¼ë¡œ ì „í™˜
    # ğŸ”§ FIX: was_full í”Œë˜ê·¸ë¡œ ì „ëŸ‰ì²­ì‚° ì‹œë„ ì—¬ë¶€ ì¶”ì  (ë¶€ë¶„ì²´ê²° ì‹œ ì¬ì‹œë„ìš©)
    was_full = False
    if sell_krw < MIN_ORDER_KRW or remaining_krw < MIN_ORDER_KRW:
        print(f"[PARTIALâ†’FULL] {m} ìµœì†Œê¸ˆì•¡ ë¯¸ë‹¬ (ë§¤ë„:{sell_krw:.0f}ì›, ì”ì—¬:{remaining_krw:.0f}ì›) â†’ ì „ëŸ‰ì²­ì‚°")
        sell_volume = current_volume  # ì „ëŸ‰ìœ¼ë¡œ ë³€ê²½
        was_full = True  # ğŸ”§ ì „ëŸ‰ì²­ì‚° ì‹œë„ í‘œì‹œ
        # ğŸ”§ FIX: ì „ëŸ‰ì²­ì‚° ëª¨ë“œë¡œ ì „í™˜ â†’ partial_state í•´ì œ (ë¶€ë¶„ì²´ê²° ì‹œ ì¬ì‹œë„ ê°€ëŠ¥í•˜ê²Œ)
        with _POSITION_LOCK:
            pos2 = OPEN_POSITIONS.get(m)
            if pos2:
                pos2["partial_state"] = None
                pos2.pop("partial_ts", None)

    try:
        res = place_market_sell(m, sell_volume, price_hint=cur_price)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid,
                              timeout_sec=12.0) if order_uuid else None

        executed = 0.0
        if od:
            try:
                executed = float(od.get("executed_volume") or "0")
            except Exception:
                executed = 0.0

        if executed <= 0:
            msg = f"[PARTIAL_SELL_ERR] {m}: executed_volume=0 (ìš”ì²­ {sell_volume:.6f})"
            print(msg)
            tg_send_mid(f"âš ï¸ <b>ë¶€ë¶„ì²­ì‚° ì£¼ë¬¸ ì‹¤íŒ¨</b> {m}\n"
                        f"â€¢ ìš”ì²­ ë¹„ìœ¨: {sell_ratio*100:.0f}%\n"
                        f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {sell_volume:.6f}\n"
                        f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: 0 (ì‹¤íŒ¨)")
            # ğŸ”§ FIX: ì²´ê²° ì‹¤íŒ¨ ì‹œ partial_state ë¡¤ë°±
            with _POSITION_LOCK:
                pos2 = OPEN_POSITIONS.get(m)
                if pos2:
                    pos2["partial_state"] = None
                    pos2.pop("partial_ts", None)
                _CLOSING_MARKETS.discard(m)  # ğŸ”§ FIX: ì²­ì‚° ë½ í•´ì œ
            return False, msg, 0.0

        remaining_volume = max(current_volume - executed, 0.0)

        # ì‹¤ì œ ì²´ê²°ê°€ ê³„ì‚°
        exit_price_used = 0.0
        if od:
            trades = od.get("trades") or []
            total_krw = 0.0
            total_vol = 0.0
            for tr in trades:
                try:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                except Exception:
                    continue
                total_krw += p * v
                total_vol += v
            if total_vol > 0:
                exit_price_used = total_krw / total_vol

        # ğŸ”§ FIX: exit_price_used=0 fallback (ë¦¬í¬íŠ¸/í•™ìŠµ í’ˆì§ˆ ë³´ì¥)
        exit_price_used = exit_price_used if exit_price_used > 0 else cur_price

        # ğŸ”§ FIX: ì²­ì‚° ìŠ¬ë¦½ ê¸°ë¡ (ì§„ì… ìŠ¬ë¦½ë§Œ ê¸°ë¡í•˜ë©´ ê³¼ì†Œì¶”ì •ë¨)
        # ğŸ”§ FIX: ìƒí•œ ìº¡ ì¶”ê°€ (0.5%) - ê°€ê²©ì´ë™ì´ ìŠ¬ë¦½ìœ¼ë¡œ ì„ì´ë©´ TP ê³¼ë„ ìƒìŠ¹
        if cur_price > 0 and exit_price_used > 0:
            exit_slip = min(0.005, abs(exit_price_used / cur_price - 1.0))  # 0.5% ìº¡
            _EXIT_SLIP_HISTORY.append(exit_slip)  # ğŸ”§ FIX: exit ì „ìš©
            _SLIP_HISTORY.append(exit_slip)  # í•˜ìœ„í˜¸í™˜

        # ì†ìµ ê³„ì‚°
        est_entry_value = entry_price * executed
        est_exit_value = exit_price_used * executed
        pl_value = est_exit_value - est_entry_value
        ret_pct = (exit_price_used / entry_price - 1.0) * 100.0 if entry_price > 0 else 0.0
        fee_total = (est_entry_value + est_exit_value) * FEE_RATE_ONEWAY  # í¸ë„ ìˆ˜ìˆ˜ë£Œ

        # ğŸ”§ FIX: net ê¸°ì¤€ìœ¼ë¡œ í†µì¼ (ìˆ˜ìˆ˜ë£Œ ë°˜ì˜) - ëª¨ë“  ë¶„ê¸°ì—ì„œ ì‚¬ìš©
        net_ret_pct = ret_pct - (FEE_RATE_ROUNDTRIP * 100.0)

        # ğŸ’¥ í¬ë¦¬í‹°ì»¬ í•«í”½ìŠ¤: ì”ì—¬ 0ì´ë©´ í¬ì§€ì…˜ ì œê±° (ì¢€ë¹„ ë°©ì§€)
        # ğŸ”§ FIX: pop ì „ì— entry_ts, added ë°±ì—… (hold_sec 0 ë²„ê·¸ ë°©ì§€)
        backup_entry_ts = None
        backup_added = False
        if remaining_volume <= 1e-10:
            with _POSITION_LOCK:
                pos_backup = OPEN_POSITIONS.get(m, {})
                backup_entry_ts = pos_backup.get("entry_ts")
                backup_added = pos_backup.get("added", False)
                OPEN_POSITIONS.pop(m, None)
            print(f"[PARTIALâ†’FULL_DONE] {m} ì „ëŸ‰ì²­ì‚° ì™„ë£Œ â†’ í¬ì§€ì…˜ ì œê±° (net:{net_ret_pct:+.2f}%)")
        else:
            with _POSITION_LOCK:
                pos2 = OPEN_POSITIONS.get(m)
                if pos2:
                    pos2["volume"] = remaining_volume
                    # ğŸ”§ FIX: ì „ëŸ‰ì²­ì‚° ì‹œë„ í›„ ë¶€ë¶„ì²´ê²°ì´ë©´ partial_state=None (ì¬ì‹œë„ ê°€ëŠ¥)
                    if was_full:
                        pos2["partial_state"] = None  # ì „ëŸ‰ ì‹œë„í–ˆëŠ”ë° ì”ëŸ‰ ë‚¨ìŒ â†’ ì¬ì‹œë„ í—ˆìš©
                        pos2.pop("partial_ts", None)
                        print(f"[PARTIAL_RETRY] {m} ì „ëŸ‰ì²­ì‚° ì‹œë„ í›„ ë¶€ë¶„ì²´ê²° â†’ ì¬ì‹œë„ í—ˆìš©")
                    else:
                        pos2["partial_state"] = "done"  # ì¼ë°˜ ë¶€ë¶„ì²­ì‚° â†’ 1íšŒë§Œ
                        pos2.pop("partial_ts", None)  # pending íƒ€ì„ìŠ¤íƒ¬í”„ ì œê±°
                    pos2["partial_price"] = exit_price_used if exit_price_used > 0 else cur_price
                    pos2["partial_type"] = "profit" if net_ret_pct > 0 else "loss"  # ğŸ”§ net ê¸°ì¤€

                    # ğŸ”§ ë¸Œë ˆì´í¬ì´ë¸ (ë³¸ì ˆ): ë¶€ë¶„ìµì ˆ í›„ ì†ì ˆê°€ë¥¼ ì§„ì…ê°€ë¡œ ì´ë™
                    # - "ë¨¹ê³  ë±‰ëŠ”" ê±°ë˜ ë°©ì§€
                    # - ğŸ”§ FIX: ë¹„êµ ê¸°ì¤€ì„ alphaë§Œìœ¼ë¡œ ë‹¨ìˆœí™” (slipì€ gate/impact_capìœ¼ë¡œ ì´ë¯¸ ê´€ë¦¬)
                    # - ret_netì— slip ì—†ìœ¼ë‹ˆ cpì—ì„œë„ slip ì œê±° â†’ ì¼ê´€ëœ ë¹„êµ
                    cp_alpha = PROFIT_CHECKPOINT_MIN_ALPHA * 100.0  # 0.1% (alphaë§Œ)
                    if net_ret_pct >= cp_alpha and not pos2.get("breakeven_set"):
                        old_stop = pos2.get("stop", 0)
                        # ğŸ”§ FIX: ì§„ì§œ ë³¸ì ˆ = ìˆ˜ìˆ˜ë£Œ ì»¤ë²„ (entryì—ì„œ ì²­ì‚°í•˜ë©´ ìˆ˜ìˆ˜ë£Œë¡œ ì†ì‹¤)
                        BREAKEVEN_BUFFER = 0.0003  # 0.03% ì¶”ê°€ ë²„í¼
                        real_breakeven = entry_price * (1 + FEE_RATE_ROUNDTRIP + BREAKEVEN_BUFFER)
                        pos2["stop"] = real_breakeven
                        pos2["breakeven_set"] = True
                        print(f"[BREAKEVEN] {m} ì§„ì§œ ë³¸ì ˆ: ì†ì ˆ {old_stop:.0f} â†’ {real_breakeven:.0f} (ìˆ˜ìˆ˜ë£Œì»¤ë²„, net:{net_ret_pct:.2f}%)")

        msg = (f"[REMONITOR] {m} ë¶€ë¶„ ì²­ì‚° ì‹¤í–‰ {sell_ratio*100:.0f}% "
               f"(ì²´ê²° {executed:.6f}) ì”ì—¬ {remaining_volume:.6f}")
        print(msg)

        # ğŸ”§ FIX: net ê¸°ì¤€ìœ¼ë¡œ íŒì • (ìˆ˜ìˆ˜ë£Œ ë°˜ì˜)
        result_emoji = "ğŸŸ¢" if net_ret_pct > 0 else "ğŸ”´"
        tg_send(
            f"====================================\n"
            f"{result_emoji} <b>ë¶€ë¶„ ì²­ì‚°</b> {m}\n"
            f"====================================\n"
            f"ğŸ’° ìˆœì†ìµ: {pl_value:+,.0f}ì› (gross:{ret_pct:+.2f}% / net:{net_ret_pct:+.2f}%)\n\n"
            f"â€¢ ì‚¬ìœ : {reason or 'ë¶€ë¶„ì²­ì‚°'}\n"
            f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {fmt6(entry_price)}ì›\n"
            f"â€¢ ì‹¤ë§¤ë„ê°€: {fmt6(exit_price_used)}ì›\n"
            f"â€¢ ì²´ê²°ìˆ˜ëŸ‰: {executed:.6f}\n"
            f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡: {est_entry_value:,.0f}ì›\n"
            f"â€¢ ì²­ì‚°ê¸ˆì•¡: {est_exit_value:,.0f}ì›\n"
            f"â€¢ ìˆ˜ìˆ˜ë£Œ: {fee_total:,.0f}ì›\n"
            f"â€¢ ì”ì—¬ìˆ˜ëŸ‰: {remaining_volume:.6f}\n"
            f"===================================="
        )

        # ğŸ”§ FIX: ì „ëŸ‰ì²­ì‚° ì‹œ record_trade(net) + update_trade_result(net) í˜¸ì¶œ
        # - ê¸°ì¡´: update_trade_result(gross)ë§Œ í˜¸ì¶œ â†’ TRADE_HISTORY/streak ëˆ„ë½
        # - ë³€ê²½: net ê¸°ì¤€ìœ¼ë¡œ í†µì¼, record_tradeë„ í˜¸ì¶œ
        if remaining_volume <= 1e-10:
            # ğŸ”§ FIX: ë°±ì—…ëœ entry_ts, added ì‚¬ìš© (pop í›„ë¼ OPEN_POSITIONSì— ì—†ìŒ)
            try:
                if backup_entry_ts is not None:
                    hold_sec = time.time() - backup_entry_ts
                else:
                    hold_sec = 0
                # ğŸ”§ FIX: record_trade(net) í˜¸ì¶œ - TRADE_HISTORY/streak ì—…ë°ì´íŠ¸
                record_trade(m, net_ret_pct / 100.0)
                # ğŸ”§ FIX: update_trade_result(net) - í•™ìŠµ/ì¿¨ë‹¤ìš´ ì •í™•ì„±
                if AUTO_LEARN_ENABLED:
                    update_trade_result(m, exit_price_used, net_ret_pct / 100.0, hold_sec,
                                        added=backup_added, exit_reason=reason or "ë¶€ë¶„ì²­ì‚°",
                                        entry_ts=backup_entry_ts)
            except Exception as _e:
                print(f"[PARTIAL_TRADE_LOG_ERR] {_e}")

        # ğŸ”§ FIX: ì²­ì‚° ë½ í•´ì œ (ì„±ê³µ)
        with _POSITION_LOCK:
            _CLOSING_MARKETS.discard(m)
        return True, msg, executed

    except Exception as e:
        msg = f"[PARTIAL_SELL_ERR] {m}: {e}"
        print(msg)
        # ğŸ”§ FIX: ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨ ì‹œ í¬ì§€ì…˜ ìœ ì§€ (orphan ë°©ì§€)
        # - ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œì´ë©´ ë¶€ë¶„ë§¤ë„ ë¶ˆê°€ â†’ ì „ëŸ‰ì²­ì‚° ë¡œì§ì— ë§¡ê¹€
        # - í¬ì§€ì…˜ì„ popí•˜ë©´ ì”ê³ ëŠ” ë‚¨ì•„ìˆëŠ”ë° OPEN_POSITIONSì— ì—†ì–´ì„œ orphan ë¨!
        if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
            tg_send(f"âš ï¸ {m} ë¶€ë¶„ì²­ì‚° ìŠ¤í‚µ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ)\nâ€¢ í¬ì§€ì…˜ ìœ ì§€, ì „ëŸ‰ì²­ì‚° ëŒ€ê¸°")
        # ğŸ”§ FIX: ì˜ˆì™¸ ë°œìƒ ì‹œ partial_state ë¡¤ë°±
        with _POSITION_LOCK:
            pos2 = OPEN_POSITIONS.get(m)
            if pos2:
                pos2["partial_state"] = None
                pos2.pop("partial_ts", None)
            _CLOSING_MARKETS.discard(m)  # ğŸ”§ FIX: ì²­ì‚° ë½ í•´ì œ
        return False, msg, 0.0


def remonitor_until_close(m, entry_price, pre, tight_mode=False):
    """
    ëì•ŒëŒ ì´í›„ ìë™ì²­ì‚° ì‹ í˜¸ê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ ëª¨ë‹ˆí„°ë§
    ğŸ”§ FIX: ì¥ê¸° ë³´ìœ  íƒ€ì„ì•„ì›ƒ ì¶”ê°€ (ë¶€ë¶„ì²­ì‚° í›„ ì •ì²´ ë°©ì§€)
    """
    # ğŸ”§ FIX: ì§„ì… ì „ ê°€ë“œ - ì´ë¯¸ ì²­ì‚° ì¤‘/ì™„ë£Œëœ í¬ì§€ì…˜ì€ ì¦‰ì‹œ ë¦¬í„´
    with _POSITION_LOCK:
        if m in _CLOSING_MARKETS:
            print(f"[REMONITOR] {m} ì´ë¯¸ ì²­ì‚° ì§„í–‰ ì¤‘(_CLOSING_MARKETS) â†’ ìŠ¤í‚µ")
            return False
        pos_check = OPEN_POSITIONS.get(m)
        if pos_check and pos_check.get("state") == "closed":
            print(f"[REMONITOR] {m} ì´ë¯¸ ì²­ì‚° ì™„ë£Œ(state=closed) â†’ ìŠ¤í‚µ")
            return False

    # ğŸ”§ FIX: ì”ê³  0ì´ë©´ ì¦‰ì‹œ ë¦¬í„´ (ì²­ì‚° ì™„ë£Œ í™•ì¸)
    # ğŸ”§ FIX: ë§¤ìˆ˜ ì§í›„ 300ì´ˆ ë‚´ì—ëŠ” ì”ê³ =0ì´ì–´ë„ API ì§€ì—° ê°€ëŠ¥ â†’ í¬ì§€ì…˜ ìœ ì§€
    bal_check = get_balance_with_locked(m)
    buy_age = time.time() - _RECENT_BUY_TS.get(m, 0)
    if bal_check >= 0 and bal_check <= 1e-12:
        if buy_age < 300:
            print(f"[REMONITOR] {m} ì§„ì… ì „ ì”ê³ =0ì´ì§€ë§Œ ë§¤ìˆ˜ {buy_age:.0f}ì´ˆ ì „ â†’ API ì§€ì—° ê°€ëŠ¥, ê³„ì† ì§„í–‰")
        else:
            print(f"[REMONITOR] {m} ì§„ì… ì „ ì”ê³ =0 í™•ì¸ â†’ ìŠ¤í‚µ")
            mark_position_closed(m, "remonitor entry - balance zero")
            return False

    CYCLE_SEC = 300
    cycle = 0

    # ğŸ”§ ì‹œê°„ ê¸°ë°˜ íƒ€ì„ì•„ì›ƒ ì œê±° - ê°€ê²© ì¡°ê±´ìœ¼ë¡œë§Œ ë§¤ë„

    while True:
        cycle += 1
        print(f"[REMONITOR] {m} {cycle}íšŒì°¨ ì¬ëª¨ë‹ˆí„°ë§ ì‹œì‘")

        # ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ íƒˆì¶œ: ì‹¤ì”ê³  í™•ì¸
        # ğŸ”§ FIX (B): ë½ ì•ˆì—ì„œ ë³µì‚¬ë³¸ ìƒì„± â†’ ë½ í•´ì œ í›„ ë ˆì´ìŠ¤ ë°©ì§€
        with _POSITION_LOCK:
            pos_raw = OPEN_POSITIONS.get(m)
            pos = copy.deepcopy(pos_raw) if pos_raw else None  # ğŸ”§ FIX: ê¹Šì€ ë³µì‚¬ (nested dict ë ˆì´ìŠ¤ ë°©ì§€)
        if not pos:
            print(f"[REMONITOR] {m} OPEN_POSITIONSì— ì—†ìŒ â†’ ë£¨í”„ ì¢…ë£Œ")
            # ğŸ”§ FIX: í¬ì§€ì…˜ ì—†ìŒ ì•ŒëŒ ì¶”ê°€
            tg_send(f"âš ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ë¨ (OPEN_POSITIONSì—ì„œ ì œê±°ë¨)")
            return False

        # ì‹¤ì œ ê±°ë˜ì†Œ ì”ê³  í™•ì¸ (ğŸ”§ FIX: balance + locked ëª¨ë‘ ì²´í¬)
        actual = get_balance_with_locked(m)
        # ğŸ”§ FIX: -1 = ì¡°íšŒ ì‹¤íŒ¨ â†’ í¬ì§€ì…˜ ì‚­ì œí•˜ì§€ ì•Šê³  ë‹¤ìŒ ì‚¬ì´í´ ëŒ€ê¸°
        if actual < 0:
            print(f"[REMONITOR] {m} ì”ê³  ì¡°íšŒ ì‹¤íŒ¨ â†’ í¬ì§€ì…˜ ìœ ì§€, ë‹¤ìŒ ì‚¬ì´í´ ëŒ€ê¸°")
            time.sleep(5)
            continue
        if actual <= 1e-12:
            # ğŸ”§ FIX: ë§¤ìˆ˜ ì§í›„ 300ì´ˆ ë‚´ì—ëŠ” ì”ê³ =0ì´ì–´ë„ API ì§€ì—° ê°€ëŠ¥ â†’ ë‹¤ìŒ ì‚¬ì´í´ ëŒ€ê¸°
            buy_age_loop = time.time() - _RECENT_BUY_TS.get(m, 0)
            if buy_age_loop < 300:
                print(f"[REMONITOR] {m} ì”ê³ =0ì´ì§€ë§Œ ë§¤ìˆ˜ {buy_age_loop:.0f}ì´ˆ ì „ â†’ API ì§€ì—° ê°€ëŠ¥, ë‹¤ìŒ ì‚¬ì´í´ ëŒ€ê¸°")
                time.sleep(5)
                continue
            print(f"[REMONITOR] {m} ì‹¤ì”ê³ +locked=0 â†’ ìœ ë ¹ í¬ì§€ì…˜ ì •ë¦¬ í›„ ë£¨í”„ ì¢…ë£Œ")
            # ğŸ”§ FIX: ì²­ì‚° ì•ŒëŒ ì¶”ê°€ (ì™¸ë¶€ ì •ë¦¬ ë˜ëŠ” ì²´ê²° ëˆ„ë½ ê°ì§€)
            entry_price_for_msg = pos.get("entry_price", 0)
            tg_send(f"âš ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ (ì”ê³ +locked=0 í™•ì¸)\nâ€¢ ë§¤ìˆ˜ê°€: {fmt6(entry_price_for_msg)}ì›\nâ€¢ ì™¸ë¶€ ì²­ì‚° ë˜ëŠ” ì´ë¯¸ ì •ë¦¬ë¨")
            # ğŸ”§ FIX: mark_position_closedë¡œ state ë§ˆí‚¹ í›„ ì •ë¦¬
            mark_position_closed(m, "remonitor_zero_balance")
            return False

        # ğŸ”§ ë¶€ë¶„ì²­ì‚° í›„ ì¶”ê°€ í•˜ë½ ì²´í¬
        if pos and pos.get("partial_state") == "done":
            partial_price = pos.get("partial_price", 0)
            partial_type = pos.get("partial_type", "loss")

            # í˜„ì¬ê°€ ì¡°íšŒ
            try:
                cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
                cur_price = cur_js[0].get("trade_price", 0) if cur_js else 0
            except:
                cur_price = 0

            if cur_price > 0 and partial_price > 0:
                # ğŸ”§ FIX: ë“œë¡­ ê¸°ì¤€ì„ ë³€ë™ì„±(trail_distance_min) ì—°ë™
                # - ê³ ì •ê°’ì´ë©´ ë³€ë™ì„± í° ì½”ì¸ì—ì„œ ì •ìƒ í”ë“¤ë¦¼ì—ë„ ì”ëŸ‰ ì •ë¦¬ë¨
                trail_min = get_trail_distance_min()
                profit_drop_thr = max(PARTIAL_EXIT_PROFIT_DROP, trail_min * 1.2)
                loss_drop_thr = max(PARTIAL_EXIT_LOSS_DROP, trail_min * 0.8)

                if partial_type == "profit":
                    # ìµì ˆ ë¶€ë¶„ì²­ì‚° í›„: ì¶”ê°€ í•˜ë½ OR ì§„ì…ê°€ "í™•ì‹¤íˆ" ì´í•˜ â†’ ì²­ì‚°
                    # ğŸ”§ FIX: Division by Zero ë°©ì–´
                    drop_from_partial = (partial_price - cur_price) / partial_price if partial_price > 0 else 0
                    # ğŸ”§ FIX: breakeven box ì ìš© - entry ì‚´ì§ ì°ëŠ” ì •ìƒ ë³€ë™ì„± í—ˆìš©
                    # - ê¸°ì¡´: entry ì°ìœ¼ë©´ ë°”ë¡œ ì”ëŸ‰ ì²­ì‚° â†’ í¬ê²Œ ê°€ëŠ” ê±°ë˜ ê¼¬ë¦¬ ì˜ë¦¼
                    # - ë³€ê²½: entry*(1-box) ì´í•˜ì¼ ë•Œë§Œ ì²­ì‚° (box = trail_min * 0.5)
                    breakeven_box = trail_min * 0.5
                    if entry_price > 0 and (cur_price <= entry_price * (1 - breakeven_box) or drop_from_partial >= profit_drop_thr):
                        reason = f"ë¶€ë¶„ìµì ˆ í›„ ì¶”ê°€í•˜ë½ -{drop_from_partial*100:.2f}% (thr:{profit_drop_thr*100:.2f}%) ì”ëŸ‰ì²­ì‚°"
                        print(f"[REMONITOR] {m} {reason} â†’ ë‚˜ë¨¸ì§€ ì²­ì‚°")
                        close_auto_position(m, reason)
                        return True
                else:
                    # ì†ì ˆ ë¶€ë¶„ì²­ì‚° í›„: ì¶”ê°€ í•˜ë½ â†’ ì²­ì‚°
                    # ğŸ”§ FIX: Division by Zero ë°©ì–´
                    drop_from_partial = (partial_price - cur_price) / partial_price if partial_price > 0 else 0
                    if drop_from_partial >= loss_drop_thr:
                        reason = f"ë¶€ë¶„ì†ì ˆ í›„ ì¶”ê°€í•˜ë½ -{drop_from_partial*100:.2f}% (thr:{loss_drop_thr*100:.2f}%) ì”ëŸ‰ì²­ì‚°"
                        print(f"[REMONITOR] {m} {reason} â†’ ë‚˜ë¨¸ì§€ ì²­ì‚°")
                        close_auto_position(m, reason)
                        return True

        verdict, action, rationale, ret_pct, last_price, maxrun, maxdd = \
            monitor_position(
                m, entry_price, pre,
                tight_mode=tight_mode,
                horizon=CYCLE_SEC,
                reentry=True
            )

        should_close = False
        reason = verdict or action or "ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ"

        # ğŸ”§ FIX: ë¶„ê¸° ìˆœì„œ ìˆ˜ì • - ìœ„í—˜ì‹ í˜¸/ì²­ì‚°ê¶Œê³ ë¥¼ TPë³´ë‹¤ ë¨¼ì € ì²˜ë¦¬
        # (ê¸°ì¡´: ret_pct ë¸”ë¡ì´ ë¨¼ì € ì‹¤í–‰ë˜ì–´ ì²­ì‚°ê¶Œê³ /ë¶€ë¶„ì²­ì‚°ê¶Œê³  ë„ë‹¬ ë¶ˆê°€)

        # ğŸ”§ FIX: ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³ ê°€ ì•„ë‹ˆë©´ ì—°ì† ì¹´ìš´íŠ¸ ë¦¬ì…‹ (ê°„í— ê²½ê³  ëˆ„ì  ë°©ì§€)
        # - ê¸°ì¡´: ë¦¬ì…‹ ì—†ì´ ëˆ„ì  â†’ "ì²­ì‚° ê¶Œê³  1ë²ˆì”© ëœ¨ë‹¤ ë§ë‹¤"ë„ ê²°êµ­ 3íšŒ ë„ë‹¬
        # - ê°œì„ : NíšŒ "ì—°ì†"ì„ ì œëŒ€ë¡œ íŒì •í•˜ë ¤ë©´ ë¹„ì²­ì‚°ê¶Œê³  ì‹œ ë¦¬ì…‹ í•„ìˆ˜
        if not (verdict and verdict.startswith("ì²­ì‚° ê¶Œê³ (")):
            with _POSITION_LOCK:
                pos_reset = OPEN_POSITIONS.get(m, {})
                if pos_reset and pos_reset.get("ctx_close_count", 0) > 0:
                    pos_reset["ctx_close_count"] = 0
                    print(f"[REMONITOR] {m} ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³  í•´ì œ â†’ ctx_close_count ë¦¬ì…‹")

        # 1) ê¸‰ë½ / ì†ì ˆ ê¶Œê³  â†’ ì¦‰ì‹œ ì²­ì‚°
        if verdict and ("ê¸‰ë½" in verdict or "ì†ì ˆ" in verdict):
            should_close = True

        # 2) ì „ëŸ‰ ì²­ì‚° ê¶Œê³  (action ê¸°ë°˜) â†’ ì¦‰ì‹œ ì²­ì‚°
        elif action and "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ " in action:
            should_close = True

        # 3) ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³  â†’ NíšŒ ì—°ì† ì‹œ ì²­ì‚° (ë‚˜ìœ í¬ì§€ì…˜ ì˜¤ë˜ ëŒë¦¼ ë°©ì§€)
        elif verdict and verdict.startswith("ì²­ì‚° ê¶Œê³ ("):
            # ğŸ”§ FIX: ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³ ê°€ ê³„ì† ë°˜ë³µë˜ë©´ ì†ì‹¤ì„ ì‹œê°„ìœ¼ë¡œ í‚¤ì›€
            # - 3íšŒ ì—°ì†ì´ë©´ ì „ëŸ‰ ì²­ì‚°ìœ¼ë¡œ ìŠ¹ê²©
            CONTEXT_CLOSE_THRESHOLD = 3
            with _POSITION_LOCK:
                pos_ctx = OPEN_POSITIONS.get(m, {})
                ctx_count = pos_ctx.get("ctx_close_count", 0) + 1
                if pos_ctx:
                    pos_ctx["ctx_close_count"] = ctx_count

            if ctx_count >= CONTEXT_CLOSE_THRESHOLD:
                print(f"[REMONITOR] {m} ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³  {ctx_count}íšŒ ì—°ì† â†’ ì „ëŸ‰ ì²­ì‚°")
                should_close = True
                reason = f"ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³  {ctx_count}íšŒ ì—°ì†"
            else:
                print(f"[REMONITOR] {m} ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³  {ctx_count}/{CONTEXT_CLOSE_THRESHOLD} â†’ ê³„ì† ëª¨ë‹ˆí„°ë§")
                continue

        # 4) ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³  â†’ ì‹¤ì œ 50% ë§¤ë„ í›„ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ ":
            ok, msg, executed = safe_partial_sell(m,
                                                  sell_ratio=0.5,
                                                  reason="ëª¨ë‹ˆí„° ê¶Œê³  ë¶€ë¶„ì²­ì‚°")
            if ok and executed > 0:
                print(msg)
            continue

        # 5) ìˆ˜ìµ ì‹¤í˜„ (ğŸ”§ signal_tagë³„ ìµì ˆ ëª©í‘œ ì°¨ë“±í™”) - ìµì ˆí‚¤ìš°ê¸° ì „ëµ
        #    - ê°•ì‹ í˜¸: ë†’ì€ ëª©í‘œ, ì•½ì‹ í˜¸: ë‚®ì€ ëª©í‘œ (ê¸°ëŒ€ê°’ ê°œì„ )
        #    - ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: ì „ì²´ ëª©í‘œ ìƒí–¥ â†’ ë” í° ìˆ˜ìµ ì¶”êµ¬
        elif ret_pct is not None:
            # signal_tagë³„ ìµì ˆ ëª©í‘œ (% ë‹¨ìœ„) - ìµì ˆí‚¤ìš°ê¸° ì ìš©
            # ğŸ”§ TP ì•ë‹¹ê¸°ê¸°: ë¶€ë¶„ìµì ˆì„ ë¹¨ë¦¬ â†’ ìŠ¹ë¥  ì•ˆì •í™”, ë‚¨ì€ ë¬¼ëŸ‰ì€ íŠ¸ë ˆì¼ë¡œ ê¸¸ê²Œ
            TP_FULL = {
                "ğŸ”¥ì í™”": 1.8,              # 3.0% â†’ 1.8% (ê°•ì‹ í˜¸ë„ í˜„ì‹¤ì ìœ¼ë¡œ)
                "ê°•ëŒíŒŒ (EMAâ†‘+ê³ ì â†‘)": 1.5,  # 2.5% â†’ 1.5%
                "EMAâ†‘": 1.2,                 # 2.0% â†’ 1.2%
                "ê³ ì â†‘": 1.0,                # 1.6% â†’ 1.0%
                "ê±°ë˜ëŸ‰â†‘": 0.8,              # 1.3% â†’ 0.8%
                "ê¸°ë³¸": 0.9,                 # 1.5% â†’ 0.9%
            }
            TP_PART = {
                "ğŸ”¥ì í™”": 0.6,              # 1.6% â†’ 0.6% (ê°•ì‹ í˜¸ë„ ë¹ ë¥¸ ë¶€ë¶„ìµì ˆ)
                "ê°•ëŒíŒŒ (EMAâ†‘+ê³ ì â†‘)": 0.5,  # 1.4% â†’ 0.5%
                "EMAâ†‘": 0.45,                # 1.2% â†’ 0.45%
                "ê³ ì â†‘": 0.40,               # 1.0% â†’ 0.40%
                "ê±°ë˜ëŸ‰â†‘": 0.35,             # 0.8% â†’ 0.35%
                "ê¸°ë³¸": 0.40,                # 0.9% â†’ 0.40%
            }

            # í˜„ì¬ í¬ì§€ì…˜ì˜ signal_tag ê°€ì ¸ì˜¤ê¸°
            with _POSITION_LOCK:
                pos_for_tag = OPEN_POSITIONS.get(m) or {}
            tag = pos_for_tag.get("signal_tag", "ê¸°ë³¸")

            # ëª©í‘œê°’ ì¡°íšŒ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
            full_tp = TP_FULL.get(tag, 1.2)
            part_tp = TP_PART.get(tag, 0.7)

            # ğŸ”§ FIX: TP ë°”ë‹¥ê°’ = alphaë§Œ (ìŠ¬ë¦½ ì´ì¤‘ ì°¨ê° ë°©ì§€)
            # - ìŠ¬ë¦½ì€ ret_netì—ì„œ í•œ ë²ˆë§Œ ì°¨ê° (Aì•ˆ)
            # - ê¸°ì¡´: slip_extraë¡œ TP ë°”ë‹¥ê°’ ìƒí–¥ + ret_netì—ì„œ ìŠ¬ë¦½ ì°¨ê° â†’ ì´ì¤‘ í˜ë„í‹°
            # - ê°œì„ : ret_net ì°¨ê°ë§Œ ìœ ì§€, TP ë°”ë‹¥ê°’ì—ì„œëŠ” ìŠ¬ë¦½ ì œê±°
            cp_alpha = PROFIT_CHECKPOINT_MIN_ALPHA * 100.0  # 0.1% (alpha)

            # ğŸ”§ FIX: exit ìŠ¬ë¦½ì€ ret_netì—ì„œë§Œ ë°˜ì˜ (ì´ì¤‘ ì°¨ê° ë°©ì§€)
            avg_exit_slip_pct = get_expected_exit_slip_pct()  # exit ì „ìš© trimmed mean
            # slip_extra ì œê±°: TP ë°”ë‹¥ê°’ + ret_net ìŠ¬ë¦½ ì°¨ê°ì€ ì´ì¤‘ í˜ë„í‹°
            # â†’ ê³ ìŠ¬ë¦½ ì¢…ëª©ì—ì„œ ìµì ˆì´ ëŠ¦ì–´ì ¸ ìˆ˜ìµ ê¸°íšŒ ê°ì†Œí•˜ëŠ” ë¬¸ì œ í•´ê²°

            part_tp = max(part_tp, cp_alpha + 0.15)    # 0.25%+ ìµœì†Œ (slip_extra ì œê±°)
            full_tp = max(full_tp, cp_alpha + 0.45)    # 0.55%+ ìµœì†Œ (slip_extra ì œê±°)

            # ğŸ”§ FIX: TP íŒë‹¨ì„ net ê¸°ì¤€ìœ¼ë¡œ (ìˆ˜ìˆ˜ë£Œ + ì˜ˆìƒ exit ìŠ¬ë¦½ ë°˜ì˜)
            # - grossë¡œ ë¹„êµí•˜ë©´ ìˆ˜ìˆ˜ë£Œ/ìŠ¬ë¦½ ë•Œë¬¸ì— ì‚¬ì‹¤ìƒ ë³¸ì ˆ~ë¯¸ì„¸ì†ìµ êµ¬ê°„ì—ì„œ ìµì ˆ ë°œìƒ
            # - ìŠ¬ë¦½ì€ ì—¬ê¸°ì„œë§Œ í•œ ë²ˆ ì°¨ê° (Aì•ˆ: ret_net ì°¨ê° ìœ ì§€)
            expected_exit_slip = avg_exit_slip_pct  # exit ìŠ¬ë¦½ë§Œ (entryëŠ” ì´ë¯¸ ë°˜ì˜ë¨)
            ret_net = ret_pct - (FEE_RATE_ROUNDTRIP * 100.0) - expected_exit_slip

            if ret_net >= full_tp:
                should_close = True
                reason = f"{tag} ëª©í‘œìˆ˜ìµ net:{ret_net:.2f}% â‰¥ {full_tp:.1f}% ì „ëŸ‰ì²­ì‚°"
            elif ret_net >= part_tp:
                # ë¶€ë¶„ìµì ˆ: 50% ë§¤ë„ í›„ ê³„ì† ë³´ìœ  (30%â†’50%ë¡œ ìƒí–¥)
                ok, msg, executed = safe_partial_sell(
                    m, sell_ratio=0.5, reason=f"{tag} net:{ret_net:.2f}% â‰¥ {part_tp:.1f}% 50% ë¶€ë¶„ìµì ˆ")
                if ok and executed > 0:
                    print(msg)
                # ë¶€ë¶„ìµì ˆ í›„ì—ëŠ” ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
                continue

        # 6) ìœ ì§€ ê¶Œê³  â†’ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ìœ ì§€ ê¶Œê³ ":
            continue

        # 7) ê·¸ëƒ¥ ì‹œê°„ ë§Œë£Œë©´ â†’ ë‹¤ì‹œ í•œ ë²ˆ ì‚¬ì´í´
        elif verdict == "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)":
            continue

        if should_close:
            print(f"[REMONITOR] {m} ìë™ì²­ì‚° ì¡°ê±´ ì¶©ì¡± â†’ ì²­ì‚° ({reason})")
            close_auto_position(m, reason)
            return True


# =========================
# ì–¼ëŸ¿ ì •ì±…
# =========================
SILENT_MIDDLE_ALERTS = True


def tg_send_mid(t):
    if not SILENT_MIDDLE_ALERTS:
        return tg_send(t)
    else:
        print("[SILENT]", t)
        return True

MIN_RELATIVE_KRW_X = 1.08  # 1.18 -> 1.25 (ê³¼ê±°ëŒ€ë¹„ ì¦ê°€ìœ¨)

# í‹±/ì²´ê²° ê¸°ë°˜
MIN_TICKS_COUNT = 3
MIN_TURNOVER = 0.018
TICKS_BUY_RATIO = 0.56

# ìœ„í—˜ ê´€ë¦¬ (ìŠ¤í”„ë ˆë“œ)
MAX_SPREAD_FAST = 1.00  # 1.10 -> 0.80
MIN_DEPTH_KRW = 6_000_000

# ========================================
# â˜…â˜…â˜… 1ë‹¨ê³„ ê²Œì´íŠ¸ ì„ê³„ì¹˜ (ìë™í•™ìŠµ ëŒ€ìƒ) â˜…â˜…â˜…
# ========================================
# ğŸ”§ 2024-12 ìŠ¹ë¥  ë°ì´í„° ê¸°ë°˜ íŠœë‹ (50ê±´: 32% ìŠ¹ë¥ )
# íšŒì „ìœ¨: ìŠ¹ 10.2% vs íŒ¨ 26.8% â†’ ìƒí•œ 20%
# ë°°ìˆ˜: ìŠ¹ 1.01x vs íŒ¨ 0.58x â†’ í•˜í•œ 0.8x
# ì—°ì†ë§¤ìˆ˜: ìŠ¹ 8.0 vs íŒ¨ 4.43 â†’ í•˜í•œ 6
# ê°€ì†ë„: ìŠ¹ 1.96 vs íŒ¨ 2.42 â†’ ìƒí•œ 2.5x
# ========================================
GATE_TURN_MIN = 2.0       # íšŒì „ìœ¨ í•˜í•œ (%)
GATE_TURN_MAX = 30.0      # ğŸ”§ íšŒì „ìœ¨ ìƒí•œ (%) - 60â†’30 (ì´ë¯¸ í•œì°¸ ë‹¬ë¦° ì¢…ëª© ì°¨ë‹¨)
GATE_SPREAD_MAX = 1.50    # ğŸ”§ HOTFIX: ì €ê°€ ì½”ì¸(100ì› ì´í•˜) ìŠ¤í”„ë ˆë“œ í—ˆìš© - 0.40â†’1.50%
GATE_ACCEL_MIN = 0.3      # ê°€ì†ë„ í•˜í•œ (x) - ì´ˆê¸° ì™„í™” (í•™ìŠµ ë°ì´í„° ìˆ˜ì§‘ìš©)
GATE_ACCEL_MAX = 5.0      # ğŸ”§ ê°€ì†ë„ ìƒí•œ (x) - 2.5â†’5.0 ì™„í™” (ë¬´ì•ŒëŒ ëŒ€ì‘)
GATE_BUY_RATIO_MIN = 0.58 # ğŸ”§ ë§¤ìˆ˜ë¹„ í•˜í•œ - 0.55â†’0.58 ê°•í™” (CONSEC ì™„í™” ë³´ì™„)
GATE_SURGE_MAX = 100.0    # ğŸ”§ ì‚¬ì‹¤ìƒ ì œê±°: ê¸‰ë“± ì´ˆì… ì¡ê¸°
GATE_OVERHEAT_MAX = 20.0  # ğŸ”§ ì¬í™œì„±í™”: ê³¼ì—´ í•„í„° (accel*surge > 20 = ê¼­ëŒ€ê¸°)
GATE_IMBALANCE_MIN = 0.50 # ğŸ”§ ë°ì´í„° ê¸°ë°˜: ìŠ¹0.65 vs íŒ¨0.45 â†’ 0.50
GATE_CONSEC_MIN = 1       # ğŸ”§ ì—°ì†ë§¤ìˆ˜ í•˜í•œ - 2â†’1 ì™„í™” (ì ì‹¬ì‹œê°„ ëŒ€ì‘, ë§¤ìˆ˜ë¹„ë¡œ í’ˆì§ˆ ë³´ì™„)
GATE_CONSEC_MAX = 15      # ğŸ”§ ì—°ì†ë§¤ìˆ˜ ìƒí•œ - 10â†’15 ì™„í™”
GATE_STRONGBREAK_OFF = False  # ğŸ”§ ê°•ëŒíŒŒ í™œì„± (ì„ê³„ì¹˜ë¡œ í’ˆì§ˆ ê´€ë¦¬)
# ê°•ëŒíŒŒ ì „ìš© ê°•í™” ì„ê³„ì¹˜ (ì¼ë°˜ë³´ë‹¤ ë¹¡ì„¸ê²Œ)
GATE_STRONGBREAK_CONSEC_MIN = 6   # ğŸ”§ 8â†’6 ì™„í™”
GATE_STRONGBREAK_TURN_MAX = 25.0  # ğŸ”§ 15â†’25 ì™„í™”
GATE_STRONGBREAK_ACCEL_MAX = 3.5  # ğŸ”§ 2.0â†’3.5 ì™„í™”
GATE_CV_MAX = 4.0         # ğŸ”§ CV ìƒí•œ - 4.0 (ê¸‰ë“±ì£¼ ì§„ì… í—ˆìš©)
GATE_FRESH_AGE_MAX = 3.0  # ğŸ”§ í‹± ì‹ ì„ ë„ ìƒí•œ (ì´ˆ) - 7.5â†’3.0 (ì¥ì¤‘ ê¸°ë³¸, ì‹œê°„ëŒ€ë³„ ë™ì  ì™„í™”)
GATE_VOL_MIN = 20_000_000  # ğŸ”§ 2ì²œë§Œì› (ì¤‘ì†Œí˜• ê¸‰ë“± ì´ˆê¸° ìºì¹˜)
GATE_SURGE_MIN = 0.7      # ğŸ”§ ë°°ìˆ˜ í•˜í•œ - 0.5â†’0.7 (ê°€ì§œ ì´ˆì…/ë´‡í•‘í ì°¨ë‹¨)
GATE_VOL_VS_MA_MIN = 0.5  # ğŸ”§ MA ëŒ€ë¹„ ê±°ë˜ëŸ‰ í•˜í•œ (ìƒìˆ˜â†’ì „ì—­ë³€ìˆ˜í™”, í•™ìŠµ/íŠœë‹ ê°€ëŠ¥)
GATE_PRICE_MIN = 0.0005   # ğŸ”§ ì™„í™”: 0.1%â†’0.05% - ë³´í•©ì¥ë„ ì§„ì… í—ˆìš©

# ========================================
# ğŸš€ Pre-break Probe ì„¤ì • (ì„ í–‰ ì§„ì…)
# ========================================
PREBREAK_ENABLED = False              # Pre-break ë¹„í™œì„±í™” (stage1_gateë¡œ í†µí•©)
PREBREAK_HIGH_PCT = 0.002             # ê³ ì  ëŒ€ë¹„ 0.2% ì´ë‚´
PREBREAK_POSTCHECK_SEC = 2            # probe ì „ìš© 2ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬
PREBREAK_BUY_MIN = 0.60               # ìµœì†Œ ë§¤ìˆ˜ë¹„ 60%
PREBREAK_KRW_PER_SEC_MIN = 20_000     # ìµœì†Œ ê±°ë˜ì†ë„ (ì›/ì´ˆ)
PREBREAK_IMBALANCE_MIN = 0.55         # ìµœì†Œ í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ (ë§¤ìˆ˜ìš°ìœ„)

# í—ˆìˆ˜ ë°©ì–´
MIN_REAL_TRADES = 10

# ì†ì ˆ/ëª¨ë‹ˆí„°ë§
STOP_LOSS_PCT = 0.008
RECHECK_SEC = 5

# Ignition
IGN_BREAK_LOOKBACK = 12
IGN_MIN_BODY = 0.006
IGN_MIN_BUY = 0.60
# USE_5M_CONTEXT ìƒë‹¨ì—ì„œ ì¼ì›í™” (ì¤‘ë³µ ì œê±°)

# Bot-aware
BOT_PINGPONG_MAX_BAND = 0.0015
BOT_PINGPONG_MIN_ALT = 0.90
BOT_WASH_REPEAT_VOL_N = 5
BOT_TWAP_MAX_CV = 0.48
BOT_TWAP_MAX_PSTD = 0.0018
BOT_ACCUM_MIN_BUY = 0.54
BOT_ACCUM_MAX_BUY = 0.68

# íŠ¸ë Œë“œ ê°€ë“œ

# Early Entry
# EARLY_FLOW_MIN_KRWPSEC ìƒë‹¨ì—ì„œ ì¼ì›í™” (ì¤‘ë³µ ì œê±°)

# í‹± ê¸°ë°˜ ì¡°ê¸° ë¸Œë ˆì´í¬
USE_TICK_BREAK = True
TICK_BREAK_GAP = 0.0020

# ì ì‘ì‹ ë³¼ë¥¨ ì„œì§€
ABS_SURGE_KRW = 2_200_000   # ì ˆëŒ€ ê±°ë˜ëŒ€ê¸ˆ ì„œì§€ ê¸°ì¤€ (2.2M KRW)
RELAXED_X = 1.08            # ê³¼ê±°ëŒ€ë¹„ ê±°ë˜ëŒ€ê¸ˆ ì™„í™” ë°°ìœ¨

# ì¿¨ë‹¤ìš´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
REARM_MIN_SEC = 45
REARM_PRICE_GAP = 0.009
REARM_PULLBACK_MAX = 0.004
REARM_REBREAK_MIN = 0.0028

# í¬ìŠ¤íŠ¸ì²´í¬(í—ˆìˆ˜ 2ì°¨) - ìƒë‹¨ì—ì„œ ì •ì˜ë¨, ì´ì¤‘ì„ ì–¸ ì œê±°
# POSTCHECK_ENABLED = False  # âŒ ì œê±°: ìƒë‹¨(56ì¤„)ì—ì„œ ì •ì˜ë¨
POSTCHECK_WINDOW_SEC = 3
POSTCHECK_MIN_BUY = 0.46  # 0.52 -> 0.54
POSTCHECK_MIN_RATE = 0.16  # 0.18 -> 0.26
POSTCHECK_MAX_PSTD = 0.0028  # 0.0028 -> 0.0022
POSTCHECK_MAX_CV = 0.72  # 0.70 -> 0.60
POSTCHECK_MAX_DD = 0.018

# ë™ì  ì†ì ˆ(ATR) - ë‹¨ì¼ ìŠ¤íƒ‘ (í‹±ìŠ¤íƒ‘ ì œê±°) - ìµì ˆí‚¤ìš°ê¸° ì ìš©
ATR_PERIOD = 14
ATR_MULT = 0.40           # ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: 0.35 â†’ 0.40 (íœ©ì˜ ë°©ì§€)
DYN_SL_MIN = 0.005        # ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: 0.4% â†’ 0.5% (ì†ì ˆ ì™„í™”)
DYN_SL_MAX = 0.007        # ğŸ”§ ìµì ˆí‚¤ìš°ê¸°: 0.6% â†’ 0.7% (ì†ì ˆ ì™„í™”)

# =========================
# ğŸ¯ í‹± ê¸°ë°˜ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ë¹„í™œì„±í™” - ATR ë‹¨ì¼ ìŠ¤íƒ‘ ì‚¬ìš©)
# =========================
MIN_TICK_DIST = 3                # (ë¯¸ì‚¬ìš©)
ATR_TICKS_MULT = 0.6             # (ë¯¸ì‚¬ìš©)
SPREAD_TICKS_PAD = 1             # (ë¯¸ì‚¬ìš©)
# ğŸ”§ HARD_STOP_DDëŠ” ìƒë‹¨ í”„ë¡œíŒŒì¼ì—ì„œë§Œ ì„¤ì • (ì´ì¤‘ì •ì˜ ì œê±°)

# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ (ìš°íšŒ ì—„ê²©í™”)
ULTRA_RELAX_ON_MEGA = True
MEGA_BREAK_MIN_GAP = 0.012  # ğŸ”§ 2.2% â†’ 1.2% (ê³„ë‹¨ì‹ ê¸‰ë“± ìºì¹˜)
MEGA_MIN_1M_CHG = 0.012  # ğŸ”§ 2.5% â†’ 1.2% (1ë¶„ 1.2% ìƒìŠ¹ì´ë©´ ì¶©ë¶„)
MEGA_VOL_Z = 2.8  # 2.2 -> 2.8
MEGA_ABS_KRW = 4_000_000  # 2.0M -> 4.0M

# =========================
# ğŸ¯ ë¦¬ìŠ¤í¬ ìŠ¤ì½”ì–´ ì„¤ì • (AND â†’ ê°€ì¤‘í•©)
# =========================
USE_RISK_SCORE = True

# ê°€ì¤‘ì¹˜ (í•©ê³„ 100) - ğŸ”§ ì´ˆê¸°ê°’ ê³ ì • (ìë™í•™ìŠµ ë¦¬ì…‹)
SCORE_WEIGHTS = {
    "buy_ratio": 28,      # ë§¤ìˆ˜ë¹„ (í•µì‹¬)
    "spread": 15,         # ìŠ¤í”„ë ˆë“œ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
    "turn": 22,           # íšŒì „ìœ¨
    "imbalance": 18,      # ì˜¤ë”ë¶ ì„ë°¸ëŸ°ìŠ¤
    "fresh": 7,           # í‹± ì‹ ì„ ë„
    "volume_surge": 10,   # ê±°ë˜ëŸ‰ ê¸‰ì¦
}

def calc_orderbook_imbalance(ob):
    """
    1~3í˜¸ê°€ ê°€ì¤‘ í‰ê·  ì„ë°¸ëŸ°ìŠ¤ ê³„ì‚°
    - 1í˜¸ê°€ ê°€ì¤‘ì¹˜ 3, 2í˜¸ê°€ 2, 3í˜¸ê°€ 1
    - ë°˜í™˜ê°’: -1.0 ~ +1.0 (ì–‘ìˆ˜=ë§¤ìˆ˜ìš°ì„¸)
    """
    try:
        units = ob["raw"]["orderbook_units"][:3]
        bid_weighted = sum(u["bid_size"] * u["bid_price"] * (3-i) for i, u in enumerate(units))
        ask_weighted = sum(u["ask_size"] * u["ask_price"] * (3-i) for i, u in enumerate(units))
        total = bid_weighted + ask_weighted
        if total <= 0:
            return 0.0
        imbalance = (bid_weighted - ask_weighted) / total
        return max(-1.0, min(1.0, imbalance))
    except:
        return 0.0

def _safe_float(x, default=0.0):
    """NaN/inf ë°©ì§€ìš© ì•ˆì „ ë³€í™˜"""
    try:
        if x is None:
            return default
        f = float(x)
        if math.isnan(f) or math.isinf(f):
            return default
        return f
    except:
        return default

def calc_risk_score(buy_ratio, spread, turn, imbalance, fresh_ok, volume_surge):
    """
    ë¦¬ìŠ¤í¬ ìŠ¤ì½”ì–´ ê³„ì‚° (0~100)
    - ê° í”¼ì²˜ë¥¼ ì •ê·œí™”í•´ì„œ ê°€ì¤‘í•©
    """
    # ğŸ”§ ì•ˆì „ íŒ¨ì¹˜: NaN/inf ë°©ì§€
    buy_ratio = _safe_float(buy_ratio, 0.5)
    spread = _safe_float(spread, 0.5)
    turn = _safe_float(turn, 0.01)
    imbalance = _safe_float(imbalance, 0.0)
    volume_surge = _safe_float(volume_surge, 1.0)

    # ğŸ”§ ì•ˆì „ íŒ¨ì¹˜: ë§¤ìˆ˜ë¹„ 100% ë¹„ì •ìƒê°’ í´ë¦¬í•‘ (í—ˆìˆ˜/ìŠ¤í‘¸í•‘ ë°©ì§€)
    if buy_ratio >= 0.999:
        buy_ratio = 0.98

    score = 0.0

    # ë§¤ìˆ˜ë¹„: 0.50~0.70 â†’ 0~100
    buy_norm = max(0, min(1, (buy_ratio - 0.50) / 0.20))
    score += SCORE_WEIGHTS["buy_ratio"] * buy_norm

    # ìŠ¤í”„ë ˆë“œ: 0.0~1.0% â†’ 100~0 (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
    spread_norm = max(0, min(1, 1.0 - spread / 1.0))
    score += SCORE_WEIGHTS["spread"] * spread_norm

    # íšŒì „ìœ¨: 0~0.05 â†’ 0~100
    turn_norm = max(0, min(1, turn / 0.05))
    score += SCORE_WEIGHTS["turn"] * turn_norm

    # ì„ë°¸ëŸ°ìŠ¤: -0.3~+0.3 â†’ 0~100
    imb_norm = max(0, min(1, (imbalance + 0.3) / 0.6))
    score += SCORE_WEIGHTS["imbalance"] * imb_norm

    # í‹± ì‹ ì„ ë„: bool â†’ 0 or 100
    score += SCORE_WEIGHTS["fresh"] * (1.0 if fresh_ok else 0.0)

    # ê±°ë˜ëŸ‰ ê¸‰ì¦: 1.0~2.5 â†’ 0~100
    surge_norm = max(0, min(1, (volume_surge - 1.0) / 1.5))
    score += SCORE_WEIGHTS["volume_surge"] * surge_norm

    return round(score, 1)

# =========================
# ğŸ§  ìë™ ê°€ì¤‘ì¹˜ í•™ìŠµ ì‹œìŠ¤í…œ
# =========================
TRADE_LOG_PATH = os.path.join(os.getcwd(), "trade_features.csv")
WEIGHTS_PATH = os.path.join(os.getcwd(), "learned_weights.json")
# ğŸ”§ ìë™í•™ìŠµ ON - ê±´ìˆ˜ ê¸°ë°˜ (ë§¤ìˆ˜ë§Œ í•™ìŠµ, ë§¤ë„ëŠ” ê³ ì •)
AUTO_LEARN_ENABLED = True   # í•™ìŠµ í™œì„±í™” (ë¡œê·¸ ìˆ˜ì§‘)
AUTO_LEARN_APPLY = False    # ğŸ”§ í•™ìŠµ ê²°ê³¼ ì‹¤ì œ ì ìš© OFF (ê·¸ë¦¼ì ëª¨ë“œ)
AUTO_LEARN_MIN_TRADES = 100 # ë¶„ì„ ì‹œ ìµœì†Œ ìƒ˜í”Œ
AUTO_LEARN_INTERVAL = 10    # ğŸ”§ 10ê±´ë§ˆë‹¤ í•™ìŠµ
AUTO_LEARN_STREAK_TRIGGER = 3  # ğŸ”§ ì—°ì† 3íŒ¨ ì‹œ ì¦‰ì‹œ í•™ìŠµ
_trade_log_lock = threading.Lock()
_trade_count_since_learn = 0  # ë§ˆì§€ë§‰ í•™ìŠµ ì´í›„ ê±°ë˜ ìˆ˜
_path_report_count = 0  # ğŸ” ê²½ë¡œ ë¦¬í¬íŠ¸ìš© ì¹´ìš´í„°
_reported_trades = set()  # ğŸ”§ ì¤‘ë³µ ì¹´ìš´íŠ¸ ë°©ì§€ìš© (market, entry_ts) ì„¸íŠ¸
PATH_REPORT_INTERVAL = 10  # ğŸ”§ 10ê±´ë§ˆë‹¤ ë°œì†¡ (ìµœê·¼ 10ê±´ ìƒì„¸ í‘œì‹œì™€ ë§ì¶¤)
# ğŸ”§ _lose_streak, _win_streakëŠ” ìƒë‹¨(ë¼ì¸ 203-204)ì—ì„œ ì„ ì–¸ë¨

FEATURE_FIELDS = [
    "ts", "market", "entry_price", "exit_price",
    "buy_ratio", "spread", "turn", "imbalance", "volume_surge",
    "fresh", "score", "entry_mode",
    "signal_tag", "filter_type",  # ğŸ” ê²½ë¡œ ë¶„ì„ìš© (signal_tag í•˜ë‚˜ë¡œ í†µì¼)
    "consecutive_buys", "avg_krw_per_tick", "flow_acceleration",  # ğŸ”¥ ìƒˆ ì§€í‘œ
    # ğŸ”¥ GATE í•µì‹¬ + ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
    "overheat", "fresh_age", "cv", "pstd", "best_ask_krw",
    # ğŸ” ì„€ë„ìš° ëª¨ë“œìš© (ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, ë‚˜ì¤‘ì— ë¶„ì„ìš©)
    "shadow_flags", "would_cut",
    # ğŸ” ë¦¬í¬íŠ¸ ìƒì„¸: ì¶”ë§¤ì—¬ë¶€ + ì²­ì‚°ì‚¬ìœ 
    "added", "exit_reason",
    # ğŸ”§ MFE/MAE (ìµœê³ ì /ìµœì €ì  ìˆ˜ìµë¥ ) - ìµì ˆ/ì†ì ˆ íŠœë‹ìš©
    "mfe_pct", "mae_pct",
    "pnl_pct", "result", "hold_sec"
]

def log_trade_features(entry_data: dict, exit_data: dict = None):
    """
    ê±°ë˜ í”¼ì²˜ ë¡œê¹… (ì§„ì… ì‹œ í˜¸ì¶œ, ì²­ì‚° ì‹œ ì—…ë°ì´íŠ¸)
    """
    with _trade_log_lock:
        new_file = not os.path.exists(TRADE_LOG_PATH)
        with open(TRADE_LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=FEATURE_FIELDS)
            if new_file:
                w.writeheader()
            row = {k: entry_data.get(k, "") for k in FEATURE_FIELDS}
            if exit_data:
                row.update(exit_data)
            w.writerow(row)

_reported_trades = set()  # ğŸ”§ FIX: (market, entry_ts) ê¸°ë°˜ ì¤‘ë³µ ë°©ì§€ (30ì´ˆâ†’ê±°ë˜ID ê¸°ë°˜)

def update_trade_result(market: str, exit_price: float, pnl_pct: float, hold_sec: float,
                        added: bool = False, exit_reason: str = "",
                        mfe_pct: float = 0.0, mae_pct: float = 0.0,
                        entry_ts: float = None):
    """
    ì²­ì‚° ì‹œ ê²°ê³¼ ì—…ë°ì´íŠ¸ + ê±´ìˆ˜ ê¸°ë°˜ í•™ìŠµ íŠ¸ë¦¬ê±° + ê²½ë¡œ ë¦¬í¬íŠ¸
    - added: ì¶”ë§¤ ì—¬ë¶€ (probe â†’ confirm ìŠ¹ê²© ì‹œ True)
    - exit_reason: ì²­ì‚° ì‚¬ìœ  (ì˜ˆ: ATRì†ì ˆ, íŠ¸ë ˆì¼ë§, ì–‡ì€ìˆ˜ìµ, ì‹œê°„ì¢…ë£Œ ë“±)
    - mfe_pct: ìµœê³  ìˆ˜ìµë¥  (Maximum Favorable Excursion)
    - mae_pct: ìµœì € ìˆ˜ìµë¥  (Maximum Adverse Excursion)
    - entry_ts: ì§„ì… ì‹œê° (ì¤‘ë³µ ë°©ì§€ìš© - ë™ì¼ ê±°ë˜ ì‹ë³„)
    """
    global _trade_count_since_learn, _lose_streak, _win_streak, _path_report_count

    # ğŸ”§ ë°©ì–´: last_trade_was_lossê°€ ì•„ì§ ì—†ìœ¼ë©´ ì´ˆê¸°í™” (ë¡œì»¬ ë°”ì¸ë”©)
    last_trade_was_loss = globals().setdefault("last_trade_was_loss", {})

    # ğŸ”§ FIX: (market, entry_ts) ê¸°ë°˜ ì¤‘ë³µ ë°©ì§€ - ë™ì¼ ê±°ë˜ 2íšŒ ê¸°ë¡ ë°©ì§€
    # entry_tsê°€ ìˆìœ¼ë©´ ê±°ë˜ IDë¡œ ì‚¬ìš©, ì—†ìœ¼ë©´ market+í˜„ì¬ì‹œê° ê¸°ì¤€ (í˜¸í™˜ì„±)
    if entry_ts is not None:
        # ğŸ”§ FIX: ms ë‹¨ìœ„ë¡œ ë³€ê²½ (1ì´ˆ ë‚´ ì¬ì§„ì… ì‹œ ì¤‘ë³µ íŒì • ë°©ì§€)
        trade_id = (market, int(entry_ts * 1000))  # ms ë‹¨ìœ„
        if trade_id in _reported_trades:
            print(f"[UPDATE_TRADE] {market} ë™ì¼ ê±°ë˜ ì¤‘ë³µ ìŠ¤í‚µ (entry_ts={entry_ts:.0f})")
            return
        _reported_trades.add(trade_id)
        # ì˜¤ë˜ëœ í•­ëª© ì •ë¦¬ (1ì‹œê°„ ì´ìƒ ì§€ë‚œ ê±°ë˜)
        # ğŸ”§ FIX: discard()ëŠ” ë‹¨ì¼ ì›ì†Œë§Œ ì œê±° â†’ difference_update() ì‚¬ìš©
        now = time.time()
        _old_trades = {t for t in _reported_trades if now - t[1] / 1000 > 3600}  # msâ†’sec ë³€í™˜
        _reported_trades.difference_update(_old_trades)
    else:
        # ğŸ”§ í˜¸í™˜ì„±: entry_ts ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©ì‹ (market + 30ì´ˆ)
        now_ts = time.time()
        recent = [t for t in _reported_trades if t[0] == market and now_ts - t[1] < 30]
        if recent:
            print(f"[UPDATE_TRADE] {market} ì¤‘ë³µ í˜¸ì¶œ ìŠ¤í‚µ (30ì´ˆ ë‚´)")
            return
        _reported_trades.add((market, int(now_ts)))

    print(f"[UPDATE_TRADE] {market} ì²­ì‚° ê¸°ë¡ ì‹œì‘ (pnl: {pnl_pct:.2%})")

    is_win = pnl_pct > 0
    csv_exists = os.path.exists(TRADE_LOG_PATH)

    # ğŸ”§ ì†ì‹¤ í›„ ë™ì¼ ì¢…ëª© ì¿¨ë‹¤ìš´ 2ë°° ì ìš©ìš© í”Œë˜ê·¸ ì„¤ì •
    last_trade_was_loss[market] = not is_win

    if not csv_exists:
        print(f"[UPDATE_TRADE] {TRADE_LOG_PATH} íŒŒì¼ ì—†ìŒ (CSV ì—…ë°ì´íŠ¸ ìŠ¤í‚µ, ë¦¬í¬íŠ¸ëŠ” ê³„ì†)")
    else:
        with _trade_log_lock:
            try:
                rows = []
                with open(TRADE_LOG_PATH, "r", encoding="utf-8") as f:
                    reader = csv.DictReader(f)
                    rows = list(reader)

                # ë§ˆì§€ë§‰ í•´ë‹¹ ë§ˆì¼“ ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸
                for i in range(len(rows) - 1, -1, -1):
                    if rows[i]["market"] == market and not rows[i].get("exit_price"):
                        rows[i]["exit_price"] = str(exit_price)
                        rows[i]["pnl_pct"] = f"{pnl_pct:.4f}"
                        rows[i]["result"] = "win" if is_win else "lose"
                        rows[i]["hold_sec"] = str(int(hold_sec))
                        # ğŸ” ë¦¬í¬íŠ¸ ìƒì„¸: ì¶”ë§¤ì—¬ë¶€ + ì²­ì‚°ì‚¬ìœ 
                        rows[i]["added"] = "1" if added else "0"
                        rows[i]["exit_reason"] = exit_reason
                        # ğŸ”§ MFE/MAE ê¸°ë¡ (ìµì ˆ/ì†ì ˆ íŠœë‹ìš©)
                        rows[i]["mfe_pct"] = f"{mfe_pct:.4f}"
                        rows[i]["mae_pct"] = f"{mae_pct:.4f}"
                        break

                # ë‹¤ì‹œ ì“°ê¸°
                with open(TRADE_LOG_PATH, "w", newline="", encoding="utf-8") as f:
                    w = csv.DictWriter(f, fieldnames=FEATURE_FIELDS)
                    w.writeheader()
                    w.writerows(rows)
            except Exception as e:
                print(f"[TRADE_LOG_UPDATE_ERR] {e}")

    # ğŸ”§ ê±´ìˆ˜ ê¸°ë°˜ í•™ìŠµ íŠ¸ë¦¬ê±° (ë§¤ìˆ˜ë§Œ í•™ìŠµ)
    if AUTO_LEARN_ENABLED:
        _trade_count_since_learn += 1

        # ğŸ”§ FIX: streak ì—…ë°ì´íŠ¸ëŠ” record_trade()ì—ì„œë§Œ (ì¤‘ë³µ ë°©ì§€)
        # - ì—¬ê¸°ì„œ ë˜ ì—…ë°ì´íŠ¸í•˜ë©´ ê±°ë˜ 1ë²ˆì— streak 2ë²ˆ ì˜¬ë¼ê°
        # - record_trade()ê°€ streakì˜ ë‹¨ì¼ ì§„ì‹¤ ê³µê¸‰ì›(SSOT)

        # ğŸ”§ ì—°íŒ¨ 3íšŒ ì‹œ Pre-break 10ë¶„ê°„ ì¤‘ì§€ (streak ê°’ì€ ì°¸ì¡°ë§Œ)
        global _PREBREAK_SUSPEND_UNTIL
        if _lose_streak >= 3:
            _PREBREAK_SUSPEND_UNTIL = time.time() + 600  # 10ë¶„
            print(f"[LOSE_STREAK] ì—°ì† {_lose_streak}íŒ¨ â†’ Pre-break 10ë¶„ ì¤‘ì§€")

        # í•™ìŠµ ì¡°ê±´: 10ê±´ë§ˆë‹¤ OR ì—°ì† 3íŒ¨
        should_learn = (
            _trade_count_since_learn >= AUTO_LEARN_INTERVAL or
            _lose_streak >= AUTO_LEARN_STREAK_TRIGGER
        )

        if should_learn:
            trigger_reason = f"ì—°ì† {_lose_streak}íŒ¨" if _lose_streak >= AUTO_LEARN_STREAK_TRIGGER else f"{_trade_count_since_learn}ê±´ ë„ë‹¬"
            print(f"[AUTO_LEARN] í•™ìŠµ íŠ¸ë¦¬ê±°: {trigger_reason}")
            _trade_count_since_learn = 0  # ë¦¬ì…‹

            try:
                learn_result = analyze_and_update_weights()
                if learn_result:
                    thr = learn_result.get("thresholds", {})
                    chg = learn_result.get("changes", {})

                    # analyze_and_update_weights() ì•ˆì—ì„œ ì´ë¯¸ GATE_* ì „ì—­ì„ ê°±ì‹ í•¨
                    change_detail = " | ".join(
                        f"{k}:{v:+g}" for k, v in chg.items() if v != 0
                    ) or "ë³€í™”ì—†ìŒ"

                    tg_send(
                        f"ğŸ§  <b>ìë™í•™ìŠµ ì™„ë£Œ</b> ({trigger_reason})\n"
                        f"ğŸ“Š ìŠ¹ë¥ : {learn_result['win_rate']}% ({learn_result['wins']}ìŠ¹/{learn_result['loses']}íŒ¨)\n"
                        f"ğŸ“ˆ ìƒ˜í”Œ: {learn_result.get('sample_size', 0)}ê±´\n"
                        f"ğŸ§± ê²Œì´íŠ¸ ë³€í™”: {change_detail}\n"
                        f"ğŸ¯ í˜„ì¬ ì„ê³„ì¹˜: "
                        f"ë§¤ìˆ˜ë¹„â‰¥{thr.get('GATE_BUY_RATIO_MIN', GATE_BUY_RATIO_MIN):.0%} "
                        f"ìŠ¤í”„ë ˆë“œâ‰¤{thr.get('GATE_SPREAD_MAX', GATE_SPREAD_MAX):.2f}% "
                        f"íšŒì „â‰¥{thr.get('GATE_TURN_MIN', GATE_TURN_MIN):.1f}% "
                        f"ì„ë°¸â‰¥{thr.get('GATE_IMBALANCE_MIN', GATE_IMBALANCE_MIN):.2f} "
                        f"ê¸‰ë“±â‰¤{thr.get('GATE_SURGE_MAX', GATE_SURGE_MAX):.1f}x "
                        f"ê°€ì†â‰¥{thr.get('GATE_ACCEL_MIN', GATE_ACCEL_MIN):.2f}x"
                    )
                else:
                    tg_send_mid(f"ğŸ§  ìë™í•™ìŠµ ì‹œë„ ({trigger_reason}) - ë°ì´í„° ë¶€ì¡±ìœ¼ë¡œ ìŠ¤í‚µ")
            except Exception as e:
                print(f"[AUTO_LEARN_ERR] {e}")

    # ğŸ” ê²½ë¡œ ë¦¬í¬íŠ¸ (20ê±´ë§ˆë‹¤ ìë™ ë°œì†¡)
    _path_report_count += 1
    print(f"[PATH_REPORT] ì¹´ìš´íŠ¸: {_path_report_count}/{PATH_REPORT_INTERVAL}")
    if _path_report_count >= PATH_REPORT_INTERVAL:
        _path_report_count = 0
        try:
            # ê²½ë¡œ í†µê³„ + ìƒì„¸ ê±°ë˜ ëª©ë¡ í•©ì³ì„œ ë°œì†¡
            path_report = get_path_statistics(50)  # ìµœê·¼ 50ê±´ ê²½ë¡œ ë¶„ì„
            detail_report = get_recent_trades_detail(10)  # ìµœê·¼ 10ê±´ ìƒì„¸
            combined = path_report + detail_report
            print(f"[PATH_REPORT] ë¦¬í¬íŠ¸ ë°œì†¡ ì‹œë„")
            tg_send(combined)
        except Exception as e:
            print(f"[PATH_REPORT_ERR] {e}")

def get_path_statistics(last_n: int = 100) -> str:
    """
    ğŸ” ê²½ë¡œë³„ ìŠ¹ë¥  í†µê³„ ìƒì„± (í…”ë ˆê·¸ë¨ ë¦¬í¬íŠ¸ìš©)
    """
    if not os.path.exists(TRADE_LOG_PATH):
        return "ğŸ“Š ê±°ë˜ ê¸°ë¡ ì—†ìŒ"

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        # result ì»¬ëŸ¼ì´ ìˆê³  ê°’ì´ ìˆëŠ” í–‰ë§Œ (ì²­ì‚° ì™„ë£Œëœ ê±°ë˜)
        if "result" not in df.columns:
            return "ğŸ“Š ì²­ì‚° ê¸°ë¡ ì—†ìŒ"

        df = df[df["result"].isin(["win", "lose"])].tail(last_n)

        if len(df) < 5:
            return f"ğŸ“Š ë°ì´í„° ë¶€ì¡± ({len(df)}ê±´, ìµœì†Œ 5ê±´ í•„ìš”)"

        total = len(df)
        wins = len(df[df["result"] == "win"])
        overall_wr = wins / total * 100 if total > 0 else 0

        lines = [
            f"ğŸ“Š <b>ê²½ë¡œë³„ ìŠ¹ë¥  ë¦¬í¬íŠ¸</b> (ìµœê·¼ {total}ê±´)",
            f"ğŸ“ˆ ì „ì²´ ìŠ¹ë¥ : {overall_wr:.1f}% ({wins}ìŠ¹/{total-wins}íŒ¨)",
            "â”€" * 20,
        ]

        # ğŸ”¥ ì§„ì… ê²½ë¡œë³„ ìŠ¹ë¥  (signal_tag ê¸°ì¤€)
        if "signal_tag" in df.columns:
            lines.append("<b>ğŸ“ ì§„ì… ê²½ë¡œ:</b>")
            tag_stats = {}
            for _, row in df.iterrows():
                tag = str(row.get("signal_tag", "ê¸°ë³¸"))
                if tag not in tag_stats:
                    tag_stats[tag] = {"win": 0, "total": 0}
                tag_stats[tag]["total"] += 1
                if row["result"] == "win":
                    tag_stats[tag]["win"] += 1

            # ìŠ¹ë¥  ìˆœ ì •ë ¬
            sorted_tags = sorted(tag_stats.items(),
                                 key=lambda x: (x[1]["win"]/max(x[1]["total"],1), x[1]["total"]),
                                 reverse=True)
            for tag, stats in sorted_tags:
                cnt = stats["total"]
                w = stats["win"]
                wr = w / cnt * 100 if cnt > 0 else 0
                star = " âœ…" if wr >= overall_wr + 10 else (" âš ï¸" if wr <= overall_wr - 10 else "")
                lines.append(f"  {tag}: {cnt}ê±´ ({wr:.0f}%){star}")

            # ì¶”ì²œ: ê°€ì¥ ë‚˜ìœ ê²½ë¡œ ì°¾ê¸°
            lines.append("â”€" * 20)
            worst = None
            worst_wr = 100
            for tag, stats in sorted_tags:
                cnt = stats["total"]
                if cnt >= 3:
                    wr = stats["win"] / cnt * 100
                    if wr < worst_wr:
                        worst_wr = wr
                        worst = tag

            if worst and worst_wr < overall_wr - 5:
                lines.append(f"ğŸ’¡ ê²€í†  í•„ìš”: {worst} ({worst_wr:.0f}%)")
            else:
                lines.append("ğŸ’¡ íŠ¹ë³„íˆ ë‚˜ìœ ê²½ë¡œ ì—†ìŒ")

        return "\n".join(lines)

    except Exception as e:
        return f"ğŸ“Š í†µê³„ ì˜¤ë¥˜: {e}"

def get_recent_trades_detail(last_n: int = 10) -> str:
    """
    ğŸ” ìµœê·¼ ê±°ë˜ ìƒì„¸ ëª©ë¡ (ì„ê³„ì¹˜ ë¶„ì„ìš©)
    """
    if not os.path.exists(TRADE_LOG_PATH):
        return ""

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        if "result" not in df.columns:
            return ""

        # ì²­ì‚° ì™„ë£Œëœ ê±°ë˜ë§Œ
        df = df[df["result"].isin(["win", "lose"])].tail(last_n)

        if len(df) == 0:
            return ""

        lines = [
            "",
            f"ğŸ“‹ <b>ìµœê·¼ {len(df)}ê±´ ìƒì„¸</b>",
            "â”€" * 20,
        ]

        for idx, row in df.iterrows():
            # ê¸°ë³¸ ì •ë³´
            market = str(row.get("market", "?"))[-6:]  # KRW-XXXì—ì„œ XXXë§Œ
            result = row.get("result", "?")
            pnl_raw = row.get("pnl_pct", 0) or 0
            pnl = float(pnl_raw) * 100  # ğŸ”§ FIX: ì†Œìˆ˜ â†’ í¼ì„¼íŠ¸ í™˜ì‚°
            icon = "âœ…" if result == "win" else "âŒ"
            pnl_str = f"+{pnl:.2f}%" if pnl > 0 else f"{pnl:.2f}%"

            # ê²½ë¡œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
            signal_tag = str(row.get("signal_tag", "ê¸°ë³¸"))

            # ì§€í‘œë“¤ (ì†Œìˆ˜ì  ì •ë¦¬)
            buy_r = row.get("buy_ratio", 0) or 0
            turn = row.get("turn", 0) or 0
            imbal = row.get("imbalance", 0) or 0
            spread = row.get("spread", 0) or 0
            vol_surge = row.get("volume_surge", 0) or 0
            score = row.get("score", 0) or 0
            hold = row.get("hold_sec", 0) or 0

            # ğŸ”¥ ìƒˆ ì§€í‘œ
            cons_buys = row.get("consecutive_buys", 0) or 0
            avg_krw = row.get("avg_krw_per_tick", 0) or 0
            flow_accel = row.get("flow_acceleration", 1.0) or 1.0

            # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
            overheat = row.get("overheat", 0) or 0
            fresh_age = row.get("fresh_age", 0) or 0

            # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
            cv = row.get("cv", 0) or 0
            pstd = row.get("pstd", 0) or 0
            best_ask_krw = row.get("best_ask_krw", 0) or 0
            is_prebreak = row.get("is_prebreak", 0) or 0

            # ì‹œê°„ (tsì—ì„œ ì‹œ:ë¶„ë§Œ ì¶”ì¶œ)
            ts = str(row.get("ts", ""))
            time_str = ts[11:16] if len(ts) >= 16 else "?"

            # ê°€ì†ë„ ì´ëª¨ì§€
            accel_emoji = "ğŸš€" if flow_accel >= 1.5 else ("ğŸ“‰" if flow_accel <= 0.7 else "")

            # CV ì´ëª¨ì§€
            cv_emoji = "ğŸ¤–" if cv <= 0.45 else ("ğŸ”¥" if cv >= 1.2 else "")
            # Pre-break ë§ˆí¬
            pb_mark = "âš¡PB" if is_prebreak else ""

            # ğŸ” ì§„ì…ëª¨ë“œ + ì¶”ë§¤ + ì²­ì‚°ì‚¬ìœ 
            entry_mode = str(row.get("entry_mode", "confirm"))
            added_val = str(row.get("added", "0"))
            was_added = added_val == "1"
            exit_reason = str(row.get("exit_reason", "")).strip() or "ë¯¸ê¸°ë¡"

            # ì§„ì…ëª¨ë“œ ì´ëª¨ì§€ (probe+ì¶”ë§¤ = ìŠ¹ê²©)
            if entry_mode == "probe" and was_added:
                mode_str = "ğŸ”¬â†’âœ…ìŠ¹ê²©"  # probeì—ì„œ ì¶”ë§¤ë¡œ confirm ìŠ¹ê²©
            elif entry_mode == "probe":
                mode_str = "ğŸ”¬íƒìƒ‰"  # probe ì§„ì…, ì¶”ë§¤ ì—†ì´ ì²­ì‚°
            else:
                mode_str = "âœ…í™•ì •"  # ì²˜ìŒë¶€í„° confirm ì§„ì…

            lines.append(
                f"{icon} {market} {time_str} {pnl_str} {pb_mark}\n"
                f"   {mode_str} ê²½ë¡œ:{signal_tag}\n"
                f"   â¹ì²­ì‚°:{exit_reason}\n"
                f"   ë§¤ìˆ˜{buy_r:.0%} íšŒì „{turn:.1%} ì„ë°¸{imbal:.2f} ìŠ¤í”„{spread:.2f}%\n"
                f"   ë°°ìˆ˜{vol_surge:.1f}x ì—°ì†{cons_buys:.0f} ê°€ì†{flow_accel:.1f}x{accel_emoji}\n"
                f"   ğŸ“ˆCV{cv:.2f}{cv_emoji} pstd{pstd:.2f}%"
            )

        # ì„ê³„ì¹˜ íŒíŠ¸ (ìŠ¹ë¦¬/íŒ¨ë°° í‰ê·  ë¹„êµ)
        wins = df[df["result"] == "win"]
        loses = df[df["result"] == "lose"]

        if len(wins) >= 2 and len(loses) >= 2:
            lines.append("â”€" * 20)
            lines.append("<b>ğŸ’¡ ìŠ¹/íŒ¨ í‰ê·  ë¹„êµ:</b>")

            for col, name in [("buy_ratio", "ë§¤ìˆ˜ë¹„"), ("turn", "íšŒì „"), ("imbalance", "ì„ë°¸"),
                              ("spread", "ìŠ¤í”„ë ˆë“œ"), ("volume_surge", "ë°°ìˆ˜"),
                              ("consecutive_buys", "ì—°ì†ë§¤ìˆ˜"), ("flow_acceleration", "ê°€ì†ë„"),
                              ("overheat", "ê³¼ì—´"), ("fresh_age", "í‹±ë‚˜ì´"),
                              ("cv", "CV"), ("pstd", "pstd")]:
                if col in df.columns:
                    w_avg = wins[col].mean() if col in wins.columns else 0
                    l_avg = loses[col].mean() if col in loses.columns else 0
                    if pd.notna(w_avg) and pd.notna(l_avg):
                        diff = w_avg - l_avg
                        if col == "buy_ratio":
                            lines.append(f"  {name}: ìŠ¹{w_avg:.0%} / íŒ¨{l_avg:.0%} (ì°¨ì´ {diff:+.0%})")
                        elif col == "turn":
                            lines.append(f"  {name}: ìŠ¹{w_avg:.1%} / íŒ¨{l_avg:.1%} (ì°¨ì´ {diff:+.1%})")
                        elif col == "spread":
                            # spreadëŠ” ì´ë¯¸ % ë‹¨ìœ„ë¡œ ì €ì¥ë¨ (0.15 = 0.15%)
                            lines.append(f"  {name}: ìŠ¹{w_avg:.2f}% / íŒ¨{l_avg:.2f}% (ì°¨ì´ {diff:+.2f}%)")
                        else:
                            lines.append(f"  {name}: ìŠ¹{w_avg:.2f} / íŒ¨{l_avg:.2f} (ì°¨ì´ {diff:+.2f})")

        return "\n".join(lines)

    except Exception as e:
        return f"ğŸ“‹ ìƒì„¸ ì˜¤ë¥˜: {e}"

def analyze_and_update_weights():
    """
    ğŸ”¥ 1ë‹¨ê³„ ê²Œì´íŠ¸ ì„ê³„ì¹˜ ìë™ ì¡°ì ˆ
    - ìŠ¹ë¦¬/íŒ¨ë°° ê·¸ë£¹ ê°„ í”¼ì²˜ ë¶„í¬ ë¶„ì„
    - GATE_* ì „ì—­ ë³€ìˆ˜ ì¡°ì ˆ
    """
    global GATE_TURN_MIN, GATE_TURN_MAX, GATE_SPREAD_MAX
    global GATE_ACCEL_MIN, GATE_ACCEL_MAX, GATE_BUY_RATIO_MIN
    global GATE_SURGE_MAX, GATE_IMBALANCE_MIN, GATE_OVERHEAT_MAX, GATE_FRESH_AGE_MAX
    global GATE_VOL_MIN, GATE_SURGE_MIN, GATE_PRICE_MIN

    if not os.path.exists(TRADE_LOG_PATH):
        print("[AUTO_LEARN] ê±°ë˜ ë¡œê·¸ ì—†ìŒ")
        return None

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        # ê²°ê³¼ê°€ ìˆëŠ” ê²ƒë§Œ
        df = df[df["result"].isin(["win", "lose"])]

        if len(df) < AUTO_LEARN_MIN_TRADES:
            print(f"[AUTO_LEARN] ë°ì´í„° ë¶€ì¡± ({len(df)}/{AUTO_LEARN_MIN_TRADES})")
            return None

        wins = df[df["result"] == "win"]
        loses = df[df["result"] == "lose"]

        if len(wins) < 5 or len(loses) < 5:
            print(f"[AUTO_LEARN] ìŠ¹/íŒ¨ ìƒ˜í”Œ ë¶€ì¡± (ìŠ¹:{len(wins)}, íŒ¨:{len(loses)})")
            return None

        win_rate = round(len(wins) / len(df) * 100, 1)

        # ìŠ¹/íŒ¨ í‰ê·  ê³„ì‚°
        stats = {}
        for col in ["buy_ratio", "spread", "turn", "imbalance", "volume_surge", "flow_acceleration", "overheat", "fresh_age"]:
            try:
                w_avg = pd.to_numeric(wins[col], errors='coerce').mean()
                l_avg = pd.to_numeric(loses[col], errors='coerce').mean()
                stats[col] = {"win": w_avg, "lose": l_avg}
            except:
                pass

        # ì¡°ì ˆ ë¡œì§ (10% ë¸”ë Œë”©, í•˜ë“œë°”ìš´ë“œ ì ìš©)
        BLEND = 0.10
        old_values = {
            "GATE_BUY_RATIO_MIN": GATE_BUY_RATIO_MIN,
            "GATE_SPREAD_MAX": GATE_SPREAD_MAX,
            "GATE_TURN_MIN": GATE_TURN_MIN,
            "GATE_IMBALANCE_MIN": GATE_IMBALANCE_MIN,
            "GATE_SURGE_MAX": GATE_SURGE_MAX,
            "GATE_ACCEL_MIN": GATE_ACCEL_MIN,
            "GATE_OVERHEAT_MAX": GATE_OVERHEAT_MAX,
            "GATE_FRESH_AGE_MAX": GATE_FRESH_AGE_MAX,
        }
        changes = {}

        # ğŸ”§ ê·¸ë¦¼ì ëª¨ë“œ: ë³€ê²½ê°’ ê³„ì‚°ì€ í•˜ë˜, AUTO_LEARN_APPLY=Trueì¼ ë•Œë§Œ ì‹¤ì œ ì ìš©
        # ë§¤ìˆ˜ë¹„: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥ (ë” ì—„ê²©)
        if "buy_ratio" in stats:
            w, l = stats["buy_ratio"]["win"], stats["buy_ratio"]["lose"]
            if w > l:  # ìŠ¹ìê°€ ë” ë†’ì€ ë§¤ìˆ˜ë¹„
                target = min(0.80, w * 0.95)  # ìŠ¹ì í‰ê· ì˜ 95%
                new_val = round(GATE_BUY_RATIO_MIN * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.55, min(0.80, new_val))  # ë°”ìš´ë“œ
                changes["GATE_BUY_RATIO_MIN"] = round(new_val - GATE_BUY_RATIO_MIN, 3)
                if AUTO_LEARN_APPLY:
                    GATE_BUY_RATIO_MIN = new_val

        # ìŠ¤í”„ë ˆë“œ: ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "spread" in stats:
            w, l = stats["spread"]["win"], stats["spread"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë” ë‚®ì€ ìŠ¤í”„ë ˆë“œ
                target = max(0.08, w * 1.2)  # ìŠ¹ì í‰ê· ì˜ 120%
                new_val = round(GATE_SPREAD_MAX * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.08, min(0.35, new_val))  # ë°”ìš´ë“œ
                changes["GATE_SPREAD_MAX"] = round(new_val - GATE_SPREAD_MAX, 3)
                if AUTO_LEARN_APPLY:
                    GATE_SPREAD_MAX = new_val

        # íšŒì „ìœ¨: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "turn" in stats:
            w, l = stats["turn"]["win"], stats["turn"]["lose"]
            if w > l:
                target = max(1.0, w * 0.8)
                new_val = round(GATE_TURN_MIN * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.0, min(10.0, new_val))
                changes["GATE_TURN_MIN"] = round(new_val - GATE_TURN_MIN, 2)
                if AUTO_LEARN_APPLY:
                    GATE_TURN_MIN = new_val

        # ì„ë°¸ëŸ°ìŠ¤: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "imbalance" in stats:
            w, l = stats["imbalance"]["win"], stats["imbalance"]["lose"]
            if w > l:
                target = max(0.20, w * 0.9)
                new_val = round(GATE_IMBALANCE_MIN * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.15, min(0.50, new_val))
                changes["GATE_IMBALANCE_MIN"] = round(new_val - GATE_IMBALANCE_MIN, 3)
                if AUTO_LEARN_APPLY:
                    GATE_IMBALANCE_MIN = new_val

        # ê¸‰ë“±: ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "volume_surge" in stats:
            w, l = stats["volume_surge"]["win"], stats["volume_surge"]["lose"]
            if w < l:
                target = max(1.5, w * 1.3)
                new_val = round(GATE_SURGE_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.5, min(6.0, new_val))
                changes["GATE_SURGE_MAX"] = round(new_val - GATE_SURGE_MAX, 2)
                if AUTO_LEARN_APPLY:
                    GATE_SURGE_MAX = new_val

        # ê°€ì†ë„: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "flow_acceleration" in stats:
            w, l = stats["flow_acceleration"]["win"], stats["flow_acceleration"]["lose"]
            if w > l:
                target = max(0.3, w * 0.7)
                new_val = round(GATE_ACCEL_MIN * (1 - BLEND) + target * BLEND, 2)
                new_val = max(0.3, min(1.5, new_val))
                changes["GATE_ACCEL_MIN"] = round(new_val - GATE_ACCEL_MIN, 2)
                if AUTO_LEARN_APPLY:
                    GATE_ACCEL_MIN = new_val

        # ê³¼ì—´(overheat): ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "overheat" in stats:
            w, l = stats["overheat"]["win"], stats["overheat"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë‚®ì€ ê³¼ì—´
                target = max(2.0, w * 1.3)  # ìŠ¹ì í‰ê· ì˜ 130%
                new_val = round(GATE_OVERHEAT_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(2.0, min(8.0, new_val))  # ë°”ìš´ë“œ
                changes["GATE_OVERHEAT_MAX"] = round(new_val - GATE_OVERHEAT_MAX, 2)
                if AUTO_LEARN_APPLY:
                    GATE_OVERHEAT_MAX = new_val

        # í‹±ë‚˜ì´(fresh_age): ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "fresh_age" in stats:
            w, l = stats["fresh_age"]["win"], stats["fresh_age"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë‚®ì€ í‹±ë‚˜ì´ (ë” ì‹ ì„ )
                target = max(1.0, w * 1.5)  # ìŠ¹ì í‰ê· ì˜ 150%
                new_val = round(GATE_FRESH_AGE_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.0, min(6.0, new_val))  # ë°”ìš´ë“œ
                changes["GATE_FRESH_AGE_MAX"] = round(new_val - GATE_FRESH_AGE_MAX, 2)
                if AUTO_LEARN_APPLY:
                    GATE_FRESH_AGE_MAX = new_val

        new_values = {
            "GATE_BUY_RATIO_MIN": GATE_BUY_RATIO_MIN,
            "GATE_SPREAD_MAX": GATE_SPREAD_MAX,
            "GATE_TURN_MIN": GATE_TURN_MIN,
            "GATE_IMBALANCE_MIN": GATE_IMBALANCE_MIN,
            "GATE_SURGE_MAX": GATE_SURGE_MAX,
            "GATE_ACCEL_MIN": GATE_ACCEL_MIN,
            "GATE_OVERHEAT_MAX": GATE_OVERHEAT_MAX,
            "GATE_FRESH_AGE_MAX": GATE_FRESH_AGE_MAX,
            "GATE_VOL_MIN": GATE_VOL_MIN,
            "GATE_SURGE_MIN": GATE_SURGE_MIN,
            "GATE_PRICE_MIN": GATE_PRICE_MIN,
        }

        # ì €ì¥
        with open(WEIGHTS_PATH, "w", encoding="utf-8") as f:
            json.dump({
                "gate_thresholds": new_values,
                "updated_at": now_kst_str(),
                "sample_size": len(df),
                "win_rate": win_rate,
                "feature_stats": {k: {"win": round(v["win"], 3), "lose": round(v["lose"], 3)} for k, v in stats.items()}
            }, f, ensure_ascii=False, indent=2)

        print(f"[AUTO_LEARN] ê²Œì´íŠ¸ ì„ê³„ì¹˜ ì—…ë°ì´íŠ¸: {new_values}")
        print(f"[AUTO_LEARN] ìŠ¹ë¥ : {len(wins)}/{len(df)} = {win_rate}%")

        return {
            "thresholds": new_values,
            "old_values": old_values,
            "changes": changes,
            "win_rate": win_rate,
            "wins": len(wins),
            "loses": len(loses),
            "sample_size": len(df)
        }

    except ImportError:
        print("[AUTO_LEARN] pandas ë¯¸ì„¤ì¹˜ - ìˆ˜ë™ ë¶„ì„ í•„ìš”")
        return None
    except Exception as e:
        print(f"[AUTO_LEARN_ERR] {e}")
        import traceback
        traceback.print_exc()
        return None

# =========================
# ğŸ§  ë§¤ë„ íŒŒë¼ë¯¸í„° ìë™ íŠœë‹
# =========================
EXIT_PARAMS_PATH = os.path.join(os.getcwd(), "learned_exit_params.json")

# ğŸ”§ hard_stop ì œê±° â†’ ë™ì ì†ì ˆ(ATR)ë¡œ ëŒ€ì²´ (DYN_SL_MIN~DYN_SL_MAX)
DYNAMIC_EXIT_PARAMS = {}

# ë¶€ë¶„ì²­ì‚° í›„ ì¶”ê°€ ì†ì ˆ ì„¤ì •
PARTIAL_EXIT_PROFIT_DROP = 0.002   # ìµì ˆ ë¶€ë¶„ì²­ì‚° í›„ -0.2% ì¶”ê°€ í•˜ë½ ì‹œ ì²­ì‚°
PARTIAL_EXIT_LOSS_DROP = 0.001     # ì†ì ˆ ë¶€ë¶„ì²­ì‚° í›„ -0.1% ì¶”ê°€ í•˜ë½ ì‹œ ì²­ì‚°

# ğŸ”§ [í†µí•©ë¨] ì–‡ì€ìˆ˜ìµ/íŠ¸ë ˆì¼ë§/Plateau â†’ PROFIT_CHECKPOINT (ìƒë‹¨ ì •ì˜)
# THIN_PROFIT_CHECKPOINT, STRONG_TRAIL_DROP ì œê±°ë¨

# ğŸ”§ ì†Œí”„íŠ¸ ë³¸ì ˆ ê°€ë“œ (íœ©ì˜ ë°©ì§€)
BREAKEVEN_BOX = 0.0015           # Â±0.15% ë°•ìŠ¤ ë‚´ì—ì„œëŠ” ë³¸ì ˆ ì²­ì‚° ì–µì œ
SOFT_GUARD_SEC = 30              # ì´ˆê¸° 30ì´ˆê°„ ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ì¡°ê±´ ê°•í™”

def is_strong_momentum(ticks, ob):
    """
    ì²´í¬í¬ì¸íŠ¸ ë„ë‹¬ ì‹œì ì— ê°•ì„¸ ì—¬ë¶€ íŒë‹¨ (ì ìˆ˜ ê¸°ë°˜)
    - ì•½ì„¸ ì ìˆ˜ 2ì  ì´ìƒì´ë©´ ì•½ì„¸ â†’ ì¦‰ì‹œ ë§¤ë„
    - ì•½ì„¸ ì ìˆ˜ 1ì  ì´í•˜ë©´ ê°•ì„¸ â†’ í™€ë”© (íŠ¸ë ˆì¼ë§ ëª¨ë“œ)
    """
    try:
        t15 = micro_tape_stats_from_ticks(ticks or [], 15)
        imb = calc_orderbook_imbalance(ob) if ob else 0.0
        fresh = uptick_streak_from_ticks(ticks, need=2) if ticks else False

        # ì•½ì„¸ ì ìˆ˜ ê³„ì‚° (0~4ì )
        weak_score = 0

        # 1) ë§¤ìˆ˜ë¹„ ë‚®ìŒ
        if t15["buy_ratio"] < 0.55:
            weak_score += 1

        # 2) ê±°ë˜ì†ë„ ë‘”í™”
        if t15["krw_per_sec"] < 15000:
            weak_score += 1

        # 3) í˜¸ê°€ ë§¤ë„ìš°ì„¸ (imbalance < -0.1)
        if imb < -0.1:
            weak_score += 1

        # 4) ìƒìŠ¹í‹± ëŠê¹€
        if not fresh:
            weak_score += 1

        # ì•½ì„¸ ì ìˆ˜ 3ì  ì´ìƒì´ë©´ ì•½ì„¸ íŒì • â†’ False ë°˜í™˜ (ğŸ”§ 2â†’3 ê°•í™”: í™•ì‹¤í•œ ì•½ì„¸ë§Œ ìŠ¤ìº˜í•‘)
        return weak_score < 3
    except:
        return False

def load_exit_params():
    """ì €ì¥ëœ ë§¤ë„ íŒŒë¼ë¯¸í„° ë¡œë“œ"""
    global DYNAMIC_EXIT_PARAMS
    if os.path.exists(EXIT_PARAMS_PATH):
        try:
            with open(EXIT_PARAMS_PATH, "r", encoding="utf-8") as f:
                data = json.load(f)
            if "params" in data:
                DYNAMIC_EXIT_PARAMS.update(data["params"])
                print(f"[EXIT_PARAMS] ë¡œë“œ ì™„ë£Œ: ìŠ¹ë¥  {data.get('win_rate')}%, í‰ê· ì†ìµ {data.get('avg_pnl')}%")
        except Exception as e:
            print(f"[EXIT_PARAMS_LOAD_ERR] {e}")

def load_learned_weights():
    """
    ì €ì¥ëœ í•™ìŠµ íŒŒì¼ ë¡œë“œ
    - ê³¼ê±° ë²„ì „ í˜¸í™˜: "weights"ê°€ ìˆìœ¼ë©´ SCORE_WEIGHTS ì—…ë°ì´íŠ¸
    - í˜„í–‰: "gate_thresholds"ê°€ ìˆìœ¼ë©´ GATE_* ì„ê³„ì¹˜ ë³µì›
    """
    global SCORE_WEIGHTS
    global GATE_TURN_MIN, GATE_TURN_MAX, GATE_SPREAD_MAX
    global GATE_ACCEL_MIN, GATE_ACCEL_MAX, GATE_BUY_RATIO_MIN
    global GATE_SURGE_MAX, GATE_OVERHEAT_MAX, GATE_IMBALANCE_MIN, GATE_FRESH_AGE_MAX
    global GATE_VOL_MIN, GATE_SURGE_MIN, GATE_PRICE_MIN

    if not os.path.exists(WEIGHTS_PATH):
        print("[WEIGHTS] í•™ìŠµëœ íŒŒì¼ ì—†ìŒ - ê¸°ë³¸ê°’ ì‚¬ìš©")
        return

    try:
        with open(WEIGHTS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)

        # (êµ¬ë²„ì „ í˜¸í™˜) ìŠ¤ì½”ì–´ ê°€ì¤‘ì¹˜ê°€ ì €ì¥ë¼ ìˆìœ¼ë©´ ê°±ì‹ 
        if isinstance(data.get("weights"), dict):
            SCORE_WEIGHTS.update(data["weights"])
            print(f"[WEIGHTS] í•™ìŠµëœ ê°€ì¤‘ì¹˜ ë¡œë“œ: {SCORE_WEIGHTS}")

        # (í˜„í–‰) ê²Œì´íŠ¸ ì„ê³„ì¹˜ ë³µì›
        thr = data.get("gate_thresholds")
        if isinstance(thr, dict):
            GATE_TURN_MIN      = thr.get("GATE_TURN_MIN",      GATE_TURN_MIN)
            GATE_TURN_MAX      = thr.get("GATE_TURN_MAX",      GATE_TURN_MAX)
            GATE_SPREAD_MAX    = thr.get("GATE_SPREAD_MAX",    GATE_SPREAD_MAX)
            GATE_ACCEL_MIN     = thr.get("GATE_ACCEL_MIN",     GATE_ACCEL_MIN)
            GATE_ACCEL_MAX     = thr.get("GATE_ACCEL_MAX",     GATE_ACCEL_MAX)
            GATE_BUY_RATIO_MIN = thr.get("GATE_BUY_RATIO_MIN", GATE_BUY_RATIO_MIN)
            GATE_SURGE_MAX     = thr.get("GATE_SURGE_MAX",     GATE_SURGE_MAX)
            GATE_OVERHEAT_MAX  = thr.get("GATE_OVERHEAT_MAX",  GATE_OVERHEAT_MAX)
            GATE_IMBALANCE_MIN = thr.get("GATE_IMBALANCE_MIN", GATE_IMBALANCE_MIN)
            # ğŸ”§ ì•„ë˜ 4ê°œëŠ” ì½”ë“œ ê°’ ìš°ì„  ì‚¬ìš© (ì €ì¥ëœ íŒŒì¼ì—ì„œ ë¡œë“œ ì•ˆ í•¨)
            # GATE_FRESH_AGE_MAX = thr.get("GATE_FRESH_AGE_MAX", GATE_FRESH_AGE_MAX)
            # GATE_VOL_MIN       = thr.get("GATE_VOL_MIN",       GATE_VOL_MIN)
            # GATE_SURGE_MIN     = thr.get("GATE_SURGE_MIN",     GATE_SURGE_MIN)
            # GATE_PRICE_MIN     = thr.get("GATE_PRICE_MIN",     GATE_PRICE_MIN)
            print(f"[WEIGHTS] ê²Œì´íŠ¸ ì„ê³„ì¹˜ ë¡œë“œ (VOL/PRICEëŠ” ì½”ë“œê°’ ìš°ì„ ): {thr}")

        print(f"[WEIGHTS] ì—…ë°ì´íŠ¸: {data.get('updated_at', '?')}, ìƒ˜í”Œ: {data.get('sample_size', '?')}, ìŠ¹ë¥ : {data.get('win_rate', '?')}%")
    except Exception as e:
        print(f"[WEIGHTS_LOAD_ERR] {e}")

# =========================
# ì„¸ì…˜/ìš”ì²­(ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”)
# =========================
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter


def _new_session():
    s = requests.Session()
    # ğŸ”§ urllib3 ë²„ì „ í˜¸í™˜ì„± (1.26+ = allowed_methods, êµ¬ë²„ì „ = method_whitelist)
    # ğŸ”§ FIX: POSTëŠ” ìë™ì¬ì‹œë„ ì œì™¸ (ì¤‘ë³µ ì£¼ë¬¸ ë°©ì§€)
    retry_kwargs = dict(
        total=3,
        backoff_factor=0.3,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    try:
        retry = Retry(allowed_methods=frozenset(["GET"]), **retry_kwargs)  # POST ì œê±°
    except TypeError:
        # urllib3 < 1.26 fallback
        retry = Retry(method_whitelist=frozenset(["GET"]), **retry_kwargs)  # POST ì œê±°
    adapter = HTTPAdapter(pool_connections=256,
                          pool_maxsize=256,
                          max_retries=retry)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({
        "Connection": "keep-alive",
        "User-Agent": "UpbitSniper/3.2.7-hh+...+netRetry"
    })
    return s


SESSION = _new_session()
KST = timezone(timedelta(hours=9))

def now_kst():
    return datetime.now(KST)

def now_kst_str():
    return now_kst().strftime("%Y-%m-%d %H:%M:%S KST")

# =========================
# ğŸ”¥ ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ê°„ê²©
# =========================
def get_scan_interval():
    """
    ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ì£¼ê¸°(ì´ˆ)
    - 09ì‹œëŒ€: 3ì´ˆ (ì´ˆë™ ë³€ë™ì„± ëŒ€ì‘)
    - 10~14ì‹œ: 5ì´ˆ
    - ê·¸ ì™¸: ê¸°ë³¸ 6ì´ˆ
    """
    h = now_kst().hour
    if h == 9:
        return 3
    elif 10 <= h <= 14:
        return 5
    else:
        return SCAN_INTERVAL  # ê¸°ë³¸ê°’(6ì´ˆ)

def link_for(m):
    return f"https://upbit.com/exchange?code=CRIX.UPBIT.{m}"


# í† í°ë²„í‚·
_BUCKET = {"tokens": 6.0, "last": time.time(), "cap": 6.0, "rate": 4.5}
_req_lock = threading.Lock()
REQ_STATS = {"ok": 0, "http429": 0, "http5xx": 0, "errors": 0, "conn_err": 0}
_CONSEC_CONN_ERR = 0


def _throttle():
    while True:
        with _req_lock:
            now = time.time()
            delta = now - _BUCKET["last"]
            _BUCKET["last"] = now
            rate = max(float(_BUCKET.get("rate", 0.0)), 0.1)
            cap = max(float(_BUCKET.get("cap", 1.0)), 1.0)
            tokens = min(cap, max(0.0, _BUCKET["tokens"] + delta * rate))
            if tokens >= 1.0:
                _BUCKET["tokens"] = tokens - 1.0
                return
            _BUCKET["tokens"] = tokens
            need = 1.0 - tokens
        base_wait = need / rate
        time.sleep(min(1.2, max(0.05, base_wait)) * (1.0 + 0.2 * rnd()))


def _refresh_session():
    global SESSION, _CONSEC_CONN_ERR
    try:
        SESSION.close()
    except Exception:
        pass
    SESSION = _new_session()
    _CONSEC_CONN_ERR = 0
    print("[NET] session refreshed")


def upbit_get(url, params=None, timeout=7):
    global _CONSEC_CONN_ERR
    for attempt in range(3):  # 4 -> 3 ìœ ì§€
        try:
            _throttle()
            r = SESSION.get(url, params=params, timeout=timeout)
            if r.status_code == 429:
                REQ_STATS["http429"] += 1
                # ì§€ìˆ˜ì  ë°±ì˜¤í”„ + ë²„í‚· ì†ë„ í•˜í–¥(ë³´ë‹¤ ê³µê²©ì ìœ¼ë¡œ)
                backoff = min(1.2 * (2**attempt), 6.0)
                time.sleep(backoff)
                # â†“ rateë¥¼ ë” ê°•í•˜ê²Œ ì¤„ì´ê³ , capë„ ì ê¹ ì¤„ì—¬ í­ì£¼ ì–µì œ
                _BUCKET["rate"] = max(3.0, _BUCKET["rate"] - 0.4)
                _BUCKET["cap"] = max(4.0, _BUCKET["cap"] - 0.5)
                continue
            if 500 <= r.status_code < 600:
                REQ_STATS["http5xx"] += 1
                time.sleep(0.35 * (2**attempt))
                continue
            r.raise_for_status()
            REQ_STATS["ok"] += 1
            _CONSEC_CONN_ERR = 0
            # âœ… 429 í›„ ì ì§„ íšŒë³µ (ì¥ê¸° ì„±ëŠ¥ ì €í•˜ ë°©ì§€)
            _BUCKET["rate"] = min(4.5, float(_BUCKET.get("rate", 3.0)) + 0.10)
            _BUCKET["cap"]  = min(6.0, float(_BUCKET.get("cap", 4.0)) + 0.10)
            return r.json()
        except requests.exceptions.Timeout:
            if attempt == 2: return None
            time.sleep(0.35 * (2**attempt))
        except requests.exceptions.ConnectionError:
            REQ_STATS["errors"] += 1
            REQ_STATS["conn_err"] += 1
            _CONSEC_CONN_ERR += 1
            if _CONSEC_CONN_ERR >= 3:
                _refresh_session()
                time.sleep(0.6)
            else:
                time.sleep(0.4 * (2**attempt))
            if attempt == 2: return None
        except Exception:
            REQ_STATS["errors"] += 1
            if attempt == 2: return None
            time.sleep(0.2 * (2**attempt))
    return None

# =========================================================
# ğŸ§© ì•ˆì „ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ë˜í¼ (ìë™ ì¬ì‹œë„ + ë°±ì˜¤í”„)
# =========================================================
def safe_upbit_get(url, params=None, timeout=6, retries=3, backoff=1.5):
    """
    ì—…ë¹„íŠ¸ API ìš”ì²­ìš© ì•ˆì „ ë˜í¼
    - ì¼ì‹œì  ì—°ê²° ì‹¤íŒ¨ë‚˜ 429 ì‘ë‹µì—ë„ ìë™ ì¬ì‹œë„
    - 3íšŒê¹Œì§€ ì¬ì‹œë„ (1.5ì´ˆì”© ì¦ê°€í•˜ëŠ” ëŒ€ê¸°)
    """
    for i in range(retries):
        try:
            js = upbit_get(url, params, timeout=timeout)
            if js:
                return js
        except Exception as e:
            print(f"[SAFE_GET] {url.split('/')[-1]} ì‹¤íŒ¨ ({e}) â†’ ì¬ì‹œë„ {i+1}/{retries}")
        time.sleep(backoff * (i + 1))
    print(f"[SAFE_GET_FAIL] {url.split('/')[-1]} ìµœì¢… ì‹¤íŒ¨")
    return None

def req_summary():
    print(
        f"[REQ] ok:{REQ_STATS['ok']}  429:{REQ_STATS['http429']}  5xx:{REQ_STATS['http5xx']}  err:{REQ_STATS['errors']}"
    )


def aligned_sleep(interval):
    t = time.time()
    nxt = math.ceil(t / interval) * interval
    time.sleep(max(0, nxt - t))


# =========================
# ì§€í‘œ ìœ í‹¸
# =========================
def vwap_from_candles_1m(c1, n=20):
    seg = c1[-n:] if len(c1) >= n else c1[:]
    pv = sum(x["trade_price"] * x["candle_acc_trade_volume"] for x in seg)
    vol = sum(x["candle_acc_trade_volume"] for x in seg)
    return pv / max(vol, 1e-12)


def zscore_krw_1m(c1, win=30):
    seg = c1[-win:] if len(c1) >= win else c1[:]
    arr = [x["candle_acc_trade_price"] for x in seg]
    if len(arr) < 3: return 0.0
    m = sum(arr) / len(arr)
    sd = (sum((a - m)**2 for a in arr) / max(len(arr) - 1, 1))**0.5
    return (arr[-1] - m) / max(sd, 1e-9)


def uptick_streak_from_ticks(ticks, need=2):
    t = sorted(ticks[:need + 4], key=lambda x: x.get("timestamp", 0))
    return sum(1 for a, b in zip(t, t[1:])
               if b.get("trade_price", 0) > a.get("trade_price", 0)) >= need


def last_two_ticks_fresh(ticks, max_age=None, return_age=False):
    """
    í‹± ì‹ ì„ ë„ ì²´í¬ - GATE_FRESH_AGE_MAX ì „ì—­ ë³€ìˆ˜ ì‚¬ìš©

    return_age=True: (bool, max_tick_age, effective_max_age) ë°˜í™˜
    return_age=False: boolë§Œ ë°˜í™˜ (ê¸°ì¡´ í˜¸í™˜)
    """
    if max_age is None:
        max_age = GATE_FRESH_AGE_MAX
    if len(ticks) < 2:
        if return_age:
            return False, 999.0, max_age
        return False
    # ğŸ”§ ì‹œê°„ëŒ€ë³„ ì‹ ì„ ë„ ë™ì  ì™„í™” (ì¥ì¤‘ ì—„ê²©, ì•¼ê°„ ì™„í™”)
    h = now_kst().hour
    if 0 <= h < 6:
        max_age = max(max_age, 5.0)   # ì•¼ê°„: ìµœì†Œ 5ì´ˆ
    elif 6 <= h < 9:
        max_age = max(max_age, 4.0)   # ìƒˆë²½~ì¥ì „: ìµœì†Œ 4ì´ˆ
    # 9~24ì‹œ(ì¥ì¤‘): GATE_FRESH_AGE_MAX ê·¸ëŒ€ë¡œ (3ì´ˆ)
    now = int(time.time() * 1000)
    # ìµœê·¼ 2í‹± ì¤‘ ê°€ì¥ ì˜¤ë˜ëœ í‹±ì˜ ë‚˜ì´ ê³„ì‚°
    tick_ages = [(now - x.get("timestamp", 0)) / 1000.0 for x in ticks[:2]]
    max_tick_age = max(tick_ages) if tick_ages else 999.0
    is_fresh = all(age <= max_age for age in tick_ages)

    if return_age:
        return is_fresh, max_tick_age, max_age
    return is_fresh


def body_ratio(c):
    try:
        return max((c["trade_price"] - c["opening_price"]) /
                   max(c["opening_price"], 1), 0)
    except:
        return 0


# ---- 5ë¶„ ì»¨í…ìŠ¤íŠ¸: LRU ìºì‹œ ----
class LRUCache:

    def __init__(self, maxsize=100):
        self.cache = OrderedDict()
        self.maxsize = maxsize
        self.lock = threading.Lock()

    def get(self, key):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
                return self.cache[key]
            return None

    def set(self, key, value):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.maxsize:
                self.cache.popitem(last=False)

    def clear(self):
        with self.lock:
            self.cache.clear()

    def purge_older_than(self, max_age_sec=3.0):
        cutoff = int(time.time() * 1000) - int(max_age_sec * 1000)
        with self.lock:
            drop = [
                k for k, v in self.cache.items()
                if isinstance(v, dict) and v.get("ts", 0) < cutoff
            ]
            for k in drop:
                self.cache.pop(k, None)


_TICKS_CACHE = LRUCache(maxsize=100)
_TICKS_TTL = 4.5
_C5_CACHE = LRUCache(maxsize=300)


def five_min_context_ok(m):
    if not USE_5M_CONTEXT:
        return True
    hit = _C5_CACHE.get(m)
    if hit and (time.time() - hit.get("ts", 0) <= 3.0):
        c5 = hit["c"]
    else:
        c5 = get_minutes_candles(5, m, 6)
        _C5_CACHE.set(m, {"ts": time.time(), "c": c5})
    if len(c5) < 4:
        return True
    try:
        close = [c["trade_price"] for c in c5]
        slope3 = close[-1] - close[-3]
        recent_break = c5[-1]["high_price"] > max(x["high_price"]
                                                  for x in c5[-4:-1])
        return (slope3 > 0) or recent_break
    except:
        return True

def get_dynamic_thresholds():
    h = now_kst().hour
    if 0 <= h < 6:
        return {
            "zscore": 0.90,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0008,
            "uptick": 2,
            "min_change": 0.0004,  # ê¸°ì¡´ 0.0005
            "bidask_min": 1.06
        }
    elif 6 <= h < 12:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0006,  # ê¸°ì¡´ 0.0007
            "bidask_min": 1.07
        }
    elif 12 <= h < 18:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,    # ê¸°ì¡´ 0.0010
            "uptick": 2,
            "min_change": 0.0008,  # ê¸°ì¡´ 0.0010
            "bidask_min": 1.075    # ì‚´ì§ ì™„í™”
        }
    else:
        return {
            "zscore": 0.92,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0007,
            "bidask_min": 1.07
        }

# =========================
# â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
# =========================
def relax_knob():
    """
    0.0 ~ 1.5 ìŠ¤ì¼€ì¼.
    + BTC 5ë¶„ ìˆ˜ìµ > 0.6%ë©´ +1.0, > 0.3%ë©´ +0.5
    + ì•¼ê°„(00~06h)ë©´ +0.5
    """
    try:
        b5 = btc_5m_change()
    except:
        b5 = 0.0
    h = now_kst().hour
    f = 0.0
    if b5 >= 0.006: f += 1.0
    elif b5 >= 0.003: f += 0.5
    if 0 <= h < 6: f += 0.5
    return min(1.5, f)


# =========================
# ë°ì´í„° ìˆ˜ì§‘/ìºì‹œ
# =========================
MKTS_CACHE_TTL = 90
_MKTS_CACHE = {"ts": 0.0, "mkts": []}


def get_top_krw_by_24h(n=TOP_N):
    now = time.time()
    if _MKTS_CACHE["mkts"] and (now - _MKTS_CACHE["ts"] <= MKTS_CACHE_TTL):
        mkts = _MKTS_CACHE["mkts"]
    else:
        allm = [
            d["market"]
            for d in upbit_get("https://api.upbit.com/v1/market/all") or []
            if d["market"].startswith("KRW-")
        ]
        acc = []
        for i in range(0, len(allm), 50):
            info = upbit_get("https://api.upbit.com/v1/ticker",
                             {"markets": ",".join(allm[i:i + 50])})
            if not info: continue
            for t in info:
                v = t.get("acc_trade_price_24h", 0)
                if v > 0: acc.append((t["market"], v))
        acc.sort(key=lambda x: x[1], reverse=True)
        mkts = [m for m, _ in acc]
        _MKTS_CACHE["mkts"] = mkts
        _MKTS_CACHE["ts"] = now
    return mkts[:n]


def get_minutes_candles(u, m, c):
    js = upbit_get(f"https://api.upbit.com/v1/candles/minutes/{u}", {
        "market": m,
        "count": c
    },
                   timeout=6)
    return list(reversed(js)) if js else []

def get_recent_ticks(m, c=100, allow_network=True):
    now_ms = int(time.time() * 1000)
    hit = _TICKS_CACHE.get(m)
    if hit and (now_ms - hit["ts"] <= _TICKS_TTL * 1000):
        return hit["ticks"]
    if not allow_network:
        return hit["ticks"] if hit else []

    # âœ… ì•ˆì „ ë˜í¼ë¡œ ë³€ê²½
    js = safe_upbit_get("https://api.upbit.com/v1/trades/ticks", {
        "market": m,
        "count": c
    },
                        timeout=6)

    if not js or not isinstance(js, list):
        return hit["ticks"] if hit else []
    js_sorted = sorted(js, key=lambda t: t.get("timestamp", 0), reverse=True)
    _TICKS_CACHE.set(m, {"ts": now_ms, "ticks": js_sorted})
    return js_sorted

def micro_tape_stats_from_ticks(ticks, sec):
    if not ticks:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    n = 0
    krw = 0.0
    buys = 0
    oldest_ts = newest_ts
    for x in ticks:
        ts = x.get("timestamp", 0)
        if ts < cutoff:
            break
        p = x.get("trade_price", 0.0)
        v = x.get("trade_volume", 0.0)
        krw += p * v
        n += 1
        if x.get("ask_bid") == "BID": buys += 1
        if ts < oldest_ts: oldest_ts = ts

    if n == 0:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    now_ms = int(time.time() * 1000)
    age = (now_ms - newest_ts) / 1000.0 if newest_ts else 999
    duration = max((newest_ts - (oldest_ts or newest_ts)) / 1000.0, 1.0)
    rate = n / duration
    krw_per_sec = krw / duration
    return {
        "krw": krw,
        "n": n,
        "buy_ratio": buys / n,
        "age": age,
        "rate": rate,
        "krw_per_sec": krw_per_sec
    }


def calc_consecutive_buys(ticks, sec=15):
    """
    ì²´ê²°ê°•ë„: ìµœê·¼ Nì´ˆ ë‚´ ì—°ì† ë§¤ìˆ˜ ì²´ê²° ìµœëŒ€ íšŸìˆ˜
    â†’ 5ê°œ ì´ìƒ ì—°ì† ë§¤ìˆ˜ = ê°•í•œ ì‹ í˜¸
    """
    if not ticks:
        return 0
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return 0

    max_streak = 0
    current_streak = 0
    for x in ticks:
        if x.get("timestamp", 0) < cutoff:
            break
        if x.get("ask_bid") == "BID":
            current_streak += 1
            max_streak = max(max_streak, current_streak)
        else:
            current_streak = 0
    return max_streak


def calc_avg_krw_per_tick(t_stats):
    """
    í‹±ë‹¹ í‰ê· ê¸ˆì•¡: ì´ ê±°ë˜ëŒ€ê¸ˆ / í‹±ìˆ˜
    â†’ ë†’ì„ìˆ˜ë¡ ëŒ€í˜• ì²´ê²° (ê³ ë˜ ê°€ëŠ¥ì„±)
    """
    if not t_stats or t_stats.get("n", 0) == 0:
        return 0
    return t_stats["krw"] / t_stats["n"]


def calc_flow_acceleration(ticks):
    """
    ì²´ê²° ê°€ì†ë„: t5s / t15s ë¹„ìœ¨
    â†’ 1.5 ì´ìƒ = ê°€ì† ì¤‘, 0.7 ì´í•˜ = ê°ì† ì¤‘
    """
    if not ticks:
        return 1.0
    t5s = micro_tape_stats_from_ticks(ticks, 5)
    t15s = micro_tape_stats_from_ticks(ticks, 15)

    if t15s["krw_per_sec"] <= 0:
        return 1.0
    return t5s["krw_per_sec"] / t15s["krw_per_sec"]


# ========================================
# ğŸš€ ëŸ¬ë‹ 1ë¶„ë´‰ (Running 1m Bar) - ì¢…ê°€ í™•ì • ì „ ì‹¤ì‹œê°„ ê³„ì‚°
# ========================================
def running_1m_bar(ticks, last_candle=None):
    """
    í‹± ë°ì´í„°ë¡œ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ 1ë¶„ë´‰ì„ ì‹¤ì‹œê°„ ê³„ì‚°
    - ì¢…ê°€ í™•ì • ì „ì—ë„ í˜„ì¬ ê°€ê²©/ê±°ë˜ëŸ‰/ë³€ë™í­ íŒŒì•… ê°€ëŠ¥
    - last_candleì´ ìˆìœ¼ë©´ ì´ì „ ë´‰ ê¸°ì¤€ìœ¼ë¡œ ë³€ë™ë¥  ê³„ì‚°

    Returns: {
        'open': ì‹œê°€,
        'high': ê³ ê°€,
        'low': ì €ê°€,
        'close': í˜„ì¬ê°€ (ì§„í–‰ ì¤‘),
        'volume_krw': ê±°ë˜ëŒ€ê¸ˆ,
        'tick_count': í‹± ìˆ˜,
        'buy_ratio': ë§¤ìˆ˜ ë¹„ìœ¨,
        'change_from_prev': ì´ì „ë´‰ ëŒ€ë¹„ ë³€ë™ë¥ ,
        'range_pct': ì§„í–‰ ì¤‘ ë´‰ì˜ ë³€ë™í­ (high-low)/low
    }
    """
    if not ticks:
        return None

    now_ms = int(time.time() * 1000)
    minute_start = (now_ms // 60000) * 60000  # í˜„ì¬ ë¶„ì˜ ì‹œì‘ ì‹œì 

    # í˜„ì¬ ë¶„ ë‚´ì˜ í‹±ë§Œ í•„í„°
    current_ticks = [t for t in ticks if t.get("timestamp", 0) >= minute_start]

    if not current_ticks:
        # í˜„ì¬ ë¶„ í‹±ì´ ì—†ìœ¼ë©´ ìµœê·¼ 10ì´ˆ í‹±ìœ¼ë¡œ ëŒ€ì²´
        fallback_cutoff = now_ms - 10000
        current_ticks = [t for t in ticks if t.get("timestamp", 0) >= fallback_cutoff]
        if not current_ticks:
            return None

    prices = [t.get("trade_price", 0) for t in current_ticks if t.get("trade_price", 0) > 0]
    if not prices:
        return None

    # OHLC ê³„ì‚° (í‹±ì€ ìµœì‹ ìˆœ ì •ë ¬ì´ë¯€ë¡œ reverse í•„ìš”)
    prices_chrono = list(reversed(prices))  # ì‹œê°„ìˆœ ì •ë ¬
    open_price = prices_chrono[0]
    high_price = max(prices)
    low_price = min(prices)
    close_price = prices_chrono[-1]  # ê°€ì¥ ìµœê·¼ ê°€ê²©

    # ê±°ë˜ëŒ€ê¸ˆ/ë§¤ìˆ˜ë¹„
    volume_krw = sum(t.get("trade_price", 0) * t.get("trade_volume", 0) for t in current_ticks)
    buys = sum(1 for t in current_ticks if t.get("ask_bid") == "BID")
    buy_ratio = buys / len(current_ticks) if current_ticks else 0

    # ì´ì „ë´‰ ëŒ€ë¹„ ë³€ë™ë¥ 
    change_from_prev = 0.0
    if last_candle and last_candle.get("trade_price", 0) > 0:
        change_from_prev = close_price / last_candle["trade_price"] - 1

    # ì§„í–‰ ì¤‘ ë´‰ì˜ ë³€ë™í­
    range_pct = (high_price - low_price) / low_price if low_price > 0 else 0

    return {
        "open": open_price,
        "high": high_price,
        "low": low_price,
        "close": close_price,
        "volume_krw": volume_krw,
        "tick_count": len(current_ticks),
        "buy_ratio": buy_ratio,
        "change_from_prev": change_from_prev,
        "range_pct": range_pct,
    }


# ========================================
# ğŸš€ Pre-break ë™ì  ëŒ€ì—­ (ë³€ë™ì„± ê¸°ë°˜)
# ========================================
_PREBREAK_SUSPEND_UNTIL = 0.0  # ì—°íŒ¨ ì‹œ ì¼ì‹œ ì¤‘ì§€ íƒ€ì„ìŠ¤íƒ¬í”„

def dynamic_prebreak_band(ticks):
    """
    ë¶„ìœ„ê¸°(ê°€ê²©ë°´ë“œ í‘œì¤€í¸ì°¨, ì•¼ê°„ ì™„í™”)ì— ë”°ë¼ ê³ ì  ê·¼ì ‘ í—ˆìš©í­ ìë™ ì¡°ì ˆ
    - ê¸‰ë“±/íœ©ì˜ ì¥ë©´ì—ì„  ë” íƒ€ì´íŠ¸
    - ì¡°ìš©í•˜ë©´ ì‚´ì§ ê´€ëŒ€
    """
    # 10ì´ˆ ê°€ê²©ë°´ë“œ í‘œì¤€í¸ì°¨
    pstd = price_band_std(ticks, sec=10) if ticks else None
    pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬
    # ê¸°ë³¸ 0.20% Â± pstd*40% (ìƒí•œ 0.35%)
    base = PREBREAK_HIGH_PCT  # 0.002
    band = min(0.0035, base + pstd * 0.40)
    # ì•¼ê°„ ì‚´ì§ ì™„í™”
    if 0 <= now_kst().hour < 6:
        band = min(0.0038, band + 0.0004)
    return band


# ========================================
# ğŸš€ Pre-break Probe ì²´í¬ (ê³ ì  ê·¼ì²˜ ì„ í–‰ ì§„ì…)
# ========================================
def _pct(a, b):
    try:
        return abs(a / b - 1.0)
    except:
        return 0.0


def inter_arrival_stats(ticks, sec=30):
    if not ticks: return {"cv": 9.9, "count": 0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"cv": 9.9, "count": 0}
    cutoff = newest_ts - sec * 1000
    ts = [x["timestamp"] for x in ticks if x["timestamp"] >= cutoff]
    ts = sorted(ts)
    if len(ts) < 4: return {"cv": 9.9, "count": len(ts)}
    gaps = [(b - a) / 1000.0 for a, b in zip(ts, ts[1:])]
    mu = sum(gaps) / len(gaps)
    if mu <= 0: return {"cv": 9.9, "count": len(ts)}
    var = sum((g - mu)**2 for g in gaps) / len(gaps)
    cv = (var**0.5) / mu
    return {"cv": cv, "count": len(ts)}


def price_band_std(ticks, sec=30):
    """ê°€ê²©ë°´ë“œ í‘œì¤€í¸ì°¨. ë°ì´í„° ë¶€ì¡±ì‹œ None ë°˜í™˜ (ì„¼í‹°ë„¬ 9.9 ì œê±°)"""
    if not ticks: return None
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return None
    cutoff = newest_ts - sec * 1000
    ps = [x["trade_price"] for x in ticks if x["timestamp"] >= cutoff]
    if len(ps) < 3: return None
    m = sum(ps) / len(ps)
    var = sum((p - m)**2 for p in ps) / len(ps)
    std = (var**0.5) / max(m, 1)
    return std


def bot_pingpong_score(ticks, sec=20, band=BOT_PINGPONG_MAX_BAND):
    if not ticks: return 0.0
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 0.0
    cutoff = newest_ts - sec * 1000
    win = [x for x in reversed(ticks) if x["timestamp"] >= cutoff]
    if len(win) < 6: return 0.0
    prices = [x["trade_price"] for x in win]
    pr_min, pr_max = min(prices), max(prices)
    if _pct(pr_max, pr_min) > band:
        return 0.0
    alt = sum(1 for a, b in zip(win, win[1:])
              if a["ask_bid"] != b["ask_bid"]) / max(len(win) - 1, 1)
    return alt


def wash_trade_pattern(ticks, sec=30, repeats=BOT_WASH_REPEAT_VOL_N):
    if not ticks: return False
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return False
    cutoff = newest_ts - sec * 1000
    vols = {}
    for x in ticks:
        if x["timestamp"] < cutoff: break
        v = round(x["trade_volume"], 6)
        vols[v] = vols.get(v, 0) + 1
    if not vols: return False
    top = max(vols.values())
    return top >= repeats


def _win_stats(ticks, start_s, end_s):
    if not ticks:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    lo = newest_ts - end_s * 1000
    hi = newest_ts - start_s * 1000
    win = [x for x in ticks if lo <= x.get("timestamp", 0) <= hi]
    if len(win) < 2:
        return {
            "n": len(win),
            "buy_ratio": 0.0,
            "rate": 0.0,
            "krw_per_sec": 0.0
        }
    win = sorted(win, key=lambda t: t["timestamp"])
    dur = max((win[-1]["timestamp"] - win[0]["timestamp"]) / 1000.0, 1.0)
    buys = sum(1 for x in win if x.get("ask_bid") == "BID")
    krw = sum(x["trade_price"] * x["trade_volume"] for x in win)
    return {
        "n": len(win),
        "buy_ratio": buys / max(len(win), 1),
        "rate": len(win) / dur,
        "krw_per_sec": krw / dur
    }


def buy_decay_flag(ticks):
    early = _win_stats(ticks, start_s=10, end_s=20)
    now = _win_stats(ticks, start_s=0, end_s=5)
    if early["n"] < 4 or now["n"] < 2:
        return False, {"early": early, "now": now}
    drop_buy = early["buy_ratio"] - now["buy_ratio"]
    cond = (drop_buy >= 0.12 and now["rate"] <= early["rate"] * 0.80
            and now["krw_per_sec"] <= early["krw_per_sec"] * 0.70)
    return cond, {"early": early, "now": now, "drop_buy": drop_buy}


# =========================
# ì‹œì¥ í•„í„°
# =========================
def btc_5m_change():
    c = get_minutes_candles(5, "KRW-BTC", 3)
    if len(c) < 2: return 0.0
    return c[-1]["trade_price"] / max(c[-2]["trade_price"], 1) - 1

# =========================
# ë³´ì¡°: ìº”ë“¤/ATR/EMA
# =========================
def ema_series(vals, period):
    if not vals: return []
    k = 2 / (period + 1)
    out = []
    ema = vals[0]
    for v in vals:
        ema = v * k + ema * (1 - k)
        out.append(ema)
    return out


def ema_last(vals, period):
    if len(vals) == 0: return None
    return ema_series(vals, period)[-1]


def vol_ma_from_candles(candles, period=20):
    """ìµœê·¼ Në´‰ ê±°ë˜ëŸ‰ í‰ê·  (ê±°ë˜ëŒ€ê¸ˆ ê¸°ì¤€)"""
    if len(candles) < period:
        return 0
    vols = [c.get("candle_acc_trade_price", 0) for c in candles[-period:]]
    return sum(vols) / len(vols) if vols else 0


def prev_high_from_candles(candles, lookback=12, skip_recent=1):
    """ìµœê·¼ Në´‰ ì¤‘ ê³ ì  (ìµœê·¼ skip_recentë´‰ ì œì™¸)"""
    if len(candles) < lookback + skip_recent:
        return 0
    subset = candles[-(lookback + skip_recent):-skip_recent] if skip_recent > 0 else candles[-lookback:]
    if not subset:
        return 0
    return max(c.get("high_price", 0) for c in subset)


# ========================================
# ğŸ”¥ ì í™” ê°ì§€ (Ignition Detection) - ê¸‰ë“± ì´ˆì… 0~30ì´ˆ ë‚´ ê°ì§€
# ========================================
def update_baseline_tps(market: str, ticks, window_sec: int = 300):
    """
    í‰ì‹œ í‹±/ì´ˆ (baseline TPS) ì—…ë°ì´íŠ¸
    - ìµœê·¼ 5ë¶„ê°„ í‹± ë°ì´í„°ë¡œ í‰ê·  ticks-per-second ê³„ì‚°
    - ì í™” ê°ì§€ì˜ ìƒëŒ€ ì„ê³„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©
    """
    if not ticks or len(ticks) < 10:
        return

    now_ts = ticks[0].get("timestamp", ticks[0].get("ts", 0))
    cutoff = now_ts - (window_sec * 1000)

    # window_sec ë‚´ì˜ í‹±ë§Œ í•„í„°
    window_ticks = [t for t in ticks if t.get("timestamp", t.get("ts", 0)) >= cutoff]

    if len(window_ticks) < 5:
        return

    # í‹± ìˆ˜ / ì‹œê°„(ì´ˆ) = TPS
    first_ts = window_ticks[-1].get("timestamp", window_ticks[-1].get("ts", 0))
    last_ts = window_ticks[0].get("timestamp", window_ticks[0].get("ts", 0))
    duration_sec = max((last_ts - first_ts) / 1000, 1)

    tps = len(window_ticks) / duration_sec

    with _IGNITION_LOCK:
        # ì§€ìˆ˜ì´ë™í‰ê· ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ì—…ë°ì´íŠ¸
        old_tps = _IGNITION_BASELINE_TPS.get(market, tps)
        _IGNITION_BASELINE_TPS[market] = old_tps * 0.8 + tps * 0.2


def ignition_detected(
    market: str,
    ticks,
    avg_candle_volume: float,
    ob=None,
    cooldown_ms: int = 10000
) -> tuple:
    """
    ì í™” ê°ì§€: ê¸‰ë“± ì‹œì‘ 0~30ì´ˆ ë‚´ ê°ì§€

    4ìš”ê±´ ì¤‘ 3ê°œ ì¶©ì¡± ì‹œ ì í™” (í­ë°œì  ê¸‰ë“± ê°ì§€):
    1. í‹± í­ì£¼: ìµœê·¼ 10ì´ˆ í‹±ìˆ˜ >= í‰ì‹œì˜ 4ë°° (ê°•í™”: 3â†’4ë°°)
    2. ì—°ì† ë§¤ìˆ˜: 10ì´ˆ ë‚´ 7íšŒ ì´ìƒ ì—°ì† ë§¤ìˆ˜ (ê°•í™”: 5â†’7íšŒ)
    3. ê°€ê²© ì„í„ìŠ¤: 0.5% ì´ìƒ ìƒìŠ¹ + ìµœê·¼ 6í‹± ë‹¨ì¡°ì¦ê°€ (ê°•í™”: 0.3â†’0.5%)
    4. ê±°ë˜ëŸ‰ í­ë°œ: 10ì´ˆ ê±°ë˜ëŸ‰ >= 1ë¶„í‰ê· ì˜ 40% (ê°•í™”: 25â†’40%)

    ì¶”ê°€ í•„í„°:
    - ìŠ¤í”„ë ˆë“œ ì•ˆì •ì„± (í‰ì‹œ 2ë°° ì´í•˜)
    - ì¿¨ë‹¤ìš´ (15ì´ˆê°„ ì¬ì í™” ê¸ˆì§€)

    Returns: (is_ignition, reason, score)
    """
    if not ticks or len(ticks) < 10:
        return False, "í‹±ë¶€ì¡±", 0

    now_ts = ticks[0].get("timestamp", ticks[0].get("ts", int(time.time() * 1000)))

    # ---- ì¿¨ë‹¤ìš´ ì²´í¬ ----
    with _IGNITION_LOCK:
        last_signal = _IGNITION_LAST_SIGNAL.get(market, 0)
        if (now_ts - last_signal) < cooldown_ms:
            return False, f"ì¿¨ë‹¤ìš´({(cooldown_ms - (now_ts - last_signal)) / 1000:.1f}ì´ˆ)", 0

    # ---- ìµœê·¼ 10ì´ˆ ìœˆë„ìš° ì¶”ì¶œ ----
    cutoff_10s = now_ts - 10000
    window = [t for t in ticks if t.get("timestamp", t.get("ts", 0)) >= cutoff_10s]

    if len(window) < 6:
        return False, "10ì´ˆìœˆë„ìš°ë¶€ì¡±", 0

    # ---- 1) í‹± í­ì£¼ (ìƒëŒ€ ì„ê³„ì¹˜) ----
    with _IGNITION_LOCK:
        baseline_tps = _IGNITION_BASELINE_TPS.get(market, 0.5)  # ê¸°ë³¸ê°’ 0.5 tps

    t10 = micro_tape_stats_from_ticks(ticks, 10)
    # ğŸ”§ ê°•í™”: í‰ì‹œì˜ 4ë°° ì´ìƒ, ìµœì†Œ 15í‹± (í­ë°œì  ê¸‰ë“± ê°ì§€)
    tps_threshold = max(15, 4 * baseline_tps * 10)
    tps_burst = t10["n"] >= tps_threshold

    # ---- 2) ì—°ì† ë§¤ìˆ˜ (10ì´ˆ ìœˆë„ìš°) ----
    # ğŸ”§ ê°•í™”: 5íšŒ â†’ 7íšŒ (í­ë°œì  ë§¤ìˆ˜ì„¸ë§Œ ê°ì§€)
    consec_buys = calc_consecutive_buys(window, 10) >= 7

    # ---- 3) ê°€ê²© ì„í„ìŠ¤ (ìˆ˜ìµë¥  + ëŒ€ë¶€ë¶„ ìƒìŠ¹) ----
    prices = [t["trade_price"] for t in reversed(window)]  # ì˜¤ë˜ëœ â†’ ìµœì‹ 
    if len(prices) >= 6:
        ret = (prices[-1] / prices[0]) - 1 if prices[0] > 0 else 0
        # ğŸ”§ ì™„í™”: 5í‹± ì¤‘ 4í‹± ì´ìƒ ìƒìŠ¹ (ê¸°ì¡´: 6í‹± ëª¨ë‘ ìƒìŠ¹)
        up_count = sum(1 for a, b in zip(prices[-6:-1], prices[-5:]) if b > a)
        mostly_up = up_count >= 4
        # ğŸ”§ ê°•í™”: 0.3% â†’ 0.5% (í­ë°œì  ê¸‰ë“±ë§Œ ê°ì§€)
        price_impulse = (ret >= 0.005) and mostly_up  # 0.5% ì´ìƒ + ëŒ€ë¶€ë¶„ ìƒìŠ¹
    else:
        ret = 0
        price_impulse = False

    # ---- 4) ê±°ë˜ëŸ‰ í­ë°œ (10ì´ˆ ê±°ë˜ëŸ‰ >= 1ë¶„í‰ê· ì˜ 40%) ----
    # ğŸ”§ ê°•í™”: 25% â†’ 40% (í­ë°œì  ê±°ë˜ëŸ‰ë§Œ ê°ì§€)
    vol_burst = t10["krw"] >= 0.40 * avg_candle_volume if avg_candle_volume > 0 else False

    # ---- ìŠ¤í”„ë ˆë“œ ì•ˆì •ì„± í•„í„° (ì˜µì…˜) ----
    spread_ok = True
    if ob and ob.get("spread", 0) > 0:
        # ğŸ”§ 0.5% â†’ 0.40% ê°•í™” (ì í™” êµ¬ê°„ì€ ìŠ¬ë¦½ ì»¤ì§€ë¯€ë¡œ ë” ì—„ê²©íˆ)
        spread_ok = ob["spread"] <= 0.40

    # ---- ì ìˆ˜ ê³„ì‚° ----
    score = sum([tps_burst, consec_buys, price_impulse, vol_burst])

    # ---- ì í™” íŒì •: 4ìš”ê±´ ì¤‘ 3ê°œ ì´ìƒ + ìŠ¤í”„ë ˆë“œ ì–‘í˜¸ ----
    # ğŸ”§ 4/4 â†’ 3/4ë¡œ ì™„í™” (ê°œë³„ ì¡°ê±´ì´ ê°•í™”ëìœ¼ë¯€ë¡œ, í­ë°œì  ê¸‰ë“± ìœ ì—°í•˜ê²Œ ê°ì§€)
    is_ignition = (score >= 3) and spread_ok

    if is_ignition:
        # ë§ˆì§€ë§‰ ì‹ í˜¸ ì‹œê° ê¸°ë¡
        with _IGNITION_LOCK:
            _IGNITION_LAST_SIGNAL[market] = now_ts

    # ìƒì„¸ reason ìƒì„±
    details = []
    details.append(f"í‹±{'âœ“' if tps_burst else 'âœ—'}({t10['n']:.0f}>={tps_threshold:.0f})")
    details.append(f"ì—°ë§¤{'âœ“' if consec_buys else 'âœ—'}")
    details.append(f"ê°€ê²©{'âœ“' if price_impulse else 'âœ—'}({ret*100:.2f}%)")
    details.append(f"ê±°ë˜ëŸ‰{'âœ“' if vol_burst else 'âœ—'}")
    if not spread_ok:
        details.append("ìŠ¤í”„ë ˆë“œâœ—")

    reason = ",".join(details)

    return is_ignition, reason, score


def atr14_from_candles(candles, period=14):
    if len(candles) < period + 1:
        return None
    trs = []
    for i in range(1, len(candles)):
        h = candles[i]["high_price"]
        l = candles[i]["low_price"]
        pc = candles[i - 1]["trade_price"]
        tr = max(h - l, abs(h - pc), abs(l - pc))
        trs.append(tr)
    return sum(trs[-period:]) / period if len(trs) >= period else None


# =========================
# â˜… ê·¸ë¼ì¸ë“œ(ê³„ë‹¨ì‹ ìƒìŠ¹) ì˜ˆì™¸
# =========================
# === PATCH: grind detector ===
def is_mega_breakout(c1):
    if not ULTRA_RELAX_ON_MEGA or len(c1) < 6:
        return False
    cur = c1[-1]
    prev_high = max(x["high_price"] for x in c1[-6:-1])
    gap = cur["high_price"] / max(prev_high, 1) - 1
    chg_1m = cur["trade_price"] / max(c1[-2]["trade_price"], 1) - 1 if len(
        c1) >= 2 else 0
    z = zscore_krw_1m(c1, 30)
    abs_krw = cur.get("candle_acc_trade_price", 0)
    return (gap >= MEGA_BREAK_MIN_GAP) and (chg_1m >= MEGA_MIN_1M_CHG) and (
        (z >= MEGA_VOL_Z) or (abs_krw >= MEGA_ABS_KRW))


# =========================
# ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì… í•¨ìˆ˜ë“¤
# =========================
def add_to_retest_watchlist(m, peak_price, pre):
    """ì²« ê¸‰ë“± ê°ì§€ ì‹œ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ì— ë“±ë¡"""
    if not RETEST_MODE_ENABLED:
        return
    with _RETEST_LOCK:
        if m in _RETEST_WATCHLIST:
            return  # ì´ë¯¸ ë“±ë¡ë¨
        _RETEST_WATCHLIST[m] = {
            "peak_price": peak_price,
            "peak_ts": time.time(),
            "pullback_low": peak_price,  # ë˜ëŒë¦¼ ì €ì  ì¶”ì 
            "state": "watching",  # watching â†’ pullback â†’ bounce â†’ ready
            "pre": pre,
            "entry_price": pre.get("price", peak_price),  # ì›ë˜ ì‹ í˜¸ ê°€ê²©
        }
        print(f"[RETEST] {m} ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ë“±ë¡ | ê³ ì  {peak_price:,.0f}ì› | ë¦¬í…ŒìŠ¤íŠ¸ ëŒ€ê¸°")


def check_retest_entry(m):
    """ë¦¬í…ŒìŠ¤íŠ¸ ì¡°ê±´ ì²´í¬ â†’ ì§„ì… ê°€ëŠ¥í•˜ë©´ pre ë°˜í™˜, ì•„ë‹ˆë©´ None"""
    if not RETEST_MODE_ENABLED:
        return None

    with _RETEST_LOCK:
        watch = _RETEST_WATCHLIST.get(m)
        if not watch:
            return None

        # íƒ€ì„ì•„ì›ƒ ì²´í¬
        elapsed = time.time() - watch["peak_ts"]
        if elapsed > RETEST_TIMEOUT_SEC:
            print(f"[RETEST] {m} íƒ€ì„ì•„ì›ƒ ({elapsed:.0f}ì´ˆ) â†’ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ì œê±°")
            _RETEST_WATCHLIST.pop(m, None)
            return None

        peak_price = watch["peak_price"]
        entry_price = watch["entry_price"]
        state = watch["state"]

    # í˜„ì¬ê°€ ì¡°íšŒ
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        if not cur_js or len(cur_js) == 0:
            return None
        cur_price = cur_js[0].get("trade_price", 0)
    except:
        return None

    if cur_price <= 0:
        return None

    # ë˜ëŒë¦¼ ì €ì  ì—…ë°ì´íŠ¸
    with _RETEST_LOCK:
        watch = _RETEST_WATCHLIST.get(m)
        if not watch:
            return None
        if cur_price < watch["pullback_low"]:
            watch["pullback_low"] = cur_price
        pullback_low = watch["pullback_low"]

    # ê³ ì  ëŒ€ë¹„ í•˜ë½ë¥ 
    pullback_pct = (peak_price - pullback_low) / peak_price if peak_price > 0 else 0
    # ì €ì  ëŒ€ë¹„ ë°˜ë“±ë¥ 
    bounce_pct = (cur_price - pullback_low) / pullback_low if pullback_low > 0 else 0

    # ìƒíƒœ ì „ì´ ë¡œì§
    with _RETEST_LOCK:
        watch = _RETEST_WATCHLIST.get(m)
        if not watch:
            return None

        if state == "watching":
            # ì¶©ë¶„íˆ ë˜ëŒë¦¼ì´ ì™”ëŠ”ì§€ ì²´í¬
            if pullback_pct >= RETEST_PULLBACK_MIN:
                watch["state"] = "pullback"
                print(f"[RETEST] {m} ë˜ëŒë¦¼ ê°ì§€ | -{pullback_pct*100:.2f}% | stateâ†’pullback")

        elif state == "pullback":
            # ë„ˆë¬´ ë§ì´ ë¹ ì¡Œìœ¼ë©´ ì œê±°
            if pullback_pct > RETEST_PULLBACK_MAX:
                print(f"[RETEST] {m} ê³¼ë„í•œ ë˜ëŒë¦¼ -{pullback_pct*100:.2f}% > {RETEST_PULLBACK_MAX*100:.1f}% â†’ ì œê±°")
                _RETEST_WATCHLIST.pop(m, None)
                return None

            # ë°˜ë“± ì‹œì‘ ì²´í¬
            if bounce_pct >= RETEST_BOUNCE_MIN:
                watch["state"] = "bounce"
                print(f"[RETEST] {m} ë°˜ë“± ê°ì§€ | +{bounce_pct*100:.2f}% | stateâ†’bounce")

        elif state == "bounce":
            # EMA/VWAP ì§€ì§€ í™•ì¸ (ê°„ë‹¨íˆ entry_price ìœ„ì¸ì§€ ì²´í¬)
            support_ok = cur_price >= entry_price * 0.995  # ì§„ì…ê°€ -0.5% ì´ìƒ

            if support_ok and bounce_pct >= RETEST_BOUNCE_MIN:
                watch["state"] = "ready"
                print(f"[RETEST] {m} ì§€ì§€ í™•ì¸ | í˜„ì¬ê°€ {cur_price:,.0f} >= ì§„ì…ê°€ {entry_price:,.0f} | stateâ†’ready")

        elif state == "ready":
            # ì§„ì… ì¡°ê±´ ì¶©ì¡±!
            pre = watch.get("pre", {})
            pre["retest_entry"] = True  # ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì… ë§ˆí‚¹
            pre["price"] = cur_price  # í˜„ì¬ê°€ë¡œ ì—…ë°ì´íŠ¸
            _RETEST_WATCHLIST.pop(m, None)  # ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°
            print(f"[RETEST] {m} ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì… ì‹ í˜¸! | ê³ ì  {peak_price:,.0f} â†’ ì €ì  {pullback_low:,.0f} â†’ í˜„ì¬ {cur_price:,.0f}")
            return pre

    return None


def cleanup_retest_watchlist():
    """íƒ€ì„ì•„ì›ƒëœ í•­ëª© ì •ë¦¬"""
    if not RETEST_MODE_ENABLED:
        return
    with _RETEST_LOCK:
        now = time.time()
        expired = [m for m, w in _RETEST_WATCHLIST.items()
                   if now - w["peak_ts"] > RETEST_TIMEOUT_SEC]
        for m in expired:
            print(f"[RETEST] {m} íƒ€ì„ì•„ì›ƒ â†’ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ì œê±°")
            _RETEST_WATCHLIST.pop(m, None)


def is_morning_session():
    """ì¥ì´ˆ ì‹œê°„ëŒ€ì¸ì§€ í™•ì¸ (08:00~10:00)"""
    try:
        cur_hour = now_kst().hour
        return RETEST_MORNING_HOURS[0] <= cur_hour < RETEST_MORNING_HOURS[1]
    except:
        return False


# =========================
# í—ˆìˆ˜ ë°©ì–´ / ì í™” / ì¡°ê¸° ë¸Œë ˆì´í¬
# =========================
def _turn_needed(ob_depth_krw):
    if ob_depth_krw >= 30_000_000:
        return 0.022
    elif ob_depth_krw >= 15_000_000:
        return 0.026
    elif ob_depth_krw >= 8_000_000:
        return 0.025
    else:
        return 0.023

def stage1_gate(*, spread, accel, volume_surge, turn_pct, buy_ratio, imbalance, fresh_ok,
                 fresh_age=0.0, fresh_max_age=2.0,
                 current_volume=0, price_change=0, mega=False,
                 ema20_breakout=False, high_breakout=False, vol_vs_ma=0.0,
                 ignition_score=0, best_ask_krw=0, cur_price=0):
    """
    1ë‹¨ê³„ ì§„ì… ê²Œì´íŠ¸: ë‹¨ì¼ í†µí•© í•„í„° (ì í™” í†µí•©)

    [ğŸ”¥ ì í™” ì ìˆ˜ = ê°€ì /ì™„í™” ìš”ì†Œ]
    - ignition_scoreê°€ ë†’ìœ¼ë©´ ì„ê³„ì¹˜ê°€ ë™ì ìœ¼ë¡œ ì™„í™”ë¨
    - ë³„ë„ ë¶„ê¸° ì—†ì´ ë‹¨ì¼ íë¦„ìœ¼ë¡œ ì²˜ë¦¬
    - í•™ìŠµ/íŠœë‹ í¬ì¸íŠ¸: GATE_* ë³€ìˆ˜ í•˜ë‚˜

    [ì „ì—­ ë³€ìˆ˜ ì„ê³„ì¹˜ ì‚¬ìš© - ìë™í•™ìŠµ ëŒ€ìƒ]
    - GATE_TURN_MIN: íšŒì „ìœ¨ í•˜í•œ
    - GATE_SPREAD_MAX: ìŠ¤í”„ë ˆë“œ ìƒí•œ
    - GATE_ACCEL_MIN: ê°€ì†ë„ í•˜í•œ
    - GATE_BUY_RATIO_MIN: ë§¤ìˆ˜ë¹„ í•˜í•œ
    - GATE_IMBALANCE_MIN: í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ í•˜í•œ
    - GATE_VOL_MIN: ê±°ë˜ëŒ€ê¸ˆ í•˜í•œ
    - GATE_SURGE_MIN: ê±°ë˜ëŸ‰ê¸‰ë“± í•˜í•œ
    - GATE_PRICE_MIN: ê°€ê²©ë³€ë™ í•˜í•œ
    - GATE_FRESH_AGE_MAX: í‹±ì‹ ì„ ë„ ìƒí•œ(ì´ˆ)

    [ë¡œê·¸ í˜•ì‹ í†µì¼]
    - ì»· ë©”ì‹œì§€: "í•­ëª© í˜„ì¬ê°’<ê¸°ì¤€ê°’" ë˜ëŠ” "í˜„ì¬ê°’>ê¸°ì¤€ê°’"
    - ëª¨ë“  ì»·ì— í˜„ì¬ê°’ê³¼ ë™ì  ê¸°ì¤€ê°’ í‘œì‹œ

    Returns: (allow, reason)
    """
    # ============================================================
    # ğŸ”¥ ì í™” ì ìˆ˜ì— ë”°ë¥¸ ë™ì  ì„ê³„ì¹˜ ì™„í™” (ê³„ë‹¨ì‹ + í’ˆì§ˆ í•„í„° ë³´í˜¸)
    # ğŸ”§ FIX: score=3ì€ ì•½í•œ ì™„í™”(0.12), score=4ë§Œ ê°•í•œ ì™„í™”(0.25)
    # ğŸ”§ FIX: ìŠ¤í”„ë ˆë“œ/ì„ë°¸ëŸ°ìŠ¤ëŠ” ê±°ì˜ ì•ˆ í’€ê¸° (ê°€ì§œ ì í™” ë°©ì§€)
    # ============================================================
    if ignition_score >= 4:
        relax = 0.25
    elif ignition_score == 3:
        relax = 0.12
    else:
        relax = 0.0

    # ë™ì  ì„ê³„ì¹˜ ê³„ì‚° (ì í™” ì ìˆ˜ ë†’ìœ¼ë©´ ì¡°ê±´ ì™„í™”)
    eff_surge_min = max(0.1, GATE_SURGE_MIN * (1 - relax))       # 0.7â†’0.53 (4ì )
    eff_vol_vs_ma = max(0.2, GATE_VOL_VS_MA_MIN * (1 - relax))   # ğŸ”§ ìƒìˆ˜â†’ì „ì—­ë³€ìˆ˜ ê¸°ë°˜
    eff_price_min = max(0, GATE_PRICE_MIN * (1 - relax * 2))     # ê±°ì˜ 0
    eff_turn_min = max(0.5, GATE_TURN_MIN * (1 - relax))         # 2.0â†’1.5 (4ì )
    eff_buy_min = max(0.45, GATE_BUY_RATIO_MIN * (1 - relax * 0.5))  # 0.58â†’0.51 (4ì )
    eff_imb_min = max(0.35, GATE_IMBALANCE_MIN * (1 - relax * 0.3))  # ğŸ”§ ê±°ì˜ ì•ˆ í’€ê¸° (0.50â†’0.46)
    # ğŸ”§ FIX: ìŠ¤í”„ë ˆë“œ ê°€ê²©ëŒ€ë³„ ìƒí•œ (ì €ê°€ ì½”ì¸ì€ í˜¸ê°€ë‹¨ìœ„ ë•Œë¬¸ì— êµ¬ì¡°ì ìœ¼ë¡œ ë†’ìŒ)
    if cur_price > 0 and cur_price < 100:
        eff_spread_max = 0.80   # 100ì› ë¯¸ë§Œ: 0.80%
    elif cur_price >= 100 and cur_price < 1000:
        eff_spread_max = 0.45   # 100~1000ì›: 0.45%
    else:
        eff_spread_max = 0.25   # 1000ì› ì´ìƒ: 0.25%
    eff_accel_min = max(0.1, GATE_ACCEL_MIN * (1 - relax))       # 0.3 â†’ 0.1 (3ì )

    # ì í™” ì—¬ë¶€ (ë¡œê·¸ìš©)
    is_ignition = (ignition_score >= 3)  # ğŸ”§ 4â†’3 ì™„í™” (ê°œë³„ì¡°ê±´ ê°•í™”)

    # ğŸ“Š ì£¼ìš” ì§€í‘œ í•œì¤„ ìš”ì•½ (íŠœë‹ìš© - ëª¨ë“  ì»·/í†µê³¼ì— í‘œì‹œ)
    metrics = (f"ì í™”={ignition_score} surge={volume_surge:.2f}x MAëŒ€ë¹„={vol_vs_ma:.1f}x "
               f"ë³€ë™={price_change*100:.2f}% íšŒì „={turn_pct:.1f}% ë§¤ìˆ˜ë¹„={buy_ratio:.0%} "
               f"ìŠ¤í”„ë ˆë“œ={spread:.2f}% ì„ë°¸={imbalance:.2f} ê°€ì†={accel:.1f}x")

    # ============================================================
    # ë‹¨ì¼ íë¦„: ëª¨ë“  ì¡°ê±´ ì²´í¬ (ë™ì  ì„ê³„ì¹˜ ì‚¬ìš©)
    # ============================================================

    # === ì‹ ì„ ë„ ì²´í¬ (í•„ìˆ˜ - ì™„í™” ì—†ìŒ) ===
    if not fresh_ok:
        return False, f"í‹±ì‹ ì„ ë„ë¶€ì¡± {fresh_age:.1f}ì´ˆ>{fresh_max_age:.1f}ì´ˆ"

    # === ê±°ë˜ëŒ€ê¸ˆ ì»· ===
    if current_volume < GATE_VOL_MIN and not mega:
        return False, f"ê±°ë˜ëŒ€ê¸ˆë¶€ì¡± {current_volume/1e6:.0f}M<{GATE_VOL_MIN/1e6:.0f}M"

    # === ê±°ë˜ëŸ‰ ê¸‰ë“± ì¡°ê±´ (ë™ì ) ===
    vol_ok = (volume_surge >= eff_surge_min) or (vol_vs_ma >= eff_vol_vs_ma)
    if not vol_ok and not mega:
        return False, f"ê±°ë˜ëŸ‰ë¶€ì¡± surge{volume_surge:.1f}x<{eff_surge_min:.1f}x MA{vol_vs_ma:.1f}x<{eff_vol_vs_ma:.1f}x"

    # === ê°€ê²©ë³€ë™ í•˜í•œ ì»· (ë™ì ) ===
    if price_change < eff_price_min and not mega:
        return False, f"ë³€ë™ë¶€ì¡± {price_change*100:.2f}%<{eff_price_min*100:.2f}%"

    # === íšŒì „ìœ¨ ì»· (ë™ì ) ===
    if turn_pct < eff_turn_min:
        return False, f"íšŒì „ìœ¨ë¶€ì¡± {turn_pct:.1f}%<{eff_turn_min:.1f}%"
    # ğŸ”§ ê³¼íšŒì „ ìƒí•œ (ìŠ¹ 10.2% vs íŒ¨ 26.8% â†’ 20% ìƒí•œ)
    if turn_pct > GATE_TURN_MAX:
        return False, f"ê³¼íšŒì „ {turn_pct:.1f}%>{GATE_TURN_MAX:.0f}%"
    # ğŸ”§ CRITICAL: ê³¼íšŒì „ + ìŠ¤í”„ë ˆë“œ ë„“ìŒ = ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜
    # ğŸ”§ HOTFIX: ì €ê°€ ì½”ì¸ ìŠ¤í”„ë ˆë“œ í—ˆìš© (0.25%â†’1.0%)
    if turn_pct > 50 and spread > 1.0:
        return False, f"ê³¼íšŒì „+ìŠ¤í”„ë ˆë“œ íšŒì „{turn_pct:.0f}%>50% ìŠ¤í”„{spread:.2f}%>1.0%"

    # === ìŠ¤í”„ë ˆë“œ ì»· (ë™ì ) ===
    if spread > eff_spread_max:
        return False, f"ìŠ¤í”„ë ˆë“œê³¼ë‹¤ {spread:.2f}%>{eff_spread_max:.2f}%"

    # === ê³¼ì—´ í•„í„° (ì™„í™” ì—†ìŒ - ì•ˆì „ì¥ì¹˜) ===
    overheated = accel * volume_surge
    if overheated > GATE_OVERHEAT_MAX:
        return False, f"ê³¼ì—´ {overheated:.1f}>{GATE_OVERHEAT_MAX}"

    # === ê°€ì†ë„ ì»· (ë™ì ) ===
    if accel < eff_accel_min:
        return False, f"ê°ì†ì¤‘ ê°€ì†{accel:.1f}x<{eff_accel_min:.1f}x"
    if accel > GATE_ACCEL_MAX:
        return False, f"ê°€ì†ê³¼ë‹¤ {accel:.1f}x>{GATE_ACCEL_MAX}x"

    # === ë§¤ìˆ˜ë¹„ ì»· (ë™ì ) ===
    if buy_ratio < eff_buy_min:
        return False, f"ë§¤ìˆ˜ë¹„ë¶€ì¡± {buy_ratio:.0%}<{eff_buy_min:.0%}"

    # === ë§¤ìˆ˜ë¹„ 100% ì»· (ìŠ¤í‘¸í•‘ ì˜ì‹¬ - ì™„í™” ì—†ìŒ) ===
    if abs(buy_ratio - 1.0) < 1e-6:
        return False, "ë§¤ìˆ˜ë¹„100%(ìŠ¤í‘¸í•‘)"

    # === ê¸‰ë“± ì»· (ì™„í™” ì—†ìŒ - ì•ˆì „ì¥ì¹˜) ===
    if volume_surge > GATE_SURGE_MAX:
        return False, f"ê¸‰ë“±ê³¼ë‹¤ {volume_surge:.1f}x>{GATE_SURGE_MAX}x"

    # === í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì»· (ë™ì ) ===
    if imbalance < eff_imb_min:
        return False, f"í˜¸ê°€ê· í˜•ì·¨ì•½ ì„ë°¸{imbalance:.2f}<{eff_imb_min:.2f}"

    # === ì§„ì… ì‹ í˜¸ ì²´í¬ (ë™ì ) ===
    # ëŒíŒŒ ì ìˆ˜: EMA20 ëŒíŒŒ + ê³ ì  ëŒíŒŒ
    breakout_score = int(ema20_breakout) + int(high_breakout)

    # ğŸ”§ ê°•ëŒíŒŒ ì „ìš© ê°•í™” ì„ê³„ì¹˜ (ì¼ë°˜ë³´ë‹¤ ë¹¡ì„¸ê²Œ)
    if breakout_score == 2 and not GATE_STRONGBREAK_OFF:
        # íšŒì „ìœ¨ ìƒí•œ ê°•í™”
        if turn_pct > GATE_STRONGBREAK_TURN_MAX:
            return False, f"ê°•ëŒíŒŒ+ê³¼íšŒì „ {turn_pct:.1f}%>{GATE_STRONGBREAK_TURN_MAX:.0f}%"
        # ê°€ì†ë„ ìƒí•œ ê°•í™”
        if accel > GATE_STRONGBREAK_ACCEL_MAX:
            return False, f"ê°•ëŒíŒŒ+ê³¼ì† {accel:.1f}x>{GATE_STRONGBREAK_ACCEL_MAX:.1f}x"
    elif GATE_STRONGBREAK_OFF and breakout_score == 2:
        return False, f"ê°•ëŒíŒŒì°¨ë‹¨ EMAëŒíŒŒ+ê³ ì ëŒíŒŒ ë™ì‹œ (ìŠ¹ë¥ 21%)"

    # ì§„ì… ì¡°ê±´: ëŒíŒŒ 1ê°œ OR vol_vs_ma OR ì í™” 4ì  (4/4 ëª¨ë‘ ì¶©ì¡±)
    # ğŸ”§ 4â†’3 ì™„í™”: ê°œë³„ì¡°ê±´ ê°•í™”ë¡œ 3ì ë„ í­ë°œì  ê¸‰ë“± ì‹ í˜¸
    entry_signal = (breakout_score >= 1) or (vol_vs_ma >= eff_vol_vs_ma) or (ignition_score >= 3)

    if not entry_signal:
        return False, f"ì§„ì…ì¡°ê±´ë¯¸ë‹¬ EMAëŒíŒŒ={ema20_breakout} ê³ ì ëŒíŒŒ={high_breakout} MA{vol_vs_ma:.1f}x"

    # === í†µê³¼ ===
    # ì‹ í˜¸ íƒ€ì… í‘œì‹œ (ì í™” / ê°•ëŒíŒŒ / EMAâ†‘ / ê³ ì â†‘ / ê±°ë˜ëŸ‰â†‘)
    if is_ignition:
        signal_tag = "ğŸ”¥ì í™”"
    elif breakout_score == 2:
        signal_tag = "ê°•ëŒíŒŒ (EMAâ†‘+ê³ ì â†‘)"
    elif ema20_breakout:
        signal_tag = "EMAâ†‘"
    elif high_breakout:
        signal_tag = "ê³ ì â†‘"
    else:
        signal_tag = "ê±°ë˜ëŸ‰â†‘"

    # í†µê³¼ ì‹œ ì£¼ìš” ì§€í‘œë§Œ ê°„ëµ í‘œì‹œ
    pass_summary = f"ë§¤ìˆ˜{buy_ratio:.0%} íšŒì „{turn_pct:.1f}% ì„ë°¸{imbalance:.2f}"
    return True, f"{signal_tag} PASS | {pass_summary}"


# =========================
# ğŸ”§ ë ˆì§ í•„í„° (íš¡ë³´ì¥ ì§„ì… ì°¨ë‹¨)
# =========================
def is_sideways_regime(c1, lookback=20):
    """
    íš¡ë³´ì¥ íŒì •: ìµœê·¼ Në´‰ì˜ ê³ ì € ë²”ìœ„ê°€ ì¢ìœ¼ë©´ íš¡ë³´
    - ë³€ë™í­ 1.5% ë¯¸ë§Œ = íš¡ë³´
    - íš¡ë³´ì¥ì—ì„œ ëŒíŒŒ ì‹ í˜¸ëŠ” í˜ì´í¬ í™•ë¥  ë†’ìŒ
    """
    if len(c1) < lookback:
        return False, 0.0

    candles = c1[-lookback:]
    highs = [c["high_price"] for c in candles]
    lows = [c["low_price"] for c in candles]

    box_high = max(highs)
    box_low = min(lows)

    if box_low <= 0:
        return False, 0.0

    range_pct = (box_high - box_low) / box_low

    # ğŸ”§ ê°€ê²©ëŒ€ë³„ íš¡ë³´ íŒì • (ì €ê°€ ì½”ì¸ì€ ë³€ë™ ë‹¨ìœ„ê°€ ì»¤ì„œ ì •ìƒë„ íš¡ë³´ë¡œ ì¡í˜)
    cur_price = candles[-1].get("trade_price", 0)
    if cur_price < 1000:
        sideways_thr = 0.008   # 1000ì› ë¯¸ë§Œ: 0.8%
    else:
        sideways_thr = 0.005   # 1000ì› ì´ìƒ: 0.5%
    is_sideways = range_pct < sideways_thr

    return is_sideways, range_pct


def near_box_boundary(price, c1, lookback=20, threshold=0.98):
    """
    ë°•ìŠ¤ ìƒë‹¨/í•˜ë‹¨ ê·¼ì²˜ íŒì •
    - ë°•ìŠ¤ ìƒë‹¨ ê·¼ì²˜ì—ì„œ ì§„ì…í•˜ë©´ ì €í•­ì— ë§‰í í™•ë¥  ë†’ìŒ
    - threshold=0.98: ìƒë‹¨ì˜ 98% ì´ìƒì´ë©´ "ê·¼ì²˜"ë¡œ íŒì •
    """
    if len(c1) < lookback:
        return False, ""

    candles = c1[-lookback:]
    highs = [c["high_price"] for c in candles]
    lows = [c["low_price"] for c in candles]

    box_high = max(highs)
    box_low = min(lows)

    # ë°•ìŠ¤ ìƒë‹¨ ê·¼ì²˜ (ì €í•­)
    if price >= box_high * threshold:
        return True, "BOX_TOP"

    # ë°•ìŠ¤ í•˜ë‹¨ ê·¼ì²˜ (ì§€ì§€) - ì´ê±´ ì˜¤íˆë ¤ ì¢‹ì„ ìˆ˜ ìˆì–´ì„œ íŒ¨ìŠ¤
    # if price <= box_low * (2 - threshold):
    #     return True, "BOX_BOTTOM"

    return False, ""


def calc_ema_slope(c1, period=20, lookback=5):
    """
    EMA ê¸°ìš¸ê¸° ê³„ì‚°: í‰í‰í•˜ë©´ íš¡ë³´
    - ê¸°ìš¸ê¸° 0.1% ë¯¸ë§Œ = íš¡ë³´
    """
    if len(c1) < period + lookback:
        return 0.0

    closes = [c["trade_price"] for c in c1]

    # EMA ê³„ì‚°
    mult = 2 / (period + 1)
    ema = closes[0]
    for p in closes[1:]:
        ema = p * mult + ema * (1 - mult)
    ema_now = ema

    # lookback ì „ EMA
    ema_prev = closes[0]
    for p in closes[1:-lookback]:
        ema_prev = p * mult + ema_prev * (1 - mult)

    if ema_prev <= 0:
        return 0.0

    slope = (ema_now - ema_prev) / ema_prev
    return slope


def regime_filter(m, c1, cur_price):
    """
    í†µí•© ë ˆì§ í•„í„°: íš¡ë³´ì¥/ë°•ìŠ¤ìƒë‹¨ì´ë©´ ì§„ì… ì°¨ë‹¨
    Returns: (pass: bool, reason: str)
    """
    # 1) íš¡ë³´ íŒì •
    is_sw, range_pct = is_sideways_regime(c1, lookback=20)
    if is_sw:
        return False, f"SIDEWAYS({range_pct*100:.1f}%)"

    # 2) ë°•ìŠ¤ ìƒë‹¨ ê·¼ì²˜ íŒì • - ğŸ”§ ë¹„í™œì„±í™” (ëŒíŒŒ ì „ëµì—ì„œ ê³ ì  ì§„ì…ì€ ì •ìƒ)
    # near_box, box_pos = near_box_boundary(cur_price, c1, lookback=20)
    # if near_box and box_pos == "BOX_TOP":
    #     return False, "BOX_TOP"

    # 3) EMA ê¸°ìš¸ê¸° íŒì • (ì„ íƒì )
    slope = calc_ema_slope(c1, period=20, lookback=5)
    if abs(slope) < 0.001:  # 0.1% ë¯¸ë§Œ
        # íš¡ë³´ + ê¸°ìš¸ê¸° í‰í‰ = ê°•í•œ íš¡ë³´ ì‹ í˜¸
        # í•˜ì§€ë§Œ ë‹¤ë¥¸ ì¡°ê±´ í†µê³¼í–ˆìœ¼ë©´ ì¼ë‹¨ í—ˆìš©
        pass

    return True, "OK"


# === ğŸ”§ í‹±ë²„ìŠ¤íŠ¸ í—ˆìš© íŒë‹¨ (ë¹„í™œì„±í™”ë¨) ===
def detect_leader_stock(m, obc, c1, tight_mode=False):
    """
    í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… íƒì§€ ì—”ì§„:
      - Probe(ì†Œì•¡): ì™„í™”ëœ early íë¦„ ê°ì§€ â†’ ì´ˆê¸° ì—¼íƒ ì§„ì…
      - Confirm(ì¶”ì„¸): ê°•í•œ ì í™”/ë§¤ì§‘/ëŒíŒŒ â†’ í™•ì • ì§„ì…
    """
    if len(c1) < 3:
        return None

    # === ğŸ”§ ìŠ¤í…Œì´ë¸”ì½”ì¸ ì°¨ë‹¨ (USDT, USDC ë“± ê°€ê²©ë³€ë™ ì—†ëŠ” ì½”ì¸) ===
    if any(stable in m.upper() for stable in ["USDT", "USDC", "DAI", "TUSD", "BUSD"]):
        cut("STABLECOIN", f"{m} ìŠ¤í…Œì´ë¸”ì½”ì¸ ì œì™¸")
        return None

    # === ğŸ”§ ë ˆì§ í•„í„°: íš¡ë³´ì¥/ë°•ìŠ¤ìƒë‹¨ ì§„ì… ì°¨ë‹¨ ===
    cur_price = c1[-1]["trade_price"] if c1 else 0
    regime_ok, regime_reason = regime_filter(m, c1, cur_price)
    if not regime_ok:
        cut("REGIME_FILTER", f"{m} {regime_reason}")
        return None

    # === ë™ì¼ ì¢…ëª© ì¤‘ë³µ ì§„ì… ë°©ì§€ (í¬ì§€ì…˜ ë³´ìœ  ì‹œ ìŠ¤í‚µ) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if pos:
            # ğŸ”§ FIX: ë½ ë‚´ë¶€ì—ì„œ ì²´í¬í•´ì•¼ race condition ë°©ì§€
            return None

    # === í‹± ê¸°ë°˜ ì´ˆë´‰(10ì´ˆ) ì„ í–‰ ì§„ì… ì‹œê·¸ë„ ===
    # ğŸ”§ ë¹„í™œì„±í™”: tick_burst ê²½ë¡œ ì œê±° (normal ê²½ë¡œë¡œ í†µí•©)
    # - probe ì§„ì… í›„ ë³¸ì§„ì… ì „ëµì´ ì‹¤ì œë¡œ íš¨ê³¼ ì—†ìŒ
    # - tick_burst vs normal ì„ê³„ì¹˜ê°€ ê±°ì˜ ë™ì¼í•´ì„œ ë¶„ë¦¬ ì˜ë¯¸ ì—†ìŒ
    # ticks_now = get_recent_ticks(m, 80)
    # if ticks_now: ... (ì „ì²´ tick_burst ë¡œì§ ë¹„í™œì„±í™”)

    # (ì´í•˜ ê¸°ì¡´ detect_leader_stock ì½”ë“œ ê³„ì†)

    ob = obc.get(m)
    if not ob or not isinstance(ob.get("raw"), dict):
        return None
    if not ob.get("raw", {}).get("orderbook_units"):
        return None
    if ob.get("depth_krw", 0) <= 0:
        return None

    mega = is_mega_breakout(c1)
    th = get_dynamic_thresholds()
    cur, prev = c1[-1], c1[-2]
    # ğŸ”§ FIX: ê³ ê°€ ê¸°ì¤€ íŒí”„ ê°ì§€ ì¶”ê°€ (ì¢…ê°€ë§Œ ë³´ë©´ ìœ—ê¼¬ë¦¬ íŒí”„ ë†“ì¹¨)
    price_change_close = (cur["trade_price"] / max(prev["trade_price"], 1) - 1)
    cur_high = cur.get("high_price", cur["trade_price"])
    pump_move = (cur_high / max(prev["trade_price"], 1) - 1)
    # ê°€ì¤‘ í•©ì‚°: ê³ ê°€ ê¸°ì¤€ 70% ë°˜ì˜ (íŒí”„ ì´ˆë°˜ ê°ì§€)
    price_change = max(price_change_close, pump_move * 0.7)

    # ğŸ”§ SPREAD_HIGH, VOL_LOW, SURGE_LOW, PRICE_LOW â†’ stage1_gateë¡œ ì´ë™
    # ê±°ë˜ëŸ‰ ë°ì´í„° (stage1_gateì—ì„œ ì‚¬ìš©)
    current_volume = cur.get("candle_acc_trade_price", 0)
    past_volumes = [c["candle_acc_trade_price"] for c in c1[-7:-2] if c["candle_acc_trade_price"] > 0]

    # í‹± í™•ë³´
    ticks = get_recent_ticks(m, 100)
    if not ticks:
        cut("TICKS_LOW", f"{m} no ticks")
        return None

    # ğŸ”¥ í‰ì‹œ TPS ì—…ë°ì´íŠ¸ (ì í™” ê°ì§€ìš©)
    update_baseline_tps(m, ticks)

    # === í…Œì´í”„ ì§€í‘œ (stage1_gateìš©) ===
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    t45 = micro_tape_stats_from_ticks(ticks, 45)
    twin = t15 if t15["krw_per_sec"] >= t45["krw_per_sec"] else t45
    turn = twin["krw"] / max(ob["depth_krw"], 1)

    # ğŸ”¥ 1ë‹¨ê³„ ê²Œì´íŠ¸ ì ìš© (ë‹¨ì¼ í†µí•© í•„í„°)
    # ğŸ”§ FIX: SMA â†’ EMA ê¸°ë°˜ vol_surge (íŒí”„ ì´ˆë°˜ ë” ë¹ ë¥¸ ë°˜ì‘)
    if past_volumes and len(past_volumes) >= 3:
        vol_ema = ema_last(past_volumes, min(len(past_volumes), 10))
        vol_surge_ema = current_volume / max(vol_ema, 1) if vol_ema else 1.0
        # 3ë¶„ ëˆ„ì  ë¹„êµ ì¶”ê°€ (c1[-4:-1] vs ê³¼ê±° í‰ê· )
        if len(c1) >= 6:
            sum_3 = sum(c["candle_acc_trade_price"] for c in c1[-3:])
            past_sums = []
            for i in range(max(0, len(c1)-15), len(c1)-3):
                if i >= 2:
                    s = sum(c["candle_acc_trade_price"] for c in c1[i-2:i+1])
                    past_sums.append(s)
            vol_surge_3m = (sum_3 / statistics.mean(past_sums)) if past_sums else vol_surge_ema
            vol_surge = max(vol_surge_ema, vol_surge_3m * 0.8)
        else:
            vol_surge = vol_surge_ema
    else:
        vol_surge = current_volume / max(current_volume / 8, 1)
    accel = calc_flow_acceleration(ticks)
    turn_pct = turn * 100  # decimal â†’ %
    imbalance = calc_orderbook_imbalance(ob)
    fresh_ok, fresh_age, fresh_max_age = last_two_ticks_fresh(ticks, return_age=True)

    # ğŸ”¥ ì„€ë„ìš° ëª¨ë“œìš© ì§€í‘œ ë¯¸ë¦¬ ê³„ì‚°
    ia = inter_arrival_stats(ticks, 60)  # ğŸ”§ 30â†’60ì´ˆ (CV 9.9 ê¸°ë³¸ê°’ ë°©ì§€)
    cv = ia["cv"]
    pstd10 = price_band_std(ticks, 10)
    if pstd10 is None:
        pstd10 = 9.9  # ë°ì´í„° ë¶€ì¡±ì‹œ ê¸°ë³¸ê°’ (í•˜ë“œì»· ì¡°ê±´ íšŒí”¼)
    cons_buys = calc_consecutive_buys(ticks, 15)
    overheat = accel * vol_surge
    spread = ob.get("spread", 9.9)

    # ğŸ›‘ í•˜ë“œ ì»·: ê·¹ë‹¨ ìŠ¤í‘¸í•‘ íŒ¨í„´ (í™•ì‹  êµ¬ê°„ë§Œ ì°¨ë‹¨)
    # buy_ratio >= 0.98 AND pstd <= 0.001 AND CV >= 2.5
    if twin["buy_ratio"] >= 0.98 and pstd10 <= 0.001 and cv >= 2.5:
        cut("FAKE_FLOW_HARD", f"{m} buy{twin['buy_ratio']:.2f} pstd{pstd10:.4f} cv{cv:.2f}")
        return None

    # ğŸ” ì„€ë„ìš° íƒœê¹… (ì‹¤ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, íƒœê·¸ë§Œ ê¸°ë¡)
    shadow_flags = []
    if cv > 2.2:
        shadow_flags.append("CV22")
    if turn_pct >= 12 and (cons_buys > 18 or overheat > 3):
        shadow_flags.append("TURNxCONS/HEAT")
    if accel >= 3.0 and not (imbalance >= 0.40 and spread <= 0.12):
        shadow_flags.append("ACCEL_WEAK_CTX")
    would_cut = len(shadow_flags) > 0

    # ğŸ”§ ë°ì´í„° ê¸°ë°˜ í•„í„°: ì—°ì†ë§¤ìˆ˜, CV (ìŠ¹ë¥  ë¶„ì„ ê²°ê³¼)
    # ì—°ì†ë§¤ìˆ˜ í•˜í•œ (ìŠ¹ 8.0 vs íŒ¨ 4.43 â†’ 6 ì´ìƒë§Œ)
    if cons_buys < GATE_CONSEC_MIN:
        cut("CONSEC_LOW", f"{m} ì—°ì†ë§¤ìˆ˜{cons_buys}<{GATE_CONSEC_MIN} (ìˆ˜ê¸‰ ë¯¸í™•ì¸)")
        return None
    if cons_buys > GATE_CONSEC_MAX:
        cut("CONSEC_HIGH", f"{m} ì—°ì†ë§¤ìˆ˜{cons_buys}>{GATE_CONSEC_MAX} (ì¶”ê²©ë§¤ìˆ˜ ìœ„í—˜)")
        return None
    if cv > GATE_CV_MAX:
        cut("CV_HIGH", f"{m} CV{cv:.2f}>{GATE_CV_MAX} (ë³€ë™ì„± ê³¼ì—´)")
        return None

    # ğŸš€ ì‹ ê·œ ì¡°ê±´ ê³„ì‚°: EMA20 ëŒíŒŒ, ê³ ì  ëŒíŒŒ, ê±°ë˜ëŸ‰ MA ëŒ€ë¹„
    cur_price = cur["trade_price"]
    cur_high = cur.get("high_price", cur_price)  # ğŸ”§ í˜„ì¬ë´‰ ê³ ê°€
    closes = [x["trade_price"] for x in c1]
    ema20 = ema_last(closes, 20) if len(closes) >= 20 else None
    ema20_breakout = (ema20 is not None and cur_price > ema20)

    # ğŸ”§ FIX: ê³ ì  ëŒíŒŒ - ìœ—ê¼¬ë¦¬ ì˜¤íƒ ë°©ì§€ (ì í™” ì•„ë‹ ë•ŒëŠ” ì¢…ê°€ í™•ì¸)
    prev_high = prev_high_from_candles(c1, lookback=12, skip_recent=1)
    high_breakout_wick = (prev_high > 0 and cur_high > prev_high)  # ê³ ê°€ ê¸°ì¤€ (ìœ… í¬í•¨)
    high_breakout_close = (prev_high > 0 and cur_price > prev_high * 1.0005)  # ì¢…ê°€ ê¸°ì¤€ (0.05% ë²„í¼)

    vol_ma20 = vol_ma_from_candles(c1, period=20)
    vol_vs_ma = current_volume / max(vol_ma20, 1) if vol_ma20 > 0 else 0.0

    # ğŸ”¥ ì í™” ê°ì§€ ì ìˆ˜ ê³„ì‚° (stage1_gateì— ì „ë‹¬)
    _, ignition_reason, ignition_score = ignition_detected(
        market=m,
        ticks=ticks,
        avg_candle_volume=vol_ma20,
        ob=ob,
        cooldown_ms=15000
    )

    # ğŸ”§ FIX: ì í™” ê°•í•  ë•Œë§Œ ìœ… í—ˆìš©, ì•„ë‹ˆë©´ ì¢…ê°€ í™•ì¸ (ìœ—ê¼¬ë¦¬ ì˜¤íƒ ë°©ì§€)
    if ignition_score >= 3:
        high_breakout = high_breakout_wick  # ì í™” ì‹œ ê³ ê°€ ê¸°ì¤€ í—ˆìš©
    else:
        high_breakout = high_breakout_close  # ë¹„ì í™” ì‹œ ì¢…ê°€ í™•ì¸ í•„ìˆ˜

    # === ğŸ”¥ BTC ì—­í’ ê°€ë“œ (ê²Œì´íŠ¸ í†µê³¼ í›„ ì¶”ê°€ ìš”ê±´ ì²´í¬) ===
    btc5 = btc_5m_change()
    btc_headwind = btc5 <= -0.003  # -0.3%

    gate_ok, gate_reason = stage1_gate(
        spread=ob["spread"],
        accel=accel,
        volume_surge=vol_surge,
        turn_pct=turn_pct,
        buy_ratio=twin["buy_ratio"],
        imbalance=imbalance,
        fresh_ok=fresh_ok,
        fresh_age=fresh_age,
        fresh_max_age=fresh_max_age,
        current_volume=current_volume,
        price_change=price_change,
        mega=mega,
        # ğŸš€ ì‹ ê·œ íŒŒë¼ë¯¸í„°
        ema20_breakout=ema20_breakout,
        high_breakout=high_breakout,
        vol_vs_ma=vol_vs_ma,
        ignition_score=ignition_score,
        best_ask_krw=ob.get("best_ask_krw", 0),  # ğŸ”§ FIX (C): í˜¸ê°€ê¹Šì´ ê¸°ë°˜ ìŠ¤í”„ë ˆë“œ ì œí•œ
        cur_price=cur["trade_price"],  # ğŸ”§ ìŠ¤í”„ë ˆë“œ ê°€ê²©ëŒ€ë³„ ë¶„ë¦¬ìš©
    )
    if not gate_ok:
        # STAGE1_GATEëŠ” í…”ë ˆê·¸ë¨ ì•ŒëŒ ì „ì— ì»·ë˜ë¯€ë¡œ near_miss=False
        cut("STAGE1_GATE", f"{m} {gate_reason}", near_miss=False)
        return None

    # ğŸ”¥ BTC ì—­í’ ì‹œ ì¶”ê°€ ìš”ê±´ ì²´í¬ (ê²Œì´íŠ¸ í†µê³¼ í›„)
    if btc_headwind:
        headwind_fail = []
        if accel < 0.1:
            headwind_fail.append(f"accel={accel:.2f}<0.1")
        if turn_pct < 1.5:
            headwind_fail.append(f"turn={turn_pct:.2f}<1.5")
        if twin["buy_ratio"] < 0.55:
            headwind_fail.append(f"buy_ratio={twin['buy_ratio']:.2f}<0.55")

        if headwind_fail:
            cut("BTC_HEADWIND", f"{m} BTCì—­í’({btc5*100:.2f}%) ì¶”ê°€ìš”ê±´ ë¯¸ë‹¬: {', '.join(headwind_fail)}", near_miss=False)
            return None
        print(f"[BTC_HEADWIND] {m} BTC 5ë¶„ {btc5*100:.2f}% â†’ ì¶”ê°€ìš”ê±´ í†µê³¼")

    # === ê²°ê³¼ íŒ¨í‚¤ì§• ===
    # ğŸ”¥ signal_tag ì¶”ì¶œ (gate_reason: "{signal_tag} PASS | {metrics}")
    signal_tag = gate_reason.split(" PASS")[0] if " PASS" in gate_reason else "ê¸°ë³¸"

    pre = {
        "price": cur["trade_price"],
        "change": price_change,
        "current_volume": current_volume,
        "volume_surge": vol_surge,
        "ob": ob,
        "tape": twin,
        "ticks": ticks,
        "flow_accel": accel,
        "imbalance": imbalance,
        "turn_pct": turn_pct,
        "spread": ob["spread"],
        "buy_ratio": twin["buy_ratio"],
        "fresh_ok": fresh_ok,  # ğŸ”§ CRITICAL: fresh_ok ì „ë‹¬ (ìŠ¤ì½”ì–´ ê³„ì‚°ìš©)
        "mega": mega,
        "filter_type": "stage1_gate",
        "ignition_score": ignition_score,
        "gate_reason": gate_reason,
        # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ í†µì¼ (ì í™”3, EMAâ†‘, ê³ ì â†‘, ê±°ë˜ëŸ‰â†‘ ë“±)
        "signal_tag": signal_tag,
        # ğŸ” ì„€ë„ìš° ëª¨ë“œìš© (ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, ë‚˜ì¤‘ì— ë¶„ì„ìš©)
        "shadow_flags": ",".join(shadow_flags) if shadow_flags else "",
        "would_cut": would_cut,
        "cv": cv,
        "pstd": pstd10,
        "consecutive_buys": cons_buys,
        "overheat": overheat,
    }

    return pre

def final_check_leader(m, pre, tight_mode=False):
    """
    ğŸ”§ ë‹¨ìˆœ íŒ¨ìŠ¤ì“°ë£¨: stage1_gate/prebreakì—ì„œ ëª¨ë“  í•„í„°ë§ ì™„ë£Œ
    í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ëŠ” ìœ ì§€í•˜ë˜, ë°”ë¡œ payload ë°˜í™˜
    """
    t = pre["tape"]
    ob = pre["ob"]

    # Pre-breakëŠ” í‹±ìˆ˜ ì²´í¬ ìŠ¤í‚µ (ì´ë¯¸ ì¡°ê±´ ì¶©ì¡±)
    filter_type = pre.get("filter_type", "stage1_gate")
    if filter_type != "prebreak":
        # ìµœì†Œ í‹±ìˆ˜ë§Œ ì²´í¬ (ì´ê±´ stage1_gate ì „ì— í•„ìš”)
        if t["n"] < MIN_TICKS_COUNT:
            cut("TICKS_LOW", f"{m} {t['n']}")
            return None

    # í•„í„° íƒ€ì…ì— ë”°ë¥¸ í‘œì‹œ: signal_tag ì‚¬ìš©
    if filter_type == "prebreak":
        display_filter = "ğŸš€ì„ í–‰ì§„ì…"
    elif "ì í™”" in pre.get("signal_tag", ""):
        display_filter = "ë¹ ë¥¸ì§„ì…"
    else:
        display_filter = "í†µí•©ê²Œì´íŠ¸"

    # ğŸ”§ FIX: score ê³„ì‚° ë³µì› (calc_risk_score í˜¸ì¶œ)
    buy_ratio = pre.get("buy_ratio", 0.5)
    spread = pre.get("spread", 0.5)
    # ğŸ”§ CRITICAL: turn ë‹¨ìœ„ ë³´ì • (í¼ì„¼íŠ¸ â†’ ì†Œìˆ˜)
    turn = (pre.get("turn_pct", 1.0) or 1.0) / 100.0
    imbalance = pre.get("imbalance", 0.0)
    volume_surge = pre.get("volume_surge", 1.0)
    fresh_ok = pre.get("fresh_ok", True)

    score = calc_risk_score(buy_ratio, spread, turn, imbalance, fresh_ok, volume_surge)

    # í”„ë¦¬ì‹œì „ í¬ì¼“: ì„ë°¸ >= 0.6 AND ë§¤ìˆ˜ë¹„ >= 63.5%
    is_precision = (imbalance >= 0.6 and buy_ratio >= 0.635)

    # === ğŸ”¥ ìŠ¤ì½”ì–´ ê¸°ë°˜ ì§„ì…ëª¨ë“œ ìë™ ë§¤í•‘ (ê¸°ëŒ€ê°’ ìš°ì„ ) ===
    # ğŸ”§ FIX: confirm ë¬¸í„± ìƒí–¥ (70â†’78) - ì†ì‹¤ ë¹ˆë„/í¬ê¸° ê°ì†Œ
    # score < 60: probe (ì†Œì•¡ íƒìƒ‰) â†’ ì¶”ê²© ì§„ì… ë°©ì§€
    # score 60~78: half (ì ˆë°˜)
    # score >= 78: confirm (í’€ ì‚¬ì´ì¦ˆ)
    if score < 60:
        entry_mode = "probe"
    elif score < 78:
        entry_mode = "half"
    else:
        entry_mode = "confirm"

    # ì´ë¯¸ stage1_gate/prebreakì—ì„œ ëª¨ë“  í•„í„°ë§ ì™„ë£Œ
    # ê¸°ì¡´ í˜¸ì¶œ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•´ payload í˜•ì‹ìœ¼ë¡œ ë°˜í™˜
    return {
        "price": pre["price"],
        "chg": round(pre.get("change", 0) * 100, 2),
        "current_volume": int(pre.get("current_volume", 0)),
        "volume_surge": round(pre.get("volume_surge", 0.0), 2),
        "buy": round(pre.get("buy_ratio", 0) * 100, 1),
        "n": t["n"],
        "spread": round(pre.get("spread", 0), 2),
        "turn": round(pre.get("turn_pct", 0), 2),
        "imbalance": round(imbalance, 3),
        "score": score,
        "entry_mode": entry_mode,  # ğŸ”¥ ìŠ¤ì½”ì–´ ê¸°ë°˜ ìë™ ë§¤í•‘
        "is_precision_pocket": is_precision,
        "filter_type": display_filter,
        "is_prebreak": filter_type == "prebreak",
    }


# =========================
# === [DL LOGGING]
# =========================
LOG_PATH = os.path.join(os.getcwd(), os.getenv("DL_LOG_PATH",
                                               "signals_log.csv"))
_CSV_LOCK = threading.Lock()

DL_FIELDS = [
    "ts", "market", "entry_price", "chg_1m", "chg_5m", "chg_15m", "zscore_1m",
    "vwap_gap", "t15_buy", "t15_n", "t15_rate", "t15_krw", "turn", "spread",
    "depth_krw", "bidask_ratio", "volume_surge", "btc_1m", "btc_5m", "hour",
    "dow", "two_green_break", "ignition_ok", "early_ok", "uptick_ok",
    # ğŸ”¥ ìƒˆ ì§€í‘œ ì¶”ê°€
    "consecutive_buys", "avg_krw_per_tick", "flow_acceleration",
    # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ ì¶”ê°€
    "imbalance", "overheat", "fresh_age",
    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ì¶”ê°€
    "cv", "pstd", "best_ask_krw", "prebreak_band", "is_prebreak",
    "ret_3m", "ret_10m", "ret_15m", "maxdd_10m", "maxrun_10m", "label_win10",
    "label_fail10"
]


def append_csv(row: dict):
    with _CSV_LOCK:
        new = not os.path.exists(LOG_PATH)
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=DL_FIELDS)
            if new: w.writeheader()
            for k in DL_FIELDS:
                if k not in row: row[k] = ""
            w.writerow(row)


def snapshot_row(m, entry_price, payload, pre, c1, ob, t15, btc1m, btc5m,
                 flags):
    try:
        raw_ob = ob["raw"]["orderbook_units"][:3]
        bid_sum = sum(u["bid_size"] * u["bid_price"] for u in raw_ob)
        ask_sum = sum(u["ask_size"] * u["ask_price"] for u in raw_ob)
        bidask_ratio = bid_sum / max(ask_sum, 1)
    except:
        bidask_ratio = 0.0

    # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°
    ticks = pre.get("ticks", [])
    cons_buys = calc_consecutive_buys(ticks, 15)
    avg_krw = calc_avg_krw_per_tick(t15)
    flow_accel = calc_flow_acceleration(ticks)

    # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
    imbalance = pre.get("imbalance", 0.0)
    overheat = flow_accel * float(payload.get("volume_surge", 1.0))  # accel * surge
    # í‹± ì‹ ì„ ë„: ë§ˆì§€ë§‰ í‹± ë‚˜ì´ (ì´ˆ)
    fresh_age = 0.0
    if ticks:
        now_ms = int(time.time() * 1000)
        last_tick_ts = ticks[0].get("timestamp", now_ms)
        fresh_age = (now_ms - last_tick_ts) / 1000.0

    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
    ia_stats = inter_arrival_stats(ticks, 30) if ticks else {"cv": 0.0}
    cv = ia_stats.get("cv", 0.0)
    pstd = price_band_std(ticks, sec=10) if ticks else None
    pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬
    prebreak_band = dynamic_prebreak_band(ticks) if ticks else PREBREAK_HIGH_PCT
    is_prebreak = 1 if pre.get("filter_type") == "prebreak" else 0
    # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
    try:
        u0 = ob.get("raw", {}).get("orderbook_units", [])[0]
        best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
    except Exception:
        best_ask_krw = 0.0

    row = {
        "ts": now_kst_str(),
        "market": m,
        "entry_price": int(entry_price),
        "chg_1m": round(flags.get("chg_1m", 0.0), 4),
        "chg_5m": flags.get("chg_5m", ""),
        "chg_15m": flags.get("chg_15m", ""),
        "zscore_1m": flags.get("zscore", ""),
        "vwap_gap": flags.get("vwap_gap", ""),
        "t15_buy": round(t15.get("buy_ratio", 0.0), 4),
        "t15_n": t15.get("n", 0),
        "t15_rate": round(t15.get("rate", 0.0), 4),
        "t15_krw": int(t15.get("krw", 0)),
        "turn": flags.get("turn", ""),
        "spread": payload.get("spread", ""),
        "depth_krw": ob.get("depth_krw", ""),
        "bidask_ratio": round(bidask_ratio, 3),
        "volume_surge": payload.get("volume_surge", ""),
        "btc_1m": btc1m,
        "btc_5m": btc5m,
        "hour": now_kst().hour,
        "dow": now_kst().weekday(),
        "two_green_break": 1 if flags.get("two_green_break") else 0,
        "ignition_ok": 1 if flags.get("ign_ok") else 0,
        "early_ok": 1 if flags.get("early_ok") else 0,
        "uptick_ok": 1 if flags.get("uptick_ok") else 0,
        # ğŸ”¥ ìƒˆ ì§€í‘œ
        "consecutive_buys": cons_buys,
        "avg_krw_per_tick": round(avg_krw, 0),
        "flow_acceleration": round(flow_accel, 2),
        # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
        "cv": round(cv, 2),
        "pstd": round(pstd * 100, 4),  # % ë‹¨ìœ„
        "best_ask_krw": int(best_ask_krw),
        "prebreak_band": round(prebreak_band * 100, 2),  # % ë‹¨ìœ„
        "is_prebreak": is_prebreak,
        # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
        "imbalance": round(imbalance, 3),
        "overheat": round(overheat, 2),
        "fresh_age": round(fresh_age, 2),
        "ret_3m": "",
        "ret_10m": "",
        "ret_15m": "",
        "maxdd_10m": "",
        "maxrun_10m": "",
        "label_win10": "",
        "label_fail10": ""
    }
    return row


# =========================
# í¬ìŠ¤íŠ¸ì²´í¬ 6ì´ˆ
# =========================
from collections import deque


def postcheck_6s(m, pre):
    # ğŸ”¥ ì í™” ì§„ì…ì€ í¬ìŠ¤íŠ¸ì²´í¬ ë°”ì´íŒ¨ìŠ¤ (signal_tagì— "ì í™”" í¬í•¨ ì‹œ)
    is_ignition = "ì í™”" in pre.get("signal_tag", "")
    # âœ… FIX: tick-burst ê²½ë¡œ ì œê±°ì— ë§ì¶° ì•ˆì „ ê¸°ë³¸ê°’ (NameError ë°©ì§€)
    is_tick_burst = "í‹±ë²„ìŠ¤íŠ¸" in pre.get("signal_tag", "")

    if not POSTCHECK_ENABLED:
        return True, "SKIP"
    # ğŸ”¥ ì í™” ì§„ì…ì€ ë°”ì´íŒ¨ìŠ¤
    if is_ignition:
        return True, "BYPASS_IGNITION"
    if pre.get("ign_ok") or pre.get("two_green_break") or pre.get(
            "mega_ok", False):
        return True, "BYPASS_STRONG_BREAK"

    # â˜…â˜…â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
    r = relax_knob()
    pc_min_buy = max(0.46, POSTCHECK_MIN_BUY - 0.05 * r)   # 0.48 -> 0.46, ì™„í™”í­ ì‚´ì§â†‘
    pc_min_rate = max(0.14, POSTCHECK_MIN_RATE - 0.09 * r) # 0.16 -> 0.14
    pc_max_pstd = POSTCHECK_MAX_PSTD + 0.0005 * r          # ì‚´ì§ ë” ê´€ëŒ€
    pc_max_cv = POSTCHECK_MAX_CV + 0.18 * r
    pc_max_dd = POSTCHECK_MAX_DD + 0.005 * r

    window = POSTCHECK_WINDOW_SEC
    start = time.time()
    acc = deque(maxlen=400)  # ëˆ„ìˆ˜ ë°©ì§€
    seen = set()  # ì¤‘ë³µ ì°¨ë‹¨

    last_fetch = 0.0
    net_calls = 0  # â˜… ì´ë²ˆ postcheckì—ì„œ ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜
    # ë°¤ì—ëŠ” ì¡°ê¸ˆ ëŠìŠ¨, ì£¼ê°„ì—” ì•½ê°„ ë¹ ë¥´ê²Œ
    fetch_interval = 2.0 if (0 <= now_kst().hour < 6) else 1.6
    ok_streak = 0

    base_price = pre["price"]
    peak = base_price
    trough_after_peak = base_price  # í”¼í¬ ì´í›„ ìµœì €ê°€ ì¶”ì 

    # â˜…â˜…â˜… ì—¬ê¸° í•œ ì¤„ ì¶”ê°€ (postcheck ì¤‘ ìµœëŒ€ í—ˆìš© ê¸‰ë“±)
    # ğŸ”¥ í‹±ë²„ìŠ¤íŠ¸ëŠ” ë” ë³´ìˆ˜ì ìœ¼ë¡œ (1.0%), ì¼ë°˜ ê²½ë¡œëŠ” 1.5%
    MAX_SURGE = 0.010 if is_tick_burst else 0.015

    while True:
        now = time.time()
        if now - start > window:
            break

        # ìºì‹œ ì¬ì‚¬ìš© + ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜ ì œí•œ
        if (now - last_fetch >= fetch_interval) and (net_calls < 2):
            # ìµœëŒ€ 2ë²ˆê¹Œì§€ë§Œ ì‹¤ì œ API í˜¸ì¶œ
            ticks = get_recent_ticks(m, 100, allow_network=True)
            last_fetch = now
            net_calls += 1
        else:
            # ë‚˜ë¨¸ì§€ëŠ” ìºì‹œë§Œ ì‚¬ìš©
            ticks = get_recent_ticks(m, 100, allow_network=False)

        if not ticks:
            time.sleep(0.45)
            continue

        # accì— ìµœì‹  í‹±ë§Œ ì¤‘ë³µì—†ì´ ì¶•ì 
        # ğŸ”§ FIX: appendleft ì‚¬ìš© - ìƒˆ í‹±ì„ ì™¼ìª½ì— ì¶”ê°€í•´ì•¼ acc[0]ì´ ìµœì‹  ìœ ì§€
        for x in reversed(ticks[:12]):  # ê³¼ê±°â†’ìµœì‹  ìˆœìœ¼ë¡œ ë°˜ë³µ
            key = (x.get("timestamp"), x.get("trade_price"),
                   x.get("trade_volume"))
            if key in seen:
                continue
            seen.add(key)
            acc.appendleft(x)  # âœ… ìµœì‹ ì´ index 0 ìœ ì§€

        curp = ticks[0].get("trade_price", base_price)

        # â˜…â˜…â˜… ê°€ê²© ê¸‰ë“± ì»· ì¶”ê°€
        if base_price > 0:
            surge = (curp / base_price - 1.0)
            if surge >= MAX_SURGE:
                return False, f"SURGE_IN_POST({surge*100:.2f}%)"

        if curp > peak:
            peak = curp
            trough_after_peak = curp  # ìƒˆ í”¼í¬ê°€ ìƒê¸°ë©´ íŠ¸ë¡œí”„ ë¦¬ì…‹
        else:
            trough_after_peak = min(trough_after_peak, curp)

        # âœ” DDëŠ” í”¼í¬ ëŒ€ë¹„ í•˜ë½ë¥ (ìŒìˆ˜)ë¡œ ì²´í¬
        dd = (curp / peak - 1.0)

        t10 = micro_tape_stats_from_ticks(list(acc), 10)
        ia = inter_arrival_stats(list(acc), 20)
        pstd = price_band_std(list(acc), 20)
        pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬

        # â˜… ê°€ë³€ ì„ê³„ì¹˜ ì ìš©
        pass_now = (t10["buy_ratio"] >= pc_min_buy
                    and t10["rate"] >= pc_min_rate and pstd <= pc_max_pstd
                    and ia["cv"] <= pc_max_cv and dd >= -pc_max_dd)

        if pass_now:
            ok_streak += 1
            if ok_streak >= 2:
                return True, "OK_EARLY"
        else:
            ok_streak = 0

        # í‹±ì´ ì¶©ë¶„íˆ ëŠë¦¬ë©´ ìŠ¬ë¦½ì„ ë” ê¸¸ê²Œ
        time.sleep(0.6 if t10["rate"] >= 0.6 else 1.0)

    if not acc:
        return False, "POST_NO_TICKS"

    # ì¢…ë£Œ ì‹œì  ì¬í‰ê°€ (acc ê¸°ë°˜ìœ¼ë¡œ í”¼í¬/íŠ¸ë¡œí”„ ê³„ì‚°)
    prices = [x.get("trade_price", base_price) for x in list(acc)]
    if prices:
        peak2 = max(prices + [base_price])
        curp2 = prices[0]
        dd2 = (curp2 / peak2 - 1.0)
    else:
        dd2 = 0.0

    t10 = micro_tape_stats_from_ticks(list(acc), 10)
    ia = inter_arrival_stats(list(acc), 20)
    pstd = price_band_std(list(acc), 20)
    pstd = pstd if pstd is not None else 0.0  # None ì„¼í‹°ë„¬ ì²˜ë¦¬

    # â˜… ìµœì¢… íŒì •ë„ ê°€ë³€ ì„ê³„ì¹˜ë¡œ
    if t10["buy_ratio"] < pc_min_buy:
        return False, f"BUY_LOW({t10['buy_ratio']:.2f})"
    if t10["rate"] < pc_min_rate: return False, f"RATE_LOW({t10['rate']:.2f})"
    if pstd > pc_max_pstd: return False, f"PSTD_HIGH({pstd:.4f})"
    if ia["cv"] > pc_max_cv: return False, f"CV_HIGH({ia['cv']:.2f})"
    if dd2 < -pc_max_dd: return False, f"DD_TOO_DEEP({dd2:.4f})"
    return True, "OK"

# =========================
# ğŸ¯ í‹± ê¸°ë°˜ ì†ì ˆ í—¬í¼ í•¨ìˆ˜
# =========================
def upbit_tick_size(price: float) -> float:
    """ì—…ë¹„íŠ¸ KRW ë§ˆì¼“ í˜¸ê°€ ë‹¨ìœ„ (ë³´ìˆ˜ì : 100~1000ì› êµ¬ê°„ì€ 1ì›)"""
    p = float(price)
    if p >= 2_000_000: return 1000.0
    if p >= 1_000_000: return 500.0
    if p >=   500_000: return 100.0
    if p >=   100_000: return 50.0
    if p >=    10_000: return 10.0
    if p >=     1_000: return 5.0
    if p >=       100: return 1.0    # ë³´ìˆ˜ì  (ì¼ë¶€ ì¢…ëª© 0.1ì›ì´ì§€ë§Œ 1ì›ìœ¼ë¡œ)
    if p >=        10: return 0.1
    if p >=         1: return 0.01
    return 0.001

def dynamic_stop_loss(entry_price, c1, signal_type=None, current_price=None):
    atr = atr14_from_candles(c1, ATR_PERIOD)
    if not atr or atr <= 0:
        return entry_price * (1 - STOP_LOSS_PCT), STOP_LOSS_PCT, None

    # ğŸ”§ ATR ë°”ë‹¥ê°’: ë„ˆë¬´ ì‘ìœ¼ë©´ íœ©ì˜ì— í„¸ë¦¼ ë°©ì§€ (ìµœì†Œ 0.05% ë˜ëŠ” í˜¸ê°€ë‹¨ìœ„)
    atr = max(atr, entry_price * 0.0005, upbit_tick_size(entry_price))

    base_pct = (atr / max(entry_price, 1)) * ATR_MULT
    pct = min(max(base_pct, DYN_SL_MIN), DYN_SL_MAX)  # ìë™íŠœë‹ ê°’ ê·¸ëŒ€ë¡œ ì ìš©

    # ğŸš€ ì‹ í˜¸ ìœ í˜•ë³„ ì™„í™”
    if signal_type in ("early", "ign", "mega"):
        pct *= 1.3

    # ğŸ’ ìµì ˆ ì¤‘ì´ë©´ ì†ì ˆí­ ë” ì™„í™” (ëˆŒë¦¼ ë°©ì§€)
    if current_price and current_price > entry_price * 1.008:
        pct *= 1.5  # ìˆ˜ìµ ì¤‘ì—ëŠ” SLì„ ë” ë©€ë¦¬ ë‘ 

    # ATR ìƒì„¸ (í…”ë ˆê·¸ë¨ìš©) - ì†Œìˆ˜ì  2ìë¦¬ë¡œ í‘œì‹œ
    atr_info = f"ATR {atr:.2f}ì›Ã—{ATR_MULT}ë°°"
    return entry_price * (1 - pct), pct, atr_info

# =========================
# ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì²­ì‚° ì ìˆ˜
# =========================
def context_exit_score(m, ticks, ob_depth_krw, entry_price, last_price, c1):
    """
    íœ˜í•‘ ë°©ì§€í˜• ì»¨í…ìŠ¤íŠ¸ ì ìˆ˜:
    - ë‹¨ì¼ ì‹ í˜¸ë¡œ ì²­ì‚° ìœ ë„ ê¸ˆì§€ (ë³µí•© ì¡°ê±´ ëˆ„ì )
    - ì¶”ì„¸ ì—­ì „(EMA5/VWAP ì´íƒˆ + uptick ë¶€ì¬) ìª½ì— ê°€ì¤‘ì¹˜
    """
    score = 0
    reasons = []

    # í…Œì´í”„ ë³€í™”
    w_now = _win_stats(ticks, 0, 10)
    w_early = _win_stats(ticks, 10, 30)
    decay, _ = buy_decay_flag(ticks)

    if w_now["krw_per_sec"] < w_early["krw_per_sec"] * 0.60:
        score += 1
        reasons.append("FLOW_DROP")
    if not uptick_streak_from_ticks(ticks, need=2):
        score += 1
        reasons.append("NO_UPTICK")
    if w_now["rate"] < 0.25:  # ë„ˆë¬´ ëŠë¦¬ë©´ 1ì 
        score += 1
        reasons.append("RATE_SLOW")

    # ê°€ê²©/ì»¨í…ìŠ¤íŠ¸
    vwap = vwap_from_candles_1m(c1, 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in c1], 5) if c1 else 0
    if vwap and last_price < vwap:
        score += 1
        reasons.append("VWAP_LOSS")
    if ema5 and last_price < ema5:
        score += 1
        reasons.append("EMA5_LOSS")

    # ğŸ’ ì•½ìƒìŠ¹/íš¡ë³´ ì‹œ ì²­ì‚° ì ìˆ˜ ì™„í™”
    gain_now = (last_price / entry_price - 1.0)
    if -0.004 <= gain_now <= 0.008:  # ì™„í™” ë²”ìœ„ í™•ëŒ€
        score = max(0, score - 1)
        reasons.append("MILD_GAIN_RELAX")

    # ìˆ˜ìµ êµ¬ê°„ì—ì„œì˜ ê¸‰ê°
    if last_price > entry_price * 1.008 and decay:
        score += 1
        reasons.append("DECAY_AFTER_GAIN")

    return score, reasons

# =========================
# â˜… ëª¨ë‹ˆí„°ë§ ì‹œê°„ ê²°ì • (ì‹ ê·œ ì¶”ê°€)
# =========================
def decide_monitor_secs(pre: dict, tight_mode: bool = False) -> int:
    """
    í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì´ ì‹œê°„(ì´ˆ)ì„ ìƒí™©ë³„ë¡œ ê²°ì •.
    - early_ok: ë¹„êµì  ì§§ê²Œ ì¶”ì„¸ í™•ì¸
    - ignition_ok / mega_ok: ìƒëŒ€ì ìœ¼ë¡œ ê¸¸ê²Œ (ì¶”ì„¸ ì´ì–´ì§ˆ ê°€ëŠ¥ì„±)
    - ì‹œì¥ ëª¨ë“œ(TIGHT), ì•¼ê°„, BTC ëª¨ë©˜í…€, ì˜¤ë”ë¶ ê¹Šì´ ë“±ì— ë”°ë¼ ê°€/ê°
    """
    try:
        r = relax_knob()  # 0.0 ~ 1.5
    except Exception:
        r = 0.0

    base = 150  # ê¸°ë³¸ê°’

    # ì‹ í˜¸ ìœ í˜• ê°€ì¤‘
    if pre.get("mega_ok"):
        base = 300
    elif pre.get("ign_ok"):
        base = 240
    elif pre.get("botacc_ok"):
        base = 210
    elif pre.get("early_ok"):
        base = 180
    elif pre.get("two_green_break"):
        base = 210

    # ì˜¤ë”ë¶ ê¹Šì´ ê¸°ë°˜ (ê¹Šìœ¼ë©´ ì—¬ìœ  ìˆê²Œ)
    ob_depth = 0
    try:
        ob_depth = pre.get("ob", {}).get("depth_krw", 0) or 0
    except Exception:
        pass
    if ob_depth >= 30_000_000:
        base += 30
    elif ob_depth <= 6_000_000:
        base -= 30

    # BTC 5ë¶„ ëª¨ë©˜í…€
    try:
        b5 = btc_5m_change()
    except Exception:
        b5 = 0.0
    if b5 >= 0.006:
        base += 30
    elif b5 <= -0.008:
        base -= 30

    # ì•¼ê°„(00~06 KST)ì—” í”ë“¤ë¦¼ ëŒ€ë¹„ ì•½ê°„ ë‹¨ì¶•
    h = now_kst().hour
    if 0 <= h < 6:
        base -= 15

    # ì¥ì„¸ ì™„í™” ë…¸ë¸Œ ë°˜ì˜
    base += int(10 * r)

    # íƒ€ì´íŠ¸ ëª¨ë“œ(ê¸‰ë½ ë°©ì–´)ë©´ ë‹¨ì¶•
    if tight_mode:
        base -= 30

    # í•˜í•œ/ìƒí•œ í´ë¨í”„
    base = max(90, min(base, 360))
    return int(base)


# =========================
# ëì•ŒëŒ ê¶Œê³  ìƒì„± (END RECO)
# =========================
def _end_reco(entry_price, last_price, c1, ticks, ob_depth_krw, ctx_thr=3):
    """
    ëì•ŒëŒìš© ê¶Œê³  ìƒì„±:
      - ìˆ˜ìµ/ì†ì‹¤, ì»¨í…ìŠ¤íŠ¸, í…Œì´í”„ íë¦„ ì¢…í•©ìœ¼ë¡œ
        ğŸ‘‰ ìœ ì§€ / ë¶€ë¶„ì²­ì‚° / ì „ëŸ‰ì²­ì‚° ì„¸ ê°€ì§€ ì•¡ì…˜ ì œì•ˆ
    """
    try:
        ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
    except:
        ret_pct = 0.0

    # ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´(ì¶”ì„¸ì—­ì „ ì‹ í˜¸ë“¤)
    try:
        ctx_score, ctx_reasons = context_exit_score(
            "KRW-XXX",
            ticks or [],
            ob_depth_krw or 10_000_000,
            entry_price,
            last_price,
            c1 or [],
        )
    except Exception:
        ctx_score, ctx_reasons = (0, [])

    # í…Œì´í”„(ìµœê·¼ 15s)
    t15 = micro_tape_stats_from_ticks(ticks or [], 15)
    buy = t15.get("buy_ratio", 0.0)
    n = t15.get("n", 0)

    # ì»¨í…ìŠ¤íŠ¸(EMA5 / VWAP)
    vwap = vwap_from_candles_1m(c1 or [], 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in (c1 or [])], 5) if c1 else 0
    vwap_ok = bool(vwap and last_price >= vwap)
    ema_ok = bool(ema5 and last_price >= ema5)

    # ğŸ’ ê±°ë˜ ë‘”í™” + ì•½ìƒìŠ¹ â†’ ë³¸ì ˆ ìµì ˆ ìœ ë„
    if -0.2 <= ret_pct <= 0.4 and t15.get("krw_per_sec", 0) < 12000 and ctx_score <= ctx_thr:
        action = "ë¶€ë¶„ ì²­ì‚°(ë³¸ì ˆ)"
        rationale = f"ê±°ë˜ë‘”í™” êµ¬ê°„ ë³¸ì ˆ ìµì ˆ ({ret_pct:+.2f}%)"
        return action, rationale

    # -----------------------------
    # 1) ì „ëŸ‰ ì²­ì‚° ê¶Œê³  ì¡°ê±´ (ê°•í•œ ì²­ì‚°)
    # -----------------------------
    full_exit = False
    why_full = []

    # (1) ì†ì‹¤ì´ ë§ì´ ì»¤ì¡Œì„ ë•Œ
    if ret_pct <= -2.0:
        full_exit = True
        why_full.append(f"ì†ì‹¤ {ret_pct:+.2f}%")

    # (2) ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´ê°€ ì„ê³„ì¹˜ë³´ë‹¤ ë§ì´ ë†’ê³ , VWAP/EMAë„ ê¹¨ì ¸ ìˆì„ ë•Œ
    if ctx_score >= (ctx_thr + 1) and not vwap_ok and not ema_ok:
        full_exit = True
        why_full.append(f"ì»¨í…ìŠ¤íŠ¸ {ctx_score}/{ctx_thr}")

    # (3) ì•½ì†ì‹¤ ìƒíƒœì—ì„œ ë§¤ìˆ˜ì„¸Â·í…Œì´í”„ê°€ ë§ì´ ì£½ì€ ê²½ìš°
    if ret_pct < -0.8 and buy < 0.50 and n >= 4:
        full_exit = True
        why_full.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    if full_exit:
        action = "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ "
        rationale = " Â· ".join(why_full) if why_full else "ë¦¬ìŠ¤í¬ ìš°ìœ„"
        return action, rationale

    # -----------------------------
    # 2) ë¶€ë¶„ ì²­ì‚° ê¶Œê³  (ì• ë§¤/ê²½ê³  êµ¬ê°„)
    # -----------------------------
    partial_exit = False
    why_partial = []

    # ìˆ˜ìµì´ í¬ì§€ ì•Šì€ êµ¬ê°„
    if -0.8 < ret_pct < 0.8:
        partial_exit = True
        why_partial.append(f"ìˆ˜ìµ {ret_pct:+.2f}%")

    # ì»¨í…ìŠ¤íŠ¸ ê²½ê³  ë ˆë²¨
    if ctx_score == ctx_thr:
        partial_exit = True
        why_partial.append(f"ì»¨í…ìŠ¤íŠ¸ ê²½ê³  {ctx_score}/{ctx_thr}")

    # ë§¤ìˆ˜ë¹„ ì•½í•˜ê³  í‹±ì€ ë§ì€ ê²½ìš°
    if buy < 0.55 and n >= 6:
        partial_exit = True
        why_partial.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    # ğŸš€ ê±°ë˜ë‘”í™” ì‹œ ìë™ ë¶€ë¶„ìµì ˆ ê¶Œê³ 
    if ret_pct >= 1.5 and t15["krw_per_sec"] < 15000:
        partial_exit = True
        why_partial.append(f"ê±°ë˜ì†ë„ ë‘”í™” {t15['krw_per_sec']:.0f} KRW/s")

    # VWAP/EMA ë‘˜ ë‹¤ í•˜ë°©ì¼ ë•Œ
    if not vwap_ok and not ema_ok:
        partial_exit = True
        why_partial.append("VWAPÂ·EMA5 í•˜ë°©")

    if partial_exit:
        action = "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ "
        rationale = " Â· ".join(why_partial) if why_partial else "ë¶ˆí™•ì‹¤ êµ¬ê°„"
        return action, rationale

    # -----------------------------
    # 3) ìœ ì§€ ê¶Œê³  (ì¶”ì„¸ ìœ ì§€)
    # -----------------------------
    why_keep = [f"ìˆ˜ìµ {ret_pct:+.2f}%"]
    if vwap_ok:
        why_keep.append("VWAP ìƒë°©")
    if ema_ok:
        why_keep.append("EMA5 ìƒë°©")
    if buy >= 0.60 and n >= 4:
        why_keep.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    rationale = " Â· ".join(why_keep)
    return "ìœ ì§€ ê¶Œê³ ", rationale


# =========================
# ëª¨ë‹ˆí„°ë§(ìµœì¢…í˜•)
# =========================
def monitor_position(m,
                     entry_price,
                     pre,
                     tight_mode=False,
                     horizon=None,
                     reentry=False):
    # ğŸ”§ FIX: entry_price ìœ íš¨ì„± ê²€ì¦ (Division by Zero ë°©ì§€)
    if not entry_price or entry_price <= 0:
        print(f"[MONITOR_ERR] {m} entry_price ë¬´íš¨ ({entry_price}) â†’ ëª¨ë‹ˆí„°ë§ ì¤‘ë‹¨")
        return "ìœ íš¨í•˜ì§€ ì•Šì€ entry_price", None, "", None, 0, 0, 0

    c1 = get_minutes_candles(1, m, 20)
    base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(entry_price, c1)

    # horizonì´ ì•ˆ ë“¤ì–´ì˜¤ë©´ ìë™ ê²°ì •, ë“¤ì–´ì˜¤ë©´ ê·¸ ê°’ ì‚¬ìš©
    if horizon is None:
        horizon = decide_monitor_secs(pre, tight_mode=tight_mode)
    start_ts = time.time()
    MAX_RUNTIME = horizon * 1.5  # ìµœëŒ€ í—ˆìš© ì‹¤í–‰ì‹œê°„ (ì •ìƒì‹œê°„ì˜ 1.5ë°°)


    # ë””ë°”ìš´ìŠ¤/íŠ¸ë ˆì¼ ìƒíƒœ
    # ì†ì ˆ ë””ë°”ìš´ìŠ¤ìš©
    stop_first_seen_ts = 0.0
    stop_hits = 0
    # ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ë””ë°”ìš´ìŠ¤ìš©
    ctx_first_seen_ts = 0.0
    ctx_hits = 0

    trail_armed = False
    trail_stop = 0.0

    # ìŠ¤íŒŒì´í¬/ê·¸ë ˆì´ìŠ¤ ê¸°ì¡´ ë¡œì§ ì¬í™œìš©
    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 10
    grace_used = False
    spike_recovery_used = False

    ob = pre.get("ob")
    ob_depth_default = ob.get("depth_krw", 10_000_000) if ob else 10_000_000

    last_price = entry_price
    best = entry_price
    worst = entry_price

    # ì‹¤ì œ ë³´ìœ  ìˆ˜ëŸ‰ í™•ë³´ (ìµì ˆ ì‹œ ë§¤ë„ìš©)
    with _POSITION_LOCK:
        entry_volume = OPEN_POSITIONS.get(m, {}).get("volume", 0.0)

    verdict = None
    outcome_extra = ""

    # === ğŸ¯ ì–‡ì€ ìˆ˜ìµ ì²´í¬í¬ì¸íŠ¸ ìƒíƒœ ===
    checkpoint_reached = False   # ì–‡ì€ ìˆ˜ìµ ë„ë‹¬ ì—¬ë¶€
    strong_mode = False          # ê°•ì„¸ í™•ì¸ í›„ íŠ¸ë ˆì¼ë§ ëª¨ë“œ
    strong_peak = entry_price    # ê°•ì„¸ ëª¨ë“œ ì§„ì… í›„ ê³ ì  ì¶”ì 
    # ğŸ”§ ë™ì  ì²´í¬í¬ì¸íŠ¸ (ìˆ˜ìˆ˜ë£Œ+ìŠ¬ë¦¬í”¼ì§€ ê¸°ë°˜)
    dyn_checkpoint = get_dynamic_checkpoint()
    # ğŸ”§ ë™ì  íŠ¸ë ˆì¼ ê°„ê²© (ì†ì ˆí­ ì—°ë™ - íœ©ì˜ ì»· ê°ì†Œ)
    trail_dist_min = get_trail_distance_min()

    # === ğŸ”¥ Plateau ê°ì§€ìš© ìƒíƒœ ===
    last_peak_ts = time.time()   # ë§ˆì§€ë§‰ ê³ ì  ê°±ì‹  ì‹œê°„
    plateau_partial_done = False # Plateau ë¶€ë¶„ìµì ˆ ì™„ë£Œ ì—¬ë¶€

    # === ğŸ”§ ê³ ì  ê°±ì‹  ê¸°ë°˜ ì‹œê°„ì†ì ˆ (í˜ì´í¬ ëŒíŒŒ ì¡°ê¸° íƒˆì¶œ) ===
    peak_update_count = 0        # ê³ ì  ê°±ì‹  íšŸìˆ˜
    NO_PEAK_TIMEOUT_SEC = 45     # 45ì´ˆ ë‚´ ê³ ì  ê°±ì‹  ì—†ìœ¼ë©´ í˜ì´í¬ë¡œ ê°„ì£¼
    MIN_PEAK_UPDATES = 1         # ìµœì†Œ 1íšŒ ê³ ì  ê°±ì‹  í•„ìš”

    # === ğŸ”§ MFE ê¸°ë°˜ ë¶€ë¶„ìµì ˆ ìƒíƒœ ===
    mfe_partial_done = False     # MFE ë¶€ë¶„ìµì ˆ ì™„ë£Œ ì—¬ë¶€

    # === ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¯¸ë‹ˆíŠ¸ë ˆì¼ ìƒíƒœ ===
    sideways_peak = 0.0          # 60ì´ˆ ì´í›„ ê³ ì  ì¶”ì 

    # === ğŸ”¥ ì‹¤íŒ¨ ë¸Œë ˆì´í¬ì•„ì›ƒ ê°ì§€ ìƒíƒœ ===
    breakout_reached = False     # +0.15% ì´ìƒ ëŒíŒŒ ì—¬ë¶€
    breakout_ts = 0.0            # ëŒíŒŒ ì‹œì  íƒ€ì„ìŠ¤íƒ¬í”„

    # === í¬ì§€ì…˜ ëª¨ë“œ (probe / confirm) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m, {})
    entry_mode = pos.get("entry_mode", "confirm")
    signal_tag = pos.get("signal_tag", "ê¸°ë³¸")  # ğŸ”§ MFE ìµì ˆ ê²½ë¡œìš©

    try:
        while time.time() - start_ts <= horizon:
            time.sleep(RECHECK_SEC)

            ticks = get_recent_ticks(m, 100)
            if not ticks or len(ticks) < 3:
                consecutive_failures += 1
                if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                    time.sleep(3)
                    ticks = get_recent_ticks(m, 100)
                    if not ticks:
                        verdict = "ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨"
                        break
                    consecutive_failures = 0
                continue
            consecutive_failures = 0

            # í˜„ì¬ê°€
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            if not cur_js or len(cur_js) == 0:
                continue
            curp = cur_js[0].get("trade_price", last_price)
            last_price = curp
            # âœ… íŠ¸ë ˆì¼ë§ ë˜ì¹« ë²„ê·¸ ìˆ˜ì •: ì‹ ê³ ì  íŒì • ë¨¼ì €
            new_high = curp > best
            if new_high:
                last_peak_ts = time.time()  # ğŸ”¥ Plateau ê°ì§€ìš© ê³ ì  ì‹œê°„ ê°±ì‹ 
                peak_update_count += 1      # ğŸ”§ ê³ ì  ê°±ì‹  íšŸìˆ˜ ì¦ê°€
            best = max(best, curp)
            worst = min(worst, curp)

            # ğŸ”§ ê³ ì  ë¯¸ê°±ì‹  ì‹œê°„ì†ì ˆ - ë¹„í™œì„±í™” (ì§„ì… íƒ€ì´íŠ¸í•˜ë¯€ë¡œ ì²­ì‚°ì€ ë£¨ì¦ˆí•˜ê²Œ)
            # alive_sec_now = time.time() - start_ts
            # if alive_sec_now >= NO_PEAK_TIMEOUT_SEC and peak_update_count < MIN_PEAK_UPDATES:
            #     cur_gain_check = (curp / entry_price - 1.0)
            #     if cur_gain_check <= 0:
            #         close_auto_position(m, f"ê³ ì ë¯¸ê°±ì‹  | {alive_sec_now:.0f}ì´ˆ ë‚´ ê°±ì‹  {peak_update_count}íšŒ (í˜ì´í¬ ëŒíŒŒ)")
            #         verdict = "ê³ ì  ë¯¸ê°±ì‹  í˜ì´í¬"
            #         break

            # ğŸ”§ MFE/MAE ì‹¤ì‹œê°„ ì €ì¥ (ì²­ì‚° ì‹œ ë¡œê¹…ìš©)
            mfe_pct = (best / entry_price - 1.0) * 100
            mae_pct = (worst / entry_price - 1.0) * 100
            with _POSITION_LOCK:
                pos_now = OPEN_POSITIONS.get(m)
                if pos_now:
                    pos_now["mfe_pct"] = mfe_pct
                    pos_now["mae_pct"] = mae_pct
                    OPEN_POSITIONS[m] = pos_now

            # === 1) ATR ê¸°ë°˜ ë™ì  ì†ì ˆ (ì›œì—… ì œê±°, ì²´ê²° ì§í›„ë¶€í„° ì ìš©) ===
            alive_sec = time.time() - start_ts
            dd_now = (curp / best - 1.0)
            cur_gain = (curp / entry_price - 1.0)

            # ğŸ”§ FIX (D): ì†ì ˆë„ net ê¸°ì¤€ ì •í•©ì„± (fee ë§ˆì§„ ì¶”ê°€)
            # - ìµì ˆ: ret_net = ret_pct - feeë¡œ íŒë‹¨ (ì‹¤ì œ ìˆ˜ìµ ê¸°ì¤€)
            # - ì†ì ˆ: ì†ì ˆì„ ì— fee ë§ˆì§„ ì¶”ê°€ â†’ ì²­ì‚° í›„ ì‹¤ì†ì‹¤ì´ ì˜ë„í•œ ì†ì ˆì„ ì— ê·¼ì ‘
            # - íš¨ê³¼: ì†ì ˆì´ ì•½ê°„ ì™„í™”ë˜ì–´ íœ©ì˜ ë°©ì§€ + ìµì ˆê³¼ ì •í•©ì„± í™•ë³´
            fee_margin = FEE_RATE_ROUNDTRIP  # ì™•ë³µ 0.1%
            eff_sl_with_fee = eff_sl_pct + fee_margin  # ì†ì ˆì„  ì™„í™”
            if cur_gain <= -eff_sl_with_fee:
                close_auto_position(m, f"ATRì†ì ˆ | í˜„ì¬ -{abs(cur_gain)*100:.2f}% < ì†ì ˆì„  -{eff_sl_with_fee*100:.2f}% (netê¸°ì¤€, {atr_info})")
                verdict = "ATRì†ì ˆ"
                outcome_extra = f"({cur_gain*100:.2f}%, SL-{eff_sl_with_fee*100:.2f}%)"
                break

            # === ğŸ”¥ ì‹¤íŒ¨ ë¸Œë ˆì´í¬ì•„ì›ƒ ì¦‰ì‹œ íƒˆì¶œ ===
            # +0.15% ëŒíŒŒ í›„ 5ì´ˆ ë‚´ ì§„ì…ê°€ ì´í•˜ë¡œ ë³µê·€ â†’ ê°€ì§œ ëŒíŒŒ, ì¦‰ì‹œ ì²­ì‚°
            # === ğŸ”§ ì‹¤íŒ¨ëŒíŒŒ - ë¹„í™œì„±í™” (ì§„ì… íƒ€ì´íŠ¸í•˜ë¯€ë¡œ ì²­ì‚°ì€ ë£¨ì¦ˆí•˜ê²Œ) ===
            # BREAKOUT_THRESHOLD = 0.0015  # +0.15%
            # BREAKOUT_FAIL_SEC = 5        # 5ì´ˆ ì´ë‚´ ë³µê·€í•˜ë©´ ì‹¤íŒ¨
            # if not breakout_reached and cur_gain >= BREAKOUT_THRESHOLD:
            #     breakout_reached = True
            #     breakout_ts = time.time()
            # if breakout_reached and cur_gain <= 0:
            #     time_since_breakout = time.time() - breakout_ts
            #     if time_since_breakout <= BREAKOUT_FAIL_SEC:
            #         close_auto_position(m, f"ì‹¤íŒ¨ëŒíŒŒ | +{BREAKOUT_THRESHOLD*100:.2f}%â†’{cur_gain*100:.2f}% ({time_since_breakout:.1f}ì´ˆ)")
            #         verdict = "ì‹¤íŒ¨ëŒíŒŒ"
            #         outcome_extra = f"(ëŒíŒŒí›„ {time_since_breakout:.1f}ì´ˆ ë‚´ ë³µê·€)"
            #         break

            # === ğŸ”§ ìŠ¤í¬ë˜ì¹˜ ê·œì¹™ - ë¹„í™œì„±í™” (ì§„ì… íƒ€ì´íŠ¸í•˜ë¯€ë¡œ ì²­ì‚°ì€ ë£¨ì¦ˆí•˜ê²Œ) ===
            # if alive_sec >= SCRATCH_TIMEOUT_SEC and alive_sec < SIDEWAYS_TIMEOUT:
            #     max_gain = (best / entry_price - 1.0)  # MFE
            #     if max_gain < SCRATCH_MIN_GAIN:
            #         flow_accel = calc_flow_acceleration(ticks)
            #         if flow_accel < 0.7:
            #             close_auto_position(m, f"ìŠ¤í¬ë˜ì¹˜ | {alive_sec:.0f}ì´ˆ MFE {max_gain*100:.3f}% íë¦„ë‘”í™”({flow_accel:.2f}x)")
            #             verdict = "ìŠ¤í¬ë˜ì¹˜"
            #             outcome_extra = f"(MFE {max_gain*100:.3f}%, flow={flow_accel:.2f})"
            #             break

            # === ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¡œì§ - ë¹„í™œì„±í™” (ì§„ì… íƒ€ì´íŠ¸í•˜ë¯€ë¡œ ì²­ì‚°ì€ ë£¨ì¦ˆí•˜ê²Œ) ===
            # if alive_sec >= SIDEWAYS_TIMEOUT and not trail_armed:
            #     sideways_peak = max(sideways_peak, cur_gain)
            #     SIDEWAYS_TRAIL_DROP = 0.0003  # 0.03%
            #     if cur_gain < sideways_peak - SIDEWAYS_TRAIL_DROP:
            #         close_auto_position(m, f"íš¡ë³´íƒˆì¶œ | {alive_sec:.0f}ì´ˆ ê³ ì {sideways_peak*100:.2f}%â†’í˜„ì¬{cur_gain*100:.2f}%")
            #         verdict = "íš¡ë³´íƒˆì¶œ"
            #         outcome_extra = f"(ê³ ì {sideways_peak*100:.2f}%â†’{cur_gain*100:.2f}%, {alive_sec:.0f}ì´ˆ)"
            #         break

            # === 2) íŠ¸ë ˆì¼ë§ ì†ì ˆ: ì´ìµì´ ë‚˜ì•¼ë§Œ ë¬´ì¥
            gain_from_entry = (curp / entry_price - 1.0)
            
            # === PROBE â†’ CONFIRM ì „í™˜ ë¡œì§ ===
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m, {})

            if pos.get("entry_mode") == "probe":
                # ì „í™˜ ì¡°ê±´: ì¼ì • ìˆ˜ìµ ì´ìƒ + ê±°ë˜ì†ë„ ì •ìƒ + ë§¤ìˆ˜ì„¸ ìœ ì§€ + í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤
                t15_now = micro_tape_stats_from_ticks(ticks, 15)
                # ğŸ”§ FIX: Decimal ì œê±° (floatì™€ ë¹„êµ ì‹œ TypeError ë°œìƒ)
                gain_now = (curp / entry_price - 1.0)

                # ğŸ”§ FIX: ì¶”ë§¤ ì¡°ê±´ì— ìµœì‹  í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì‚¬ìš© (ê³¼ê±° ob ì‚¬ìš© â†’ ì˜¤íŒ ë°©ì§€)
                try:
                    _ob_fresh = fetch_orderbook_cache([m])
                    ob_now = _ob_fresh.get(m, pre.get("ob", {}))
                except Exception:
                    ob_now = pre.get("ob", {})
                imb_now = calc_orderbook_imbalance(ob_now) if ob_now else 0.0

                strong_flow = (
                    t15_now["buy_ratio"] >= 0.58
                    and t15_now["krw_per_sec"] >= 18000
                    and uptick_streak_from_ticks(ticks, need=2)
                    and imb_now >= 0.40  # ğŸ”§ í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì¡°ê±´ ì¶”ê°€
                )

                if gain_now >= 0.012 and strong_flow:
                    add_reason = f"ìƒìŠ¹í™•ì • (ìˆ˜ìµ+{gain_now*100:.1f}% ë§¤ìˆ˜ë¹„{t15_now['buy_ratio']:.0%} ì´ˆë‹¹{t15_now['krw_per_sec']/1000:.0f}K)"
                    ok_add, new_entry = add_auto_position(m, curp, add_reason)
                    if ok_add and new_entry:
                        # ì§„ì…ëª¨ë“œ ìŠ¹ê²©
                        with _POSITION_LOCK:
                            pos["entry_mode"] = "confirm"
                            pos["entry_price"] = new_entry
                            pos["added"] = True
                            pos["last_add_ts"] = time.time()
                            OPEN_POSITIONS[m] = pos

                        tg_send_mid(
                            f"ğŸ”¥ {m} ìƒìŠ¹ í™•ì • â†’ probe âœ confirm ì „í™˜\n"
                            f"ì¶”ë§¤ í›„ í‰ë‹¨: {fmt6(new_entry)}ì›"
                        )

                        # ë™ì  ì†ì ˆ ì¬ê³„ì‚°
                        c1_for_sl = get_minutes_candles(1, m, 20)
                        base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(new_entry, c1_for_sl)
                        trail_armed = False  # ìƒˆ ê¸°ì¤€ìœ¼ë¡œ íŠ¸ë ˆì¼ë§ ë¦¬ì…‹

            if (not trail_armed) and gain_from_entry >= dyn_checkpoint:
                trail_armed = True
                # ì´ˆê¸° íŠ¸ë ˆì¼: ATR ê¸°ì¤€ í˜¹ì€ ìµœì†Œê±°ë¦¬ (ğŸ”§ ì†ì ˆí­ ì—°ë™)
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(trail_dist_min,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = trail_dist_min
                trail_stop = curp * (1.0 - trail_dist)

            # === 2-1) í”¼ë¼ë¯¸ë”©(ì¶”ë§¤): ì™„í™”í˜• ë¡œì§ (ë¶€ë¶„ì²­ì‚° í›„ ì¬ìƒìŠ¹ ëŒ€ì‘) ===
            if USE_PYRAMIDING and AUTO_TRADE:
                t15_now = micro_tape_stats_from_ticks(ticks, 15)

                # ğŸ”§ FIX: ì¶”ë§¤ ì¡°ê±´ì— í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì¶”ê°€ (í˜¸ê°€ êº¾ì´ë©´ í‰ë‹¨ ì•…í™” ë°©ì§€)
                ob_pyr = pre.get("ob", {})
                imb_pyr = calc_orderbook_imbalance(ob_pyr) if ob_pyr else 0.0

                # ğŸ’¡ ì¡°ê±´ ì™„í™” â€” ì•½ìƒìŠ¹ì—ì„œë„ ë°˜ì‘í•˜ë„ë¡
                add_cond_price = gain_from_entry >= max(0.005, PYRAMID_ADD_MIN_GAIN * 0.8)
                add_cond_flow = (
                    t15_now["buy_ratio"] >= 0.55 and
                    t15_now["krw_per_sec"] >= PYRAMID_ADD_FLOW_MIN_KRWPSEC * 0.8 and
                    last_two_ticks_fresh(ticks) and
                    imb_pyr >= 0.40  # ğŸ”§ í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì¡°ê±´ ì¶”ê°€
                )

                # ğŸ“Š ë‹¨ê¸° EMA ê¸°ì¤€ìœ¼ë¡œ ë‹¨ê¸° ìƒìŠ¹ ì „í™˜ ê°ì§€ (1ë¶„ë´‰)
                c1m = get_minutes_candles(1, m, 20)
                ema3 = ema_last([c["trade_price"] for c in c1m], 3)
                ema8 = ema_last([c["trade_price"] for c in c1m], 8)
                short_term_up = ema3 > ema8

                if add_cond_price and add_cond_flow and short_term_up:
                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        already_added = pos.get("added") if pos else True
                        last_add_ts = pos.get("last_add_ts", 0.0) if pos else 0.0

                    # ì¿¨ë‹¤ìš´ì„ 40% ë‹¨ì¶•í•´ ì¬ì§„ì…ì„± í–¥ìƒ
                    cooldown_ok = (time.time() - last_add_ts) >= (PYRAMID_ADD_COOLDOWN_SEC * 0.6)

                    if pos and (not already_added) and cooldown_ok:
                        add_reason = f"ì¬ìƒìŠ¹EMA (ìˆ˜ìµ+{gain_from_entry*100:.1f}% ë§¤ìˆ˜ë¹„{t15_now['buy_ratio']:.0%} EMA3>EMA8)"
                        ok_add, new_entry = add_auto_position(m, curp, add_reason)
                        if ok_add and new_entry:
                            entry_price = new_entry
                            c1_for_sl = get_minutes_candles(1, m, 20)
                            base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(entry_price, c1_for_sl)

            # ğŸ”§ FIX: íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸ - new_high ì‚¬ìš© (curp > bestëŠ” best ê°±ì‹  í›„ë¼ í•­ìƒ False)
            if trail_armed and new_high:
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(trail_dist_min,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = trail_dist_min
                trail_stop = max(trail_stop, curp * (1.0 - trail_dist))

            # ğŸ”§ [ì‹ ê·œ] íŠ¸ë ˆì¼ë§ ì†ì ˆ ì‹¤ì œ ì²­ì‚° íŠ¸ë¦¬ê±°
            if trail_armed and curp < trail_stop:
                # ğŸ”§ FIX: Division by Zero ë°©ì–´ (entry_price, bestëŠ” í•­ìƒ ì–‘ìˆ˜ì—¬ì•¼ í•¨)
                trail_gain = (curp / entry_price - 1.0) if entry_price > 0 else 0
                peak_gain = (best / entry_price - 1.0) if entry_price > 0 else 0
                drop_pct = (best - curp) / best * 100 if best > 0 else 0
                close_auto_position(m, f"íŠ¸ë ˆì¼ë§ì†ì ˆ +{trail_gain*100:.2f}% (ê³ ì +{peak_gain*100:.2f}%ì—ì„œ -{drop_pct:.2f}% í•˜ë½)")
                verdict = "TRAIL_STOP"
                break

            # ğŸ”§ [ì œê±°ë¨] ë¸Œë ˆì´í¬ì´ë¸ â†’ íŠ¸ë ˆì¼ë§ 0.4% ë°œë™ìœ¼ë¡œ ëŒ€ì²´
            # íŠ¸ë ˆì¼ë§ì´ +0.4%ì—ì„œ ë°œë™ë˜ë©´ íŠ¸ë ˆì¼ìŠ¤íƒ‘ì´ ìë™ìœ¼ë¡œ ë³¸ì ˆ ì´ìƒì´ ë¨
            in_breakeven_box = abs(gain_from_entry) <= BREAKEVEN_BOX  # Â±0.15% ë°•ìŠ¤ ë‚´ (ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©)

            # === ğŸ”¥ ì‹¬í”Œ ì²´í¬í¬ì¸íŠ¸ ë§¤ë„ ë¡œì§ ===
            cur_gain = (curp / entry_price - 1.0)
            # ğŸ”§ FIX: ìµœì‹  ì˜¤ë”ë¶ ì‚¬ìš© (ê³¼ê±° ob ê¸°ë°˜ íŒë‹¨ â†’ ì˜¤íŒ ë°©ì§€)
            try:
                _ob_fresh2 = fetch_orderbook_cache([m])
                ob_now = _ob_fresh2.get(m, pre.get("ob", {}))
            except Exception:
                ob_now = pre.get("ob", {})

            # === ğŸ¯ ATR ê¸°ë°˜ ë™ì  ì†ì ˆ (í‹±ìŠ¤íƒ‘ ì œê±°ë¨) ===
            # ì´ë¯¸ line 4876ì—ì„œ ì›œì—… ì—†ì´ ì¦‰ì‹œ ATR ì†ì ˆ ì ìš© ì¤‘
            # ì—¬ê¸°ëŠ” íŠ¸ë ˆì¼ë§ ì†ì ˆ ì´í›„ ì¶”ê°€ ì†ì ˆ íŒì •ìš©

            # â‘¡ ì²´í¬í¬ì¸íŠ¸ ë„ë‹¬ ì‹œ ê°•ì„¸/ì•½ì„¸ íŒë‹¨
            # ğŸ”§ FIX: ì²´í¬í¬ì¸íŠ¸ ì¬í‰ê°€ - ê°€ê²©ì´ 30% ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ ë¦¬ì…‹
            if checkpoint_reached and cur_gain < (dyn_checkpoint * 0.3):
                checkpoint_reached = False  # ì²´í¬í¬ì¸íŠ¸ ì•„ë˜ë¡œ ë–¨ì–´ì§ â†’ ì¬í‰ê°€ í—ˆìš©

            # ğŸ”§ ì†Œí”„íŠ¸ ê°€ë“œ: ì´ˆê¸° 30ì´ˆê°„ ì²­ì‚° ì¡°ê±´ ê°•í™”
            in_soft_guard = alive_sec < SOFT_GUARD_SEC

            if not checkpoint_reached and cur_gain >= dyn_checkpoint:
                checkpoint_reached = True
                # ğŸ”§ [ë³€ê²½] ê°•ì„¸/ì•½ì„¸ íŒë‹¨ â†’ ì•½ì„¸ë§Œ 25% ë¶€ë¶„ìµì ˆ, ê°•ì„¸ëŠ” íŠ¸ë ˆì¼ë§ì— ë§¡ê¹€
                if is_strong_momentum(ticks, ob_now):
                    # ê°•ì„¸ â†’ íŠ¸ë ˆì¼ë§ì´ ì•Œì•„ì„œ ì²˜ë¦¬ (ê°•ì„¸ëª¨ë“œ ë™ì íŠ¸ë ˆì¼ ì œê±°ë¨)
                    tg_send_mid(f"ğŸ’ª {m} +{cur_gain*100:.2f}% ê°•ì„¸ â†’ íŠ¸ë ˆì¼ë§ ìœ ì§€")
                else:
                    # ì•½ì„¸ íŒì •ì´ì§€ë§Œ ì†Œí”„íŠ¸ ê°€ë“œ + ë°•ìŠ¤ ë‚´ë©´ í™€ë”©
                    if in_soft_guard and in_breakeven_box:
                        # ì´ˆê¸° 30ì´ˆ + Â±0.15% ë°•ìŠ¤ â†’ í™€ë”© (íœ©ì˜ ë°©ì§€)
                        tg_send_mid(f"â³ {m} ì•½ì„¸ íŒì •ì´ë‚˜ ì†Œí”„íŠ¸ê°€ë“œ êµ¬ê°„ â†’ ê´€ì°° ìœ ì§€")
                    else:
                        # ì•½ì„¸ â†’ 25% ë¶€ë¶„ìµì ˆ (ë‚˜ë¨¸ì§€ 75%ëŠ” íŠ¸ë ˆì¼ë§/ATRì†ì ˆ)
                        ok, msg, sold = safe_partial_sell(m, 0.25, f"ì–‡ì€ìˆ˜ìµ ìŠ¤ìº˜í•‘ +{cur_gain*100:.2f}% ì•½ì„¸íŒì •")
                        if ok:
                            tg_send_mid(f"ğŸ’° {m} +{cur_gain*100:.2f}% ì•½ì„¸ â†’ 25% ìŠ¤ìº˜í•‘ ì™„ë£Œ")

            # ğŸ”§ [ì œê±°ë¨] ê°•ì„¸ëª¨ë“œ ë™ì  íŠ¸ë ˆì¼ë§ â†’ ì¼ë°˜ íŠ¸ë ˆì¼ë§(0.2% ê°„ê²©)ìœ¼ë¡œ ëŒ€ì²´

            # ğŸ”§ [ì œê±°ë¨] Giveback Cap / Peak Giveback â†’ íŠ¸ë ˆì¼ë§ìœ¼ë¡œ ëŒ€ì²´
            # íŠ¸ë ˆì¼ë§ ê°„ê²© 0.25%ë¡œ íƒ€ì´íŠ¸í™”í•˜ì—¬ ë™ì¼ íš¨ê³¼ ë‹¬ì„±
            max_gain = (best / entry_price - 1.0)  # MFE ìˆ˜ìµë¥  (ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©)
            cur_gain_now = (curp / entry_price - 1.0)  # í˜„ì¬ ìˆ˜ìµë¥ 

            # === ğŸ”§ (A) MFE ê¸°ë°˜ ë¶€ë¶„ìµì ˆ (ê²½ë¡œë³„ ë™ì  íƒ€ê²Ÿ) ===
            # ì‹ í˜¸ ê°•ë„ë³„ë¡œ ë‹¤ë¥¸ MFE íƒ€ê²Ÿ ì ìš© â†’ ëª©í‘œ ë„ë‹¬ ì‹œ 50% ìµì ˆ
            if not mfe_partial_done and not plateau_partial_done:
                mfe_target = MFE_PARTIAL_TARGETS.get(signal_tag, 0.004)  # ê¸°ë³¸ 0.4%
                # ğŸ”§ FIX: BTC ì—­í’ ì‹œ TP ë³´ìˆ˜í™” (ëª©í‘œ ë‚®ì¶¤)
                btc5_now = btc_5m_change()
                if btc5_now <= -0.003:  # BTC -0.3% ì—­í’
                    mfe_target *= 0.75  # ëª©í‘œ 25% í•˜í–¥
                if max_gain >= mfe_target:
                    ok, msg, sold = safe_partial_sell(
                        m, MFE_PARTIAL_RATIO,
                        f"MFEìµì ˆ +{max_gain*100:.2f}% (ê²½ë¡œ:{signal_tag}, íƒ€ê²Ÿ:{mfe_target*100:.2f}%)"
                    )
                    if ok:
                        mfe_partial_done = True
                        # ğŸ”¥ ë³¸ì ˆ ìƒí–¥: ë‚¨ì€ 50%ëŠ” ì†í•´ ë°©ì§€
                        BE_OFFSET_MFE = FEE_RATE + 0.0005  # ë³¸ì ˆ ì—¬ìœ 
                        be_stop = entry_price * (1.0 + BE_OFFSET_MFE)
                        base_stop = max(base_stop, be_stop)
                        tg_send_mid(f"ğŸ¯ {m} MFEìµì ˆ {int(MFE_PARTIAL_RATIO*100)}% | +{max_gain*100:.2f}% ({signal_tag}) | ì†ì ˆì„ â†’ë³¸ì ˆ ìƒí–¥")

            # === ğŸ”¥ (B) Plateau + ëª¨ë©˜í…€ ì•½í™” â†’ ë¶€ë¶„ìµì ˆ + ë³¸ì ˆìƒí–¥ ===
            # ì¡°ê±´: ê³ ì  ê°±ì‹  20ì´ˆ ì—†ìŒ + buy_decay + ìˆ˜ìµ ì¤‘ + ì•„ì§ ë¶€ë¶„ìµì ˆ ì•ˆí•¨
            PLATEAU_SEC = 20  # ê³ ì  ê°±ì‹  ì—†ì´ ë²„í‹´ ì‹œê°„
            # ğŸ”§ [í†µí•©ë¨] PLATEAU_MIN_GAIN â†’ PROFIT_CHECKPOINT (ìƒë‹¨ ì •ì˜)
            BE_OFFSET = FEE_RATE + 0.0005  # ë³¸ì ˆ = ìˆ˜ìˆ˜ë£Œ(0.1%) + ì—¬ìœ (0.05%) = 0.15%

            time_since_peak = time.time() - last_peak_ts
            if (not plateau_partial_done
                and not mfe_partial_done  # ğŸ”§ MFE ìµì ˆ ì™„ë£Œ ì‹œ ìŠ¤í‚µ
                and cur_gain_now >= dyn_checkpoint
                and time_since_peak >= PLATEAU_SEC):

                decay_flag, decay_info = buy_decay_flag(ticks)
                if decay_flag:
                    # ë¶€ë¶„ìµì ˆ ì‹¤í–‰ (50%)
                    ok, msg, sold = safe_partial_sell(m, 0.5, f"Plateauë¶€ë¶„ìµì ˆ +{cur_gain_now*100:.2f}% (ê³ ì í›„ {time_since_peak:.0f}ì´ˆ íš¡ë³´+ë§¤ìˆ˜ì•½í™”)")
                    if ok:
                        plateau_partial_done = True
                        # ğŸ”¥ ë³¸ì ˆ ìƒí–¥: ë‚¨ì€ 50%ëŠ” ìµœì†Œí•œ ì†í•´ ì•ˆ ë³´ê²Œ
                        be_stop = entry_price * (1.0 + BE_OFFSET)
                        base_stop = max(base_stop, be_stop)
                        tg_send_mid(f"ğŸ“‰ {m} Plateau ë¶€ë¶„ìµì ˆ 50% | +{cur_gain_now*100:.2f}% | ì†ì ˆì„ â†’ë³¸ì ˆ({BE_OFFSET*100:.2f}%) ìƒí–¥")

            # â‘£ ëˆŒë¦¼ í›„ ì¬ìƒìŠ¹ ê°ì§€ â†’ íŠ¸ë ˆì¼ ê°•í™” (ì¬ì§„ì… ëŒ€ì‹ )
            drop_from_high = (best - curp) / best if best > 0 else 0
            if drop_from_high >= 0.005 and uptick_streak_from_ticks(ticks, need=3):
                if trail_armed:
                    # ì¬ì§„ì… ëŒ€ì‹  íŠ¸ë ˆì¼ ê°„ê²© íƒ€ì´íŠ¸í•˜ê²Œ ê°•í™” (ğŸ”§ ì†ì ˆí­ ì—°ë™)
                    trail_stop = max(trail_stop, curp * (1.0 - max(trail_dist_min * 0.8, 0.0025)))
                    tg_send_mid(f"ğŸ”§ {m} ì¬ìƒìŠ¹ ê°ì§€ â†’ íŠ¸ë ˆì¼ ê°•í™”")
        
        if verdict is None:
            verdict = "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)"

    finally:
        # ================================
        # 1) ìµœì‹  ìƒíƒœ / ìˆ˜ìµë¥  ê³„ì‚°
        # ================================
        ticks = get_recent_ticks(m, 100)
        t15 = micro_tape_stats_from_ticks(ticks, 15) if ticks else {
            "buy_ratio": 0,
            "krw": 0,
            "n": 0,
            "krw_per_sec": 0
        }

        ob = pre.get("ob") or {}
        ob_depth_krw = ob.get("depth_krw", 10_000_000)

        # ğŸ”§ FIX: Division by Zero ë°©ì–´
        if entry_price > 0:
            try:
                ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
            except:
                ret_pct = 0.0
            maxrun = (best / entry_price - 1.0) * 100.0
            maxdd = (worst / entry_price - 1.0) * 100.0
        else:
            ret_pct = 0.0
            maxrun = 0.0
            maxdd = 0.0

        # ================================
        # 2) ëì•ŒëŒ ë¬¸êµ¬ ìƒì„±
        # ================================
        action, rationale = _end_reco(entry_price,
                                      last_price,
                                      c1,
                                      ticks,
                                      ob_depth_krw,
                                      ctx_thr=CTX_EXIT_THRESHOLD)

        # ===========================================
        # ëì•ŒëŒ / ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™”
        #  (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ê³¼ë‹¤ ë°©ì§€)
        # ===========================================
        if not reentry:
            pass  # ëì•ŒëŒ ë¹„í™œì„±í™”
        else:
            pass  # ì¬ëª¨ë‹ˆí„°ë§ ìš”ì•½ ë¹„í™œì„±í™”

        # ===========================================
        # ì¬ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
        #  - ìµœì´ˆ ëª¨ë‹ˆí„°ë§ì—ì„œë§Œ í˜¸ì¶œ
        #  - remonitor_until_close()ì—ì„œ ì¬í˜¸ì¶œëœ ê²½ìš°(reentry=True)ëŠ” ë‹¤ì‹œ ì•ˆ ë“¤ì–´ê°
        # ===========================================
        # âœ… ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™” (ë¶ˆí•„ìš”í•œ ë°˜ë³µ ë©”ì‹œì§€ ë°©ì§€)
        # (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ, ì•Œë¦¼ ë°œì†¡ë§Œ ì°¨ë‹¨)
        if AUTO_TRADE and m in OPEN_POSITIONS and not reentry:
            remonitor_until_close(m, entry_price, pre, tight_mode)

        # ===========================================
        # 3) probe ì†ì ˆ í›„ ë¹ ë¥¸ ì¬ì§„ì… í—ˆìš© ë¡œì§
        # ===========================================
        if AUTO_TRADE and verdict and "ì†ì ˆ" in verdict:
            # ğŸ”§ FIX: ë½ ë°–ì—ì„œ ì¬ì§„ì… ì—¬ë¶€ íŒë‹¨ í›„ sleep/remonitor ìˆ˜í–‰
            should_remonitor = False
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m)
                if pos and pos.get("entry_mode") == "probe":
                    # ìµœê·¼ ì¢…ë£Œ ì‹œê° ê¸°ë¡
                    pos["last_exit_ts"] = time.time()
                    OPEN_POSITIONS[m] = pos
                    should_remonitor = True

            # ğŸ”§ ë½ ë°–ì—ì„œ sleep ë° remonitor (ë½ 2ë¶„ ì ìœ  ë°©ì§€)
            if should_remonitor:
                REMONITOR_QUICK_COOLDOWN_SEC = 120  # 2ë¶„ ì¿¨ë‹¤ìš´
                time.sleep(REMONITOR_QUICK_COOLDOWN_SEC)
                remonitor_until_close(m, entry_price, pre, tight_mode)

        # ğŸ‘‡ ì´ return ì€ if ë°”ê¹¥ì—ì„œ í•­ìƒ ì‹¤í–‰ë˜ê²Œ
        return (
            verdict,
            action,
            rationale,
            ret_pct,
            last_price,
            maxrun,
            maxdd,
        )


# =========================
# ì•Œë¦¼
# =========================
def tg_send(t, retry=1):
    # TG_TOKEN ì—†ê±°ë‚˜ CHAT_IDSê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì½˜ì†”ì—ë§Œ ì¶œë ¥
    if not TG_TOKEN or not CHAT_IDS:
        print(t)
        return True

    ok_any = False
    for cid in CHAT_IDS:
        payload = {
            "chat_id": cid,
            "text": t,
            "parse_mode": "HTML",
            "disable_web_page_preview": True,
        }
        sent = False
        for _ in range(retry + 1):
            try:
                r = SESSION.post(
                    f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                    json=payload,
                    timeout=4,
                )
                if r.status_code == 200:
                    js = r.json()
                    if js.get("ok") is True:
                        ok_any = True
                        sent = True
                        break
                else:
                    # ë””ë²„ê¹…ìš©
                    print(f"[TG][{cid}] status={r.status_code} body={r.text}")
                    # ğŸ”§ FIX: HTML íŒŒì‹± ì‹¤íŒ¨ ì‹œ plain textë¡œ ì¬ì‹œë„
                    if r.status_code == 400 and "parse" in r.text.lower():
                        print(f"[TG][{cid}] HTML íŒŒì‹± ì‹¤íŒ¨ â†’ plain text ì¬ì‹œë„")
                        payload_plain = {
                            "chat_id": cid,
                            "text": t.replace("<b>", "").replace("</b>", ""),
                            "disable_web_page_preview": True,
                        }
                        try:
                            r2 = SESSION.post(
                                f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                                json=payload_plain,
                                timeout=4,
                            )
                            if r2.status_code == 200 and r2.json().get("ok"):
                                ok_any = True
                                sent = True
                                break
                        except:
                            pass
            except Exception as e:
                print(f"[TG][{cid}] exception: {e}")
            time.sleep(0.25 + rnd() * 0.25)
        # ğŸ”§ FIX: ëª¨ë“  ì‹œë„ ì‹¤íŒ¨ ì‹œ ë§ˆì§€ë§‰ìœ¼ë¡œ plain text ì‹œë„
        if not sent:
            try:
                payload_plain = {
                    "chat_id": cid,
                    "text": t.replace("<b>", "").replace("</b>", ""),
                    "disable_web_page_preview": True,
                }
                r3 = SESSION.post(
                    f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                    json=payload_plain,
                    timeout=4,
                )
                if r3.status_code == 200 and r3.json().get("ok"):
                    ok_any = True
            except Exception as e:
                print(f"[TG][{cid}] final plain fallback failed: {e}")
    return ok_any


# =========================
# ë©”ì¸ ë£¨í”„ ì¤€ë¹„
# =========================
last_signal_at = {}
recent_alerts = {}
last_price_at_alert = {}
last_reason = {}
last_trade_was_loss = {}  # ğŸ”§ ì†ì‹¤ í›„ ì¿¨ë‹¤ìš´ 2ë°°ìš©
ALERT_TTL = 1800

# =========================
# ì‹œê°„ëŒ€ë³„ ì¿¨ë‹¤ìš´ ì„¤ì •
# =========================
def get_cooldown_sec(market: str) -> int:
    """
    ê°™ì€ ì¢…ëª© ì¬ì§„ì… ëŒ€ê¸° ì‹œê°„(ì´ˆ)
    - 09ì‹œëŒ€: 3ë¶„
    - 10~14ì‹œ: 5ë¶„
    - ê·¸ ì™¸: ê¸°ë³¸ COOLDOWN(8ë¶„)
    - ğŸ”§ ì†ì‹¤ í›„: ì¿¨ë‹¤ìš´ 2ë°°
    """
    h = now_kst().hour

    if h == 9:
        base = 180  # 3ë¶„
    elif 10 <= h <= 14:
        base = 300  # 5ë¶„
    else:
        base = COOLDOWN  # ì „ì—­ ê¸°ë³¸ê°’(480)

    # ğŸ”§ ì†ì‹¤ í›„ ë™ì¼ ì¢…ëª© ì¬ì§„ì… ì¿¨ë‹¤ìš´ 2ë°°
    if last_trade_was_loss.get(market, False):
        return base * 2

    return base

def cooldown_ok(market, price=None, reason=None):
    now = time.time()
    last = last_signal_at.get(market, 0)

    # âœ… ì‹œê°„ëŒ€ë³„ ë™ì  ì¿¨ë‹¤ìš´ ì ìš©
    cooldown = get_cooldown_sec(market)

    # ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì¡°ê±´
    if (now - last) >= cooldown:
        return True

    # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(ì¬ëŒíŒŒ/ë˜ëŒë¦¼ ì¬ì§„ì… í—ˆìš©)ëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
    if (now - last) >= REARM_MIN_SEC:
        lp = last_price_at_alert.get(market)
        rebreak = (price and lp and (price >= lp * (1.0 + REARM_PRICE_GAP)))
        reason_changed = (last_reason.get(market) != reason)
        rebreak_small = (price and lp
                         and (price >= lp * (1.0 + REARM_REBREAK_MIN))
                         and not reason_changed)
        pullback = (price and lp
                    and (price <= lp * (1.0 - REARM_PULLBACK_MAX)))
        if rebreak or rebreak_small or (pullback and reason_changed):
            return True
    return False

def cleanup_expired(dic, ttl):
    now = time.time()
    drop = [k for k, v in dic.items() if now - v >= ttl]
    for k in drop:
        dic.pop(k, None)


# =========================
# ì„¤ì • ê²€ì¦
# =========================
def validate_config():
    errors = []
    warnings = []
    if TOP_N > 200: errors.append(f"TOP_N={TOP_N} ë„ˆë¬´ í¼ (â‰¤200 ê¶Œì¥)")
    if STOP_LOSS_PCT >= 0.05:
        warnings.append(f"STOP_LOSS_PCT={STOP_LOSS_PCT*100:.1f}% í¼ (<5%)")
    if PARALLEL_WORKERS > 30:
        warnings.append(f"PARALLEL_WORKERS={PARALLEL_WORKERS} ê³¼ë‹¤")
    if MIN_TURNOVER <= 0 or MIN_TURNOVER >= 1:
        errors.append(f"MIN_TURNOVER={MIN_TURNOVER} ë²”ìœ„ ì˜¤ë¥˜ (0~1)")
    if TICKS_BUY_RATIO < 0.5 or TICKS_BUY_RATIO > 1:
        errors.append(f"TICKS_BUY_RATIO={TICKS_BUY_RATIO} ë²”ìœ„ ì˜¤ë¥˜ (0.5~1)")
    if not TG_TOKEN or not CHAT_IDS: warnings.append("í…”ë ˆê·¸ë¨ ë¯¸ì„¤ì • - ì½˜ì†” ì¶œë ¥ë§Œ ì‚¬ìš©")
    if _BUCKET.get("rate", 0) <= 0: warnings.append("í† í°ë²„í‚· rate<=0 â†’ 0.1ë¡œ í´ë¨í”„")
    if _BUCKET.get("cap", 0) <= 0: warnings.append("í† í°ë²„í‚· cap<=0 â†’ 1.0ë¡œ í´ë¨í”„")
    if warnings:
        print("[CONFIG_WARNING]")
        for w in warnings:
            print("  âš ï¸", w)
    if errors:
        print("[CONFIG_ERROR]")
        for e in errors:
            print("  âŒ", e)
        sys.exit(1)
    print("âœ… ì„¤ì • ê²€ì¦ ì™„ë£Œ")


# =========================
# í—¬ìŠ¤ì²´í¬ ì„œë²„(ì˜µì…˜)
# =========================
from http.server import HTTPServer, BaseHTTPRequestHandler

bot_start_time = 0


class HealthHandler(BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        if self.path == "/health":
            status = {
                "status":
                "running",
                "version":
                "3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry",
                "uptime_sec":
                int(time.time() - bot_start_time),
                "uptime_str":
                str(timedelta(seconds=int(time.time() - bot_start_time))),
                "last_scan":
                now_kst_str(),
                "req_stats":
                REQ_STATS,
                "alerts_count":
                len(last_signal_at),
                "cache_size":
                len(_TICKS_CACHE.cache)
                if hasattr(_TICKS_CACHE, 'cache') else 0,
                "config": {
                    "top_n": TOP_N,
                    "scan_interval": SCAN_INTERVAL,
                    "stop_loss_pct": STOP_LOSS_PCT
                }
            }
            self.send_response(200)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(
                json.dumps(status, ensure_ascii=False).encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_health_server(port=8080):
    for p in range(port, port + 5):
        try:
            server = HTTPServer(("0.0.0.0", p), HealthHandler)
            thread = threading.Thread(target=server.serve_forever, daemon=True)
            thread.start()
            print(f"ğŸ¥ Health check server: http://localhost:{p}/health")
            return
        except OSError:
            continue
    print("[HEALTH_ERR] í¬íŠ¸ ì‚¬ìš© ë¶ˆê°€ (8080~8084)")


def start_watchdogs():
    """ì›Œì¹˜ë… ìŠ¤ë ˆë“œë“¤ ì‹œì‘: í—¬ìŠ¤ë¹„íŠ¸, ì„¸ì…˜ ë¦¬í”„ë ˆì‹œ, ë½ ì²­ì†Œ"""

    def heartbeat():
        """5ë¶„ë§ˆë‹¤ ìƒíƒœ ë¡œê¹… (ì¡°ìš©íˆ ì£½ì—ˆëŠ”ì§€ í™•ì¸ìš©)"""
        while True:
            try:
                time.sleep(300)  # 5ë¶„
                req_summary()     # 429/5xx/ì—ëŸ¬ ì¹´ìš´íŠ¸
                cut_summary()     # í•„í„° ì»· ì¹´ìš´íŠ¸ ìš”ì•½
                print(f"[HB] {now_kst_str()} open={len(OPEN_POSITIONS)} "
                      f"rate={_BUCKET.get('rate', 0):.2f} cap={_BUCKET.get('cap', 0):.2f}")
            except Exception as e:
                print(f"[HB_ERR] {e}")

    def session_refresher():
        """10ë¶„ë§ˆë‹¤ ì„¸ì…˜ ë¦¬í”„ë ˆì‹œ (ì»¤ë„¥ì…˜ í’€ ì •ë¦¬)"""
        while True:
            time.sleep(600)  # 10ë¶„
            try:
                _refresh_session()
            except Exception as e:
                print(f"[SESSION_REFRESH_ERR] {e}")

    def lock_cleaner():
        """10ë¶„ë§ˆë‹¤ ì˜¤ë˜ëœ ë½íŒŒì¼ ì •ë¦¬"""
        while True:
            time.sleep(600)  # 10ë¶„
            try:
                cleanup_stale_entry_locks(300)  # 5ë¶„ ì´ìƒ ëœ ë½ ì‚­ì œ
            except Exception as e:
                print(f"[LOCK_CLEANER_ERR] {e}")

    threading.Thread(target=heartbeat, daemon=True, name="Heartbeat").start()
    threading.Thread(target=session_refresher, daemon=True, name="SessionRefresh").start()
    threading.Thread(target=lock_cleaner, daemon=True, name="LockCleaner").start()
    print("ğŸ• ì›Œì¹˜ë… ì‹œì‘ë¨ (í—¬ìŠ¤ë¹„íŠ¸ 5ë¶„, ì„¸ì…˜ë¦¬í”„ë ˆì‹œ 10ë¶„, ë½ì²­ì†Œ 10ë¶„)")


# ===== ì˜¤ë”ë¶ ìºì‹œ =====
def fetch_orderbook_cache(mkts):
    cache = {}
    for i in range(0, len(mkts), 15):
        js = safe_upbit_get("https://api.upbit.com/v1/orderbook",
            {"markets": ",".join(mkts[i:i + 15])},
            timeout=6)
        if not js: continue
        for ob in js:
            try:
                units = ob["orderbook_units"][:3]
                ask, bid = units[0]["ask_price"], units[0]["bid_price"]
                spread = (ask - bid) / max((ask + bid) / 2, 1) * 100
                askv = sum(u["ask_price"] * u["ask_size"] for u in units)
                bidv = sum(u["bid_price"] * u["bid_size"] for u in units)
                cache[ob["market"]] = {
                    "spread": spread,
                    "depth_krw": askv + bidv,
                    "raw": ob
                }
            except:
                pass
    return cache


# =========================
# ë©”ì¸
# =========================
SHARD_SIZE = TOP_N
_cursor = 0
_last_learn_ts = 0  # ë§ˆì§€ë§‰ í•™ìŠµ ì‹œê°


def main():
    global _cursor, _last_learn_ts

    # ğŸ§  ì‹œì‘ ì‹œ í•™ìŠµëœ ê°€ì¤‘ì¹˜ & ë§¤ë„ íŒŒë¼ë¯¸í„° ë¡œë“œ
    if AUTO_LEARN_ENABLED:
        load_learned_weights()
        load_exit_params()

    tg_send(
        f"ğŸš€ ëŒ€ì¥ì´ˆì… í—Œí„° v3.2.7+Score (ìë™í•™ìŠµ+ë™ì ë§¤ë„) ì‹œì‘\n"
        f"ğŸ“Š TOP {TOP_N} | í•™ìŠµ: {AUTO_LEARN_MIN_TRADES}ê±´~ | {now_kst_str()}"
    )

    # ğŸ”§ ì‹œì‘ ì‹œ ìœ ë ¹ í¬ì§€ì…˜ ì¦‰ì‹œ ë™ê¸°í™”
    global _LAST_ORPHAN_SYNC
    _LAST_ORPHAN_SYNC = 0  # ê°•ì œ ë¦¬ì…‹
    sync_orphan_positions()

    while True:
        try:
            # ğŸ”§ Health check - watchdogìš© íŒŒì¼ ì—…ë°ì´íŠ¸
            try:
                with open("/home/ubuntu/bot/health.log", "w") as hf:
                    hf.write(f"{time.time()}\n")
            except:
                pass

            # BTC_guard ì œê±° â€” í•­ìƒ ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰
            tight_mode = False

            # ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™” (ì—…ë¹„íŠ¸ ì”ê³  vs OPEN_POSITIONS)
            sync_orphan_positions()

            # ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ì²´í¬ (ì¥ì´ˆ 2ì°¨ ê¸°íšŒ ì§„ì…)
            if RETEST_MODE_ENABLED:
                cleanup_retest_watchlist()  # íƒ€ì„ì•„ì›ƒ ì •ë¦¬
                with _RETEST_LOCK:
                    watch_markets = list(_RETEST_WATCHLIST.keys())
                for wm in watch_markets:
                    try:
                        retest_pre = check_retest_entry(wm)
                        if retest_pre:
                            # ë¦¬í…ŒìŠ¤íŠ¸ ì¡°ê±´ ì¶©ì¡± â†’ ì§„ì…
                            print(f"[RETEST] {wm} ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì… ì‹œì‘!")
                            c1 = get_minutes_candles(1, wm, 20)
                            dyn_stop, eff_sl_pct, _ = dynamic_stop_loss(retest_pre["price"], c1)
                            tg_send(f"ğŸ¯ <b>ë¦¬í…ŒìŠ¤íŠ¸ ì§„ì…</b> {wm}\n"
                                    f"â€¢ ì²« ê¸‰ë“± í›„ ë˜ëŒë¦¼ â†’ ì§€ì§€ í™•ì¸\n"
                                    f"â€¢ í˜„ì¬ê°€: {retest_pre['price']:,.0f}ì›")
                            open_auto_position(wm, retest_pre, dyn_stop, eff_sl_pct)
                    except Exception as e:
                        print(f"[RETEST_ERR] {wm}: {e}")

            # ğŸ”§ í•™ìŠµì€ update_trade_resultì—ì„œ ê±´ìˆ˜ ê¸°ë°˜ìœ¼ë¡œ ìë™ íŠ¸ë¦¬ê±°ë¨
            # (10ê±´ë§ˆë‹¤ ë˜ëŠ” ì—°ì† 3íŒ¨ ì‹œ ì¦‰ì‹œ í•™ìŠµ)
            # ë§¤ë„ íŒŒë¼ë¯¸í„°ëŠ” ê³ ì • (ë§¤ìˆ˜ë§Œ í•™ìŠµ)

            for k in list(CUT_COUNTER.keys()):
                CUT_COUNTER[k] = 0

            cleanup_expired(recent_alerts, ALERT_TTL)
            cleanup_expired(last_signal_at, COOLDOWN)
            _TICKS_CACHE.purge_older_than(max_age_sec=2.5)
            _C5_CACHE.purge_older_than(max_age_sec=2.5)

            mkts_all = get_top_krw_by_24h(TOP_N)
            if not mkts_all:
                aligned_sleep(SCAN_INTERVAL)
                continue

            start = _cursor
            end = _cursor + SHARD_SIZE
            shard = mkts_all[start:end]
            if len(shard) < SHARD_SIZE:
                shard += mkts_all[:(SHARD_SIZE - len(shard))]
            # ğŸ”§ FIX: shard ì¤‘ë³µ ì œê±° (wrap-around ì‹œ ì¤‘ë³µ ë°©ì§€)
            shard = list(dict.fromkeys(shard))
            _cursor = (end) % len(mkts_all)

            obc = fetch_orderbook_cache(shard)

            c1_cache = {}
            use_workers = min(PARALLEL_WORKERS, len(shard))
            with ThreadPoolExecutor(max_workers=use_workers) as exe:
                futures = {
                    exe.submit(get_minutes_candles, 1, m, 20): m
                    for m in shard
                }
                for f in as_completed(futures):
                    m = futures[f]
                    try:
                        c1_cache[m] = f.result() or []
                    except:
                        c1_cache[m] = []

            found = 0
            for m in shard:
              try:  # ğŸ”§ ì‹¬ë³¼ë³„ ì˜ˆì™¸ ê²©ë¦¬ (í•œ ì‹¬ë³¼ ì—ëŸ¬ê°€ ì „ì²´ ìŠ¤ìº” ì¤‘ë‹¨ ë°©ì§€)
                c1 = c1_cache.get(m, [])
                if not c1: continue

                pre = detect_leader_stock(m, obc, c1, tight_mode=tight_mode)
                if not pre: continue

                # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… ëª¨ë“œ ì¶”ê°€ (probe/confirm ë¶„ë¦¬) ===
                # ğŸ”§ í‚¬ëŸ¬ ì¡°ê±´: ëª¨ë“  ì¡°ê±´ ì¶©ì¡± ì‹œì—ë§Œ í’€ì§„ì…
                buy_ratio = pre["tape"]["buy_ratio"]
                volume_surge = pre.get("volume_surge", 1.0)
                current_vol = pre.get("current_volume", 0)
                # ğŸ”§ FIX: turn/imbalanceëŠ” tapeì— ì—†ìŒ â†’ ì§ì ‘ ê³„ì‚°
                ob = pre.get("ob", {}) or {}
                turn = pre["tape"]["krw"] / max(ob.get("depth_krw", 1), 1)
                imbalance = calc_orderbook_imbalance(ob)

                # í‚¬ëŸ¬ ì¡°ê±´ ì„ê³„ì¹˜ (í•œ ê³³ì—ì„œ ê´€ë¦¬)
                K_VOL_BASE = 100_000_000   # ê±°ë˜ëŒ€ê¸ˆ 1ì–µ
                K_VOL_SURGE = 2.0          # ì„œì§€ 2ë°°
                K_BUY = 0.70               # ë§¤ìˆ˜ë¹„ 70%
                K_TURN = 0.08              # íšŒì „ìœ¨ 8%
                K_IMB = 0.3                # ì²´ê²°ê°•ë„ 0.3
                K_CONSEC = 8               # ì—°ì†ë§¤ìˆ˜ 8íšŒ

                # í‚¬ëŸ¬ ì¡°ê±´ (ëª¨ë‘ ì¶©ì¡± ì‹œ confirm)
                killer_vol_base = current_vol >= K_VOL_BASE
                killer_vol_surge = volume_surge >= K_VOL_SURGE
                killer_buy = buy_ratio >= K_BUY
                killer_turn = turn >= K_TURN
                killer_imb = imbalance >= K_IMB
                # ì—°ì†ë§¤ìˆ˜ ì¡°ê±´
                ticks_for_killer = pre.get("ticks", [])
                cons_buys = calc_consecutive_buys(ticks_for_killer, 15) if ticks_for_killer else 0
                killer_consec = cons_buys >= K_CONSEC

                all_killer = (killer_vol_base and killer_vol_surge and
                              killer_buy and killer_turn and killer_imb and killer_consec)

                # í‚¬ëŸ¬ ì¡°ê±´ ìƒì„¸ ì €ì¥ (í…”ë ˆê·¸ë¨ìš©) - ê³ ì • í‚¤ ì‚¬ìš©
                pre["killer_details"] = {
                    "vol_base": current_vol,
                    "vol_surge": volume_surge,
                    "buy_ratio": buy_ratio,
                    "turn": turn,
                    "imbalance": imbalance,
                    "consecutive_buys": cons_buys,
                    # ì„ê³„ì¹˜ ì €ì¥ (ì•ŒëŒì—ì„œ ë™ì  í‘œì‹œìš©)
                    "thresholds": {
                        "vol_base": K_VOL_BASE,
                        "vol_surge": K_VOL_SURGE,
                        "buy": K_BUY,
                        "turn": K_TURN,
                        "imb": K_IMB,
                        "consec": K_CONSEC,
                    },
                    # í†µê³¼ ì—¬ë¶€ (ê³ ì • í‚¤)
                    "checks": {
                        "vol_base": killer_vol_base,
                        "vol_surge": killer_vol_surge,
                        "buy": killer_buy,
                        "turn": killer_turn,
                        "imb": killer_imb,
                        "consec": killer_consec,
                    }
                }

                # í‚¬ëŸ¬ ì¡°ê±´ í†µê³¼ê°’ ì „ì²´ í‘œì‹œ (í†µì¼ëœ í˜•ì‹: âœ“/âœ— + ê°’â‰¥ê¸°ì¤€)
                killer_vals = " ".join([
                    f"{'âœ“' if killer_buy else 'âœ—'}ë§¤ìˆ˜{buy_ratio:.0%}â‰¥{K_BUY:.0%}",
                    f"{'âœ“' if killer_turn else 'âœ—'}íšŒì „{turn:.0%}â‰¥{K_TURN:.0%}",
                    f"{'âœ“' if killer_consec else 'âœ—'}ì—°ì†{cons_buys}â‰¥{K_CONSEC}",
                    f"{'âœ“' if killer_vol_base else 'âœ—'}ê±°ë˜ëŒ€ê¸ˆ{current_vol/1e8:.1f}ì–µâ‰¥{K_VOL_BASE/1e8:.0f}",
                    f"{'âœ“' if killer_vol_surge else 'âœ—'}ì„œì§€{volume_surge:.1f}xâ‰¥{K_VOL_SURGE:.0f}",
                    f"{'âœ“' if killer_imb else 'âœ—'}ì²´ê²°{imbalance:.2f}â‰¥{K_IMB}",
                ])

                if all_killer:
                    pre["entry_mode"] = "confirm"
                    print(f"[CONFIRM] {m} {pre.get('signal_tag', '?')} | {killer_vals}")
                else:
                    pre["entry_mode"] = "probe"
                    fail_cnt = sum([not killer_buy, not killer_turn, not killer_consec,
                                    not killer_vol_base, not killer_vol_surge, not killer_imb])
                    print(f"[PROBE] {m} {pre.get('signal_tag', '?')} | {killer_vals} ({fail_cnt}ê°œ íƒˆë½ìœ¼ë¡œ confirm ì‹¤íŒ¨)")

                payload = final_check_leader(m, pre, tight_mode=tight_mode)
                if not payload: continue

                # ğŸ”§ FIX: score/filter_typeì„ preì— ë³µì‚¬ (ìë™ë§¤ìˆ˜ ì•ŒëŒì—ì„œ ì‚¬ìš©)
                pre["score"] = payload.get("score", 0)
                pre["filter_type"] = payload.get("filter_type", "ê¸°ë³¸í†µê³¼")

                # â˜…â˜…â˜… í”„ë¦¬ì‹œì „ í¬ì¼“: ê°•ì§„ì… ëª¨ë“œ ìŠ¹ê²© â˜…â˜…â˜…
                # ì¡°ê±´: ì„ë°¸ >= 0.6 AND ë§¤ìˆ˜ë¹„ >= 63.5% (ì •ë°€ë„ ~82%)
                if payload.get("is_precision_pocket"):
                    pre["entry_mode"] = "confirm"  # probe â†’ confirm ìŠ¹ê²©

                # ğŸ”§ FIX: postcheck ì „ ì¤‘ë³µ ì²´í¬ + ì¦‰ì‹œ ë§ˆí‚¹ (6ì´ˆ ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ìº” ì°¨ë‹¨)
                with _POSITION_LOCK:
                    if m in OPEN_POSITIONS:
                        continue
                    # ğŸ”§ FIX: recent_alertsë„ ë½ ì•ˆì—ì„œ ì²´í¬ (10ì´ˆ ì´ë‚´ë§Œ ì°¨ë‹¨ - postcheck ë™ì•ˆë§Œ)
                    if m in recent_alerts and time.time() - recent_alerts[m] < 10:
                        continue
                    # ğŸ”§ FIX: postcheck ì „ì— ë¯¸ë¦¬ ë§ˆí‚¹ (ë‹¤ë¥¸ ìŠ¤ìº” ì°¨ë‹¨)
                    recent_alerts[m] = time.time()

                # === 6ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ ===
                ok_post, post_reason = postcheck_6s(m, pre)
                if not ok_post:
                    cut("POSTCHECK_DROP", f"{m} postcheck fail: {post_reason}")
                    # ğŸ”§ FIX: postcheck ì‹¤íŒ¨ ì‹œ recent_alerts ì œê±° (ë‹¤ìŒ ìŠ¤ìº”ì—ì„œ ì¬ì‹œë„ ê°€ëŠ¥)
                    with _POSITION_LOCK:
                        recent_alerts.pop(m, None)
                    continue

                # ğŸ”§ FIX: postcheck í›„ ì¬í™•ì¸ ì œê±° (ì´ë¯¸ ìœ„ì—ì„œ ë§ˆí‚¹ë¨)

                reason = "ign" if pre.get("ign_ok") else (
                    "early" if pre.get("early_ok") else
                    ("mega" if pre.get("mega_ok") else "normal"))
                if not cooldown_ok(m, pre['price'], reason=reason):
                    continue

                # ğŸ”§ FIX: ì´ˆì… ì‹ í˜¸ ë°œì†¡ ì „ ì¤‘ë³µ ì§„ì… ì°¨ë‹¨ (race condition ë°©ì§€)
                # ğŸ” íŒŒì¼ë½ íšë“ ì‹œë„ (í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ )
                if not _try_acquire_entry_lock(m):
                    print(f"[LOCK] {m} already locked â†’ skip")
                    continue

                # ğŸ”§ FIX: íŒŒì¼ë½ íšë“ í›„ OPEN_POSITIONSë§Œ ì¬í™•ì¸ (recent_alertsëŠ” ì´ë¯¸ ìœ„ì—ì„œ ë§ˆí‚¹ë¨)
                with _POSITION_LOCK:
                    if m in OPEN_POSITIONS:
                        print(f"[SCAN] {m} ì´ë¯¸ í¬ì§€ì…˜/pending ì¡´ì¬ â†’ ìŠ¤í‚µ")
                        _release_entry_lock(m)
                        continue
                    # ë¯¸ë¦¬ pending ë§ˆí‚¹ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œ ì°¨ë‹¨)
                    OPEN_POSITIONS[m] = {"state": "pending", "pre_signal": True}
                    # recent_alertsëŠ” postcheck ì „ì— ì´ë¯¸ ì„¤ì •ë¨ (line 5684)
                    last_signal_at[m] = time.time()
                    last_price_at_alert[m] = pre['price']
                    last_reason[m] = reason

                # ë™ì  ì†ì ˆê°€
                dyn_stop, eff_sl_pct, _ = dynamic_stop_loss(pre['price'], c1)

                # ìŠ¤ì½”ì–´/ì„ë°¸ëŸ°ìŠ¤ í‘œì‹œ
                score_str = f"ìŠ¤ì½”ì–´ {payload.get('score', 0)}" if USE_RISK_SCORE else ""
                imb_str = f"ì„ë°¸ {payload.get('imbalance', 0):.2f}"
                pocket_mark = "ğŸ¯" if payload.get("is_precision_pocket") else ""

                # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
                filter_type = pre.get("filter_type", "stage1_gate")
                if filter_type == "prebreak":
                    path_str = "ğŸš€ì„ í–‰ì§„ì…"
                else:
                    path_str = pre.get("signal_tag", "ê¸°ë³¸")

                # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°: ì²´ê²°ê°•ë„, í‹±ë‹¹ê¸ˆì•¡, ê°€ì†ë„
                ticks_for_metrics = pre.get("ticks", [])
                t15_for_avg = micro_tape_stats_from_ticks(ticks_for_metrics, 15)
                cons_buys = calc_consecutive_buys(ticks_for_metrics, 15)
                avg_krw = calc_avg_krw_per_tick(t15_for_avg)
                flow_accel = calc_flow_acceleration(ticks_for_metrics)

                # ê°€ì†ë„ ì´ëª¨ì§€
                accel_emoji = "ğŸš€" if flow_accel >= 1.5 else ("ğŸ“‰" if flow_accel <= 0.7 else "â¡ï¸")

                # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
                overheat = flow_accel * float(payload.get("volume_surge", 1.0))
                fresh_age = 0.0
                if ticks_for_metrics:
                    now_ms = int(time.time() * 1000)
                    last_tick_ts = ticks_for_metrics[0].get("timestamp", now_ms)
                    fresh_age = (now_ms - last_tick_ts) / 1000.0

                # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ê³„ì‚°
                ia_stats = inter_arrival_stats(ticks_for_metrics, 30) if ticks_for_metrics else {"cv": 0.0}
                cv_val = ia_stats.get("cv", 0.0)
                pstd_val = price_band_std(ticks_for_metrics, sec=10) if ticks_for_metrics else 0.0
                prebreak_band_val = dynamic_prebreak_band(ticks_for_metrics) if ticks_for_metrics else PREBREAK_HIGH_PCT
                is_prebreak = pre.get("filter_type") == "prebreak"
                # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
                try:
                    u0 = pre.get("ob", {}).get("raw", {}).get("orderbook_units", [])[0]
                    best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
                except Exception:
                    best_ask_krw = 0.0

                # CV ì´ëª¨ì§€ (ë´‡/ì‚¬ëŒ íŒë‹¨)
                cv_emoji = "ğŸ¤–" if cv_val <= 0.45 else ("âš”ï¸" if cv_val >= 1.2 else "")

                txt = (
                    f"âš¡ <b>ì´ˆì… ì‹ í˜¸</b> {m} <code>#{reason}</code>{pocket_mark}\n"
                    f"ğŸ’µ í˜„ì¬ê°€ {fmt6(pre['price'])}ì›\n"
                    f"ğŸ“Š ë“±ë½ {payload['chg']}% | ê±°ë˜ì¦ê°€ {payload['volume_surge']}ë°° | íšŒì „ {payload['turn']}%\n"
                    f"ğŸ”¸ë§¤ìˆ˜ {payload['buy']}% | í‹± {payload['n']} | ìŠ¤í”„ë ˆë“œ {payload['spread']}% | {imb_str}\n"
                    f"ğŸ”¥ ì—°ì†ë§¤ìˆ˜ {cons_buys}íšŒ | í‹±ë‹¹ {avg_krw/1000:.0f}K | ê°€ì† {flow_accel:.1f}x {accel_emoji}\n"
                    f"ğŸŒ¡ï¸ ê³¼ì—´ {overheat:.1f} | í‹±ë‚˜ì´ {fresh_age:.1f}ì´ˆ\n"
                    f"ğŸ“ˆ CV {cv_val:.2f}{cv_emoji} | pstd {pstd_val*100:.3f}% | í˜¸ê°€ {best_ask_krw/1000:.0f}K\n"
                    f"ğŸ§¯ ì†ì ˆê°€: {fmt6(dyn_stop)} (ë™ì SL {eff_sl_pct*100:.2f}%)\n"
                    f"ğŸ” ê²½ë¡œ: {path_str}\n"
                    f"{link_for(m)}")

                sent = tg_send(txt, retry=2)

                if sent:
                    found += 1
                    # --- ë¡œê·¸ CSV ê¸°ë¡ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ) ---
                    try:
                        c5 = get_minutes_candles(5, m, 2) or []
                        c15 = get_minutes_candles(15, m, 2) or []
                        chg_1m = (c1[-1]["trade_price"] /
                                  max(c1[-2]["trade_price"], 1) -
                                  1) if len(c1) >= 2 else 0.0
                        chg_5m = (c5[-1]["trade_price"] /
                                  max(c5[-2]["trade_price"], 1) -
                                  1) if len(c5) >= 2 else ""
                        chg_15m = (c15[-1]["trade_price"] /
                                   max(c15[-2]["trade_price"], 1) -
                                   1) if len(c15) >= 2 else ""

                        cbtc1 = get_minutes_candles(1, "KRW-BTC", 2) or []
                        btc1m = (cbtc1[-1]["trade_price"] /
                                 max(cbtc1[-2]["trade_price"], 1) -
                                 1) if len(cbtc1) >= 2 else 0.0
                        cbtc5 = get_minutes_candles(5, "KRW-BTC", 2) or []
                        btc5m = (cbtc5[-1]["trade_price"] /
                                 max(cbtc5[-2]["trade_price"], 1) -
                                 1) if len(cbtc5) >= 2 else 0.0

                        t15_now = micro_tape_stats_from_ticks(pre["ticks"], 15)
                        ob = pre["ob"]
                        flags = {
                            "chg_1m":
                            chg_1m,
                            "chg_5m":
                            chg_5m,
                            "chg_15m":
                            chg_15m,
                            "zscore":
                            zscore_krw_1m(c1, 30),
                            "vwap_gap": (c1[-1]["trade_price"] /
                                         max(vwap_from_candles_1m(c1, 20), 1) -
                                         1) if len(c1) >= 1 else 0.0,
                            "turn":
                            round((t15_now["krw"] / max(ob["depth_krw"], 1)) *
                                  100, 2),
                            "two_green_break":
                            pre.get("two_green_break", False),
                            "ignition_ok":
                            pre.get("ign_ok", False),
                            "early_ok":
                            pre.get("early_ok", False),
                            "uptick_ok":
                            True
                        }
                        row = snapshot_row(m, pre["price"], payload, pre, c1,
                                           ob, t15_now, btc1m, btc5m, flags)
                        append_csv(row)
                    except Exception as e:
                        print("[LOG_ERR]", e)

                    # --- ğŸ”¥ ìë™ë§¤ìˆ˜ ì§„ì… ---
                    # ğŸ¯ ë¦¬í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ì¥ì´ˆ ì²« ì–‘ë´‰ì€ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ì—ë§Œ ë“±ë¡
                    if RETEST_MODE_ENABLED and is_morning_session():
                        # ê¸‰ë“±ë¥  ì²´í¬ (ì‹ í˜¸ê°€ ëŒ€ë¹„ í˜„ì¬ê°€)
                        cur_price = pre.get("price", 0)
                        entry_price_base = pre.get("entry_price", cur_price)
                        gain_pct = (cur_price / entry_price_base - 1.0) if entry_price_base > 0 else 0

                        if gain_pct >= RETEST_PEAK_MIN_GAIN:
                            # ì²« ê¸‰ë“± â†’ ì›Œì¹˜ë¦¬ìŠ¤íŠ¸ ë“±ë¡, ë°”ë¡œ ì§„ì… X
                            add_to_retest_watchlist(m, cur_price, pre)
                            print(f"[RETEST] {m} ì¥ì´ˆ ì²« ê¸‰ë“± +{gain_pct*100:.2f}% â†’ ë¦¬í…ŒìŠ¤íŠ¸ ëŒ€ê¸° (ë°”ë¡œ ì§„ì… X)")
                            _release_entry_lock(m)
                            continue  # ë°”ë¡œ ì§„ì…í•˜ì§€ ì•Šê³  ë‹¤ìŒ ì¢…ëª©ìœ¼ë¡œ

                    # ğŸ”§ FIX: ìŠ¤ìº” ë£¨í”„ì—ì„œ íšë“í•œ íŒŒì¼ë½ í•´ì œ (open_auto_positionì—ì„œ ë‹¤ì‹œ íšë“)
                    _release_entry_lock(m)
                    try:
                        open_auto_position(m, pre, dyn_stop, eff_sl_pct)
                    except Exception as e:
                        print("[AUTO_OPEN_ERR]", e)
                        # ğŸ”§ FIX: ìë™ë§¤ìˆ˜ ì‹¤íŒ¨ ì‹œ pre_signal pending ì •ë¦¬ + ë½ í•´ì œ
                        with _POSITION_LOCK:
                            pos = OPEN_POSITIONS.get(m)
                            if pos and pos.get("pre_signal"):
                                OPEN_POSITIONS.pop(m, None)
                        _release_entry_lock(m)

                    # --- í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ì²­ì‚°ê¹Œì§€ ì´ì–´ì§) ---
                    # ğŸ”§ FIX: ì‹ í˜¸ê°€ê°€ ì•„ë‹Œ ì‹¤ì œ ì²´ê²°ê°€ ì‚¬ìš©
                    with _POSITION_LOCK:
                        actual_entry = OPEN_POSITIONS.get(m, {}).get("entry_price", pre["price"])

                    # ğŸ”§ FIX: ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ëª¨ë‹ˆí„°ë§ ì‹¤í–‰ (ë©”ì¸ ìŠ¤ìº” ë£¨í”„ ë¸”ë¡œí‚¹ ë°©ì§€)
                    # ğŸ”§ FIX: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¤‘ë³µ ë°©ì§€ + ì£½ì€ ìŠ¤ë ˆë“œ ê°ì§€
                    with _MONITOR_LOCK:
                        existing_thread = _ACTIVE_MONITORS.get(m)
                        if existing_thread is not None:
                            # ğŸ”§ FIX: ìŠ¤ë ˆë“œê°€ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸ (is_alive)
                            if isinstance(existing_thread, threading.Thread) and existing_thread.is_alive():
                                print(f"[MON_SKIP] {m} ì´ë¯¸ ëª¨ë‹ˆí„°ë§ ì¤‘ â†’ ìŠ¤ë ˆë“œ ìƒì„± ìŠ¤í‚µ")
                                _release_entry_lock(m)
                                continue
                            # ì£½ì€ ìŠ¤ë ˆë“œë©´ ì •ë¦¬í•˜ê³  ìƒˆë¡œ ì‹œì‘
                            print(f"[MON_CLEANUP] {m} ì£½ì€ ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ ì •ë¦¬")
                            _ACTIVE_MONITORS.pop(m, None)

                    pre_copy = dict(pre)  # í´ë¡œì € ë¬¸ì œ ë°©ì§€
                    def _run_monitor(market, entry, pre_data, tight):
                        try:
                            monitor_position(market, entry, pre_data, tight_mode=tight)
                        except Exception as e:
                            print(f"[MON_ERR] {market}: {e}")
                            import traceback
                            traceback.print_exc()
                            # ğŸ”§ FIX: ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ŒëŒ + ì”ê³  í™•ì¸ í›„ ì •ë¦¬
                            try:
                                actual = get_balance_with_locked(market)
                                # ğŸ”§ FIX: -1 = ì¡°íšŒ ì‹¤íŒ¨ â†’ í¬ì§€ì…˜ ìœ ì§€ (ì˜¤íƒ ë°©ì§€)
                                if actual < 0:
                                    tg_send(f"âš ï¸ {market} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ (ì”ê³  ì¡°íšŒ ì‹¤íŒ¨)\nâ€¢ ì˜ˆì™¸: {e}\nâ€¢ í¬ì§€ì…˜ ìœ ì§€")
                                elif actual <= 1e-12:
                                    # ğŸ”§ FIX: ë§¤ìˆ˜ ì§í›„ 300ì´ˆ ë‚´ ì”ê³ =0ì€ API ì§€ì—°ì¼ ìˆ˜ ìˆìŒ â†’ í¬ì§€ì…˜ ìœ ì§€
                                    buy_age = time.time() - _RECENT_BUY_TS.get(market, 0)
                                    if buy_age < 300:
                                        tg_send(f"âš ï¸ {market} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ (ë§¤ìˆ˜ {buy_age:.0f}ì´ˆ ì „, ì”ê³ =0 but í¬ì§€ì…˜ ìœ ì§€)\nâ€¢ ì˜ˆì™¸: {e}")
                                    else:
                                        # ì”ê³  0ì´ë©´ ì´ë¯¸ ì²­ì‚°ë¨ â†’ ì•ŒëŒë§Œ ë°œì†¡
                                        tg_send(f"âš ï¸ {market} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ (ì´ë¯¸ ì²­ì‚°ë¨)\nâ€¢ ì˜ˆì™¸: {e}")
                                        with _POSITION_LOCK:
                                            OPEN_POSITIONS.pop(market, None)
                                else:
                                    # ì”ê³  ìˆìœ¼ë©´ ì²­ì‚° ì‹œë„
                                    tg_send(f"ğŸš¨ {market} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ â†’ ì²­ì‚° ì‹œë„\nâ€¢ ì˜ˆì™¸: {e}")
                                    close_auto_position(market, f"ëª¨ë‹ˆí„°ë§ì˜ˆì™¸ | {e}")
                            except Exception as cleanup_err:
                                print(f"[MON_CLEANUP_ERR] {market}: {cleanup_err}")
                                tg_send(f"ğŸš¨ {market} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ (ì²­ì‚° ì‹œë„ ì‹¤íŒ¨)\nâ€¢ ì˜ˆì™¸: {e}")
                        finally:
                            _release_entry_lock(market)
                            # ğŸ”§ FIX: ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ ì‹œ í™œì„± ëª©ë¡ì—ì„œ ì œê±°
                            with _MONITOR_LOCK:
                                _ACTIVE_MONITORS.pop(market, None)

                    mon_thread = threading.Thread(
                        target=_run_monitor,
                        args=(m, actual_entry, pre_copy, tight_mode),
                        daemon=True
                    )
                    mon_thread.start()
                    # ğŸ”§ FIX: ìŠ¤ë ˆë“œ ê°ì²´ ì €ì¥ (ident ëŒ€ì‹ )
                    with _MONITOR_LOCK:
                        _ACTIVE_MONITORS[m] = mon_thread
                else:
                    # ğŸ”§ FIX: ì‹ í˜¸ ë°œì†¡ ì‹¤íŒ¨ ì‹œ pre_signal pending ì •ë¦¬ + ë½ í•´ì œ
                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        if pos and pos.get("pre_signal"):
                            OPEN_POSITIONS.pop(m, None)
                    _release_entry_lock(m)

              except Exception as e:
                # ğŸ”§ ì‹¬ë³¼ë³„ ì˜ˆì™¸ ì²˜ë¦¬: ë½/íœë”© ì •ë¦¬ í›„ ë‹¤ìŒ ì‹¬ë³¼ ì§„í–‰
                print(f"[SYMBOL_ERR][{m}] {e}")
                traceback.print_exc()
                _release_entry_lock(m)
                with _POSITION_LOCK:
                    if OPEN_POSITIONS.get(m, {}).get("state") == "pending":
                        OPEN_POSITIONS.pop(m, None)

            cut_summary()
            if found == 0:
                req_summary()
            # ì‹œê°„ëŒ€ë³„ ë™ì  ìŠ¤ìº” ê°„ê²© ì ìš©
            aligned_sleep(get_scan_interval())

        except KeyboardInterrupt:
            print("Stopped by user.")
            break
        except Exception as e:
            print("[MAIN_ERR]", e)
            traceback.print_exc()
            print("[MAIN] 5ì´ˆ í›„ ì¬ì‹œì‘...")
            time.sleep(5)
            continue  # ğŸ’¡ ë‹¤ì‹œ ë£¨í”„ ì‹œì‘

if __name__ == "__main__":
    validate_config()
    bot_start_time = time.time()
    start_health_server()
    start_watchdogs()  # ğŸ• ì›Œì¹˜ë… ì‹œì‘ (í—¬ìŠ¤ë¹„íŠ¸/ì„¸ì…˜ë¦¬í”„ë ˆì‹œ/ë½ì²­ì†Œ)
    main()
