# -*- coding: utf-8 -*-
import os, time, math, requests, statistics, traceback, threading, csv, sys, json, random
from datetime import datetime, timedelta, timezone
from collections import deque, OrderedDict
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlencode

import uuid
import hashlib
import hmac
import jwt


def rnd():
    return random.random()  # â† ì´ ì¤„ì´ 4ì¹¸(ìŠ¤í˜ì´ìŠ¤) ë“¤ì—¬ì“°ê¸° ë˜ì–´ì•¼ í•¨

def fmt6(x):
    """
    ìˆ«ìë¥¼ ë³´ê¸° ì¢‹ê²Œ í‘œì‹œ:
    - ì •ìˆ˜ëŠ” ì†Œìˆ˜ì  ì—†ì´
    - ì†Œìˆ˜ì ì´ ìˆëŠ” ê²½ìš° ìµœëŒ€ 6ìë¦¬ê¹Œì§€ í‘œì‹œ
    """
    if isinstance(x, (int, float)):
        if abs(x - int(x)) < 1e-6:
            return f"{int(x):,}"
        else:
            s = f"{x:,.6f}".rstrip('0').rstrip('.')
            return s
    return str(x)

# =========================
# ì„¤ì • (24ì‹œê°„ ë‹¨íƒ€ ìµœì í™” + Bot-aware, 3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry)
# =========================
TOP_N = 60
SCAN_INTERVAL = 6
COOLDOWN = 480
PARALLEL_WORKERS = 12

# ==== Exit Control (anti-whipsaw) ====
WARMUP_SEC = 5  # ì§„ì… í›„ ì´ˆê¸° ë…¸ì´ì¦ˆ í—ˆìš© êµ¬ê°„
HARD_STOP_DD = 0.015  # -1.5% ê¸‰ë½ ì‹œ ì¦‰ì‹œ ì»· (strict ê¸°ì¤€)
EXIT_DEBOUNCE_SEC = 8  # ì²­ì‚° ì‹ í˜¸ ì§€ì† í™•ì¸ ì‹œê°„
EXIT_DEBOUNCE_N = 4  # ì—°ì† NíšŒ ì¡°ê±´ ì¶©ì¡± í•„ìš”

# íŠ¸ë ˆì¼ë§ ì†ì ˆ(ì´ìµë°œìƒ í›„ë§Œ ë¬´ì¥)
TRAIL_ARM_GAIN = 0.010  # +1.0% ì´ìµ ì‹œ íŠ¸ë ˆì¼ë§ í™œì„±í™” (ì¡°ê¸° ë¬´ì¥)
TRAIL_ATR_MULT = 1.15  # ATR ê¸°ë°˜ ì—¬ìœ í­
TRAIL_DISTANCE_MIN = 0.012  # ìµœì†Œ íŠ¸ë ˆì¼ ê°„ê²©(1.2%) (ì—¬ìœ  í™•ë³´)

# === ìˆ˜ìˆ˜ë£Œ ì„¤ì • (ì™•ë³µ 0.1% ë°˜ì˜) ===
FEE_RATE = 0.001  # 0.05% ë§¤ìˆ˜ + 0.05% ë§¤ë„

# === í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ ì „ì—­ ì„¤ì • ===
USE_5M_CONTEXT = False        # 5ë¶„ ì»¨í…ìŠ¤íŠ¸ ë¹„í™œì„±í™”
POSTCHECK_ENABLED = False     # ì´ˆì… ë‹¨ê³„ í¬ìŠ¤íŠ¸ì²´í¬ ë¹„í™œì„±í™”
EARLY_FLOW_MIN_KRWPSEC = 22_000  # ì´ˆê¸° ê±°ë˜ì†ë„ ì™„í™”

# --- í™˜ê²½ë³€ìˆ˜(.env ì§€ì›) ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

# ==== Exit Profile (gentle/ balanced / strict) ====
EXIT_PROFILE = os.getenv("EXIT_PROFILE", "strict").lower()


def _apply_exit_profile():
    """
    í”„ë¡œíŒŒì¼ë³„ ì²­ì‚° ë¯¼ê°ë„ ì„¸íŒ…
    - gentle  : ëŠìŠ¨(íœ©ì˜ ë‚´ì„±â†‘, ìˆ˜ìµ ìµœëŒ€í™” ì§€í–¥)
    - balanced: ê¸°ë³¸ê°’(í˜„ì¬ ë„¤ ì„¸íŒ… ê¸°ì¤€)
    - strict  : ì—„ê²©(ë³´ìˆ˜ì , ì†ì‹¤ì¶•ì†Œ ì§€í–¥)
    """
    global WARMUP_SEC, HARD_STOP_DD, EXIT_DEBOUNCE_SEC, EXIT_DEBOUNCE_N
    global TRAIL_ARM_GAIN, TRAIL_ATR_MULT, TRAIL_DISTANCE_MIN
    global SPIKE_RECOVERY_WINDOW, SPIKE_RECOVERY_MIN_BUY
    global CTX_EXIT_THRESHOLD

    prof = EXIT_PROFILE

    if prof == "gentle":
        WARMUP_SEC = 14
        HARD_STOP_DD = 0.024
        EXIT_DEBOUNCE_SEC = 10
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.007
        TRAIL_ATR_MULT = 1.20
        TRAIL_DISTANCE_MIN = 0.010
        SPIKE_RECOVERY_WINDOW = 4
        SPIKE_RECOVERY_MIN_BUY = 0.56
        CTX_EXIT_THRESHOLD = 4

    elif prof == "strict":
        WARMUP_SEC = 5
        HARD_STOP_DD = 0.015
        EXIT_DEBOUNCE_SEC = 6
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.012
        TRAIL_ATR_MULT = 1.10
        TRAIL_DISTANCE_MIN = 0.015
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.60
        CTX_EXIT_THRESHOLD = 3  # ì»¨í…ìŠ¤íŠ¸ ì—­ì „ ë¯¼ê°

    else:  # balanced (í˜„ì¬ ê°’ì— ê·¼ì ‘)
        WARMUP_SEC = 12
        HARD_STOP_DD = 0.022
        EXIT_DEBOUNCE_SEC = 8
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.006
        TRAIL_ATR_MULT = 1.15
        TRAIL_DISTANCE_MIN = 0.009
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.58
        CTX_EXIT_THRESHOLD = 3


_apply_exit_profile()

TG_TOKEN = os.getenv("TELEGRAM_TOKEN") or os.getenv("TG_TOKEN") or ""

# ğŸ“Œ ì—¬ëŸ¬ ëª…ì—ê²Œ ë³´ë‚´ê¸°ìš© chat_id ëª©ë¡
_raw_chats = (
    os.getenv("TG_CHATS")  # ìƒˆë¡œ ì“¸ ì¶”ì²œ í‚¤: "id1,id2,-100xxx"
    or os.getenv("TELEGRAM_CHAT_ID")  # ì˜ˆì „ ë‹¨ì¼ í‚¤ë„ í˜¸í™˜
    or os.getenv("TG_CHAT") or "")

CHAT_IDS = []
for part in _raw_chats.split(","):
    part = part.strip()
    if not part:
        continue
    try:
        CHAT_IDS.append(int(part))
    except Exception:
        print(f"[WARN] ì˜ëª»ëœ chat_id ê°’ ë¬´ì‹œë¨: {part}")

print("[DEBUG] CHAT_IDS =", CHAT_IDS)  # ì‹¤í–‰ ì‹œ í•œ ë²ˆ ì°í˜€ì„œ í™•ì¸ìš©

# =========================
# ğŸ”¥ ì—…ë¹„íŠ¸ Private API (ì£¼ë¬¸/ì”ê³ /í¬ì§€ì…˜ ê´€ë¦¬)
# =========================
import uuid, hashlib
import jwt
from urllib.parse import urlencode

UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY", "")
UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY", "")

print(
    "[UPBIT_KEYS] access_len=",
    len(UPBIT_ACCESS_KEY),
    "secret_len=",
    len(UPBIT_SECRET_KEY),
)

# AUTO_TRADE = 1 ì´ë©´ ì‹¤ì œ ì£¼ë¬¸, 0ì´ë©´ ì•Œë¦¼ + ëª¨ë‹ˆí„°ë§ë§Œ
AUTO_TRADE = os.getenv("AUTO_TRADE", "0") == "1"
RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.003"))  # ê³„ì¢Œì˜ 0.3% ë¦¬ìŠ¤í¬

print(f"[BOT_MODE] AUTO_TRADE={AUTO_TRADE}, RISK_PER_TRADE={RISK_PER_TRADE}")

# === ê³µê²© ëª¨ë“œ / í”¼ë¼ë¯¸ë”© ì„¤ì • ===
AGGRESSIVE_MODE = os.getenv("AGGRESSIVE_MODE", "1") == "1"

# ì†Œì•¡ ì„ ì§„ì… + ì¶”ë§¤ êµ¬ì¡°
USE_PYRAMIDING = os.getenv("USE_PYRAMIDING", "1") == "1"

# RISK_PER_TRADEë¥¼ ìª¼ê°œì„œ ì‚¬ìš© (seed + add)
# ì˜ˆ: RISK_PER_TRADE=0.003, SEED=0.55, ADD=0.55 ë©´ ëŒ€ëµ 1.1ë°° ì •ë„ ë¦¬ìŠ¤í¬ ì‚¬ìš©
SEED_RISK_FRACTION = float(os.getenv("SEED_RISK_FRACTION", "0.55"))
ADD_RISK_FRACTION = float(os.getenv("ADD_RISK_FRACTION", "0.55"))

# ì¶”ë§¤ íŠ¸ë¦¬ê±° ì¡°ê±´
PYRAMID_ADD_MIN_GAIN = float(os.getenv("PYRAMID_ADD_MIN_GAIN", "0.008"))  # +0.8% ì´ìƒì—ì„œ ì¶”ë§¤
PYRAMID_ADD_FLOW_MIN_BUY = float(os.getenv("PYRAMID_ADD_FLOW_MIN_BUY", "0.60"))  # ë§¤ìˆ˜ë¹„
PYRAMID_ADD_FLOW_MIN_KRWPSEC = float(os.getenv("PYRAMID_ADD_FLOW_MIN_KRWPSEC", "35000"))  # KRW/s
PYRAMID_ADD_COOLDOWN_SEC = int(os.getenv("PYRAMID_ADD_COOLDOWN_SEC", "12"))  # ì¶”ë§¤ ê°„ ìµœì†Œ ê°„ê²©(ì´ˆ)


# í˜„ì¬ ì—´ë¦° í¬ì§€ì…˜ ê¸°ë¡ìš©
# ì˜ˆ: { "KRW-BTC": {"entry_price":..., "volume":..., "stop":..., "sl_pct":..., "state":"open"} }
OPEN_POSITIONS = {}
_POSITION_LOCK = threading.Lock()  # í¬ì§€ì…˜ ì ‘ê·¼ ë½

# ğŸ”” ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ì¿¨íƒ€ì„ (ë¹„ë§¤ë§¤ ì•Œë¦¼ìš©)
REMONITOR_COOLDOWN_SEC = 300  # 5ë¶„
REMONITOR_LAST_ALERT = {}

# =========================
# ğŸ“ˆ ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹
# =========================
from collections import deque as _deque_for_risk  # ê¸°ì¡´ dequeì™€ ë³„ë„ alias

TRADE_HISTORY = _deque_for_risk(maxlen=30)  # ìµœê·¼ 30ê°œ ê±°ë˜ ê¸°ë¡


def record_trade(market: str, pnl_pct: float):
    """
    ê±°ë˜ ê²°ê³¼ ê¸°ë¡
    - pnl_pct: % ë‹¨ìœ„ ìˆ˜ìµë¥  (ì˜ˆ: +2.3, -1.5)
    """
    TRADE_HISTORY.append({
        "market": market,
        "pnl": pnl_pct,
        "win": pnl_pct > 0,
        "time": time.time(),
    })


def get_adaptive_risk() -> float:
    """
    ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ RISK_PER_TRADE ê°€ë³€ ì¡°ì •
    - íˆìŠ¤í† ë¦¬ 10ê±´ ë¯¸ë§Œ: ê¸°ë³¸ê°’
    - winrate < 30% : ë¦¬ìŠ¤í¬ 0.5ë°°
    - winrate >= 50%: ë¦¬ìŠ¤í¬ 1.2ë°°
    """
    if len(TRADE_HISTORY) < 10:
        return RISK_PER_TRADE

    wins = sum(1 for t in TRADE_HISTORY if t.get("win"))
    win_rate = wins / len(TRADE_HISTORY)

    if win_rate < 0.30:
        return RISK_PER_TRADE * 0.5
    elif win_rate >= 0.50:
        return RISK_PER_TRADE * 1.2
    else:
        return RISK_PER_TRADE

def _make_auth_headers(query: dict = None):
    payload = {
        'access_key': UPBIT_ACCESS_KEY,
        'nonce': str(uuid.uuid4()),
    }
    if query:
        q = urlencode(query).encode()
        m = hashlib.sha512()
        m.update(q)
        payload['query_hash'] = m.hexdigest()
        payload['query_hash_alg'] = 'SHA512'
    jwt_token = jwt.encode(payload, UPBIT_SECRET_KEY)
    return {"Authorization": f"Bearer {jwt_token}"}


def upbit_private_get(path, params=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    headers = _make_auth_headers(params or {})
    _throttle()
    r = SESSION.get(url, headers=headers, params=params, timeout=timeout)
    r.raise_for_status()
    return r.json()


def upbit_private_post(path, body=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    body = body or {}
    headers = _make_auth_headers(body)
    _throttle()
    r = SESSION.post(url, headers=headers, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()


def get_order_result(uuid_str, timeout_sec=6.0):
    """
    ì£¼ë¬¸ uuid ë¡œ ìµœì¢… ì²´ê²° ê²°ê³¼ ì¡°íšŒ
    - done / cancel / watch ìƒíƒœê°€ ë˜ê±°ë‚˜ timeout ë  ë•Œê¹Œì§€ polling
    """
    deadline = time.time() + timeout_sec
    last = None
    while time.time() < deadline:
        try:
            od = upbit_private_get("/v1/order", {"uuid": uuid_str})
            last = od
            state = od.get("state")
            if state in ("done", "cancel", "watch"):
                break
        except Exception as e:
            last = None
        time.sleep(0.25)
    return last


def get_account_info():
    """ì—…ë¹„íŠ¸ ê³„ì¢Œ(ì”ê³ ) ì¡°íšŒ"""
    try:
        return upbit_private_get("/v1/accounts")
    except Exception as e:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨:", e)
        return []


def calc_position_size(entry_price, stop_price, total_equity, risk_pct):
    """
    ì†ì ˆê°€ ê¸°ì¤€ìœ¼ë¡œ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    - total_equity * risk_pct ë§Œí¼ë§Œ ìµœëŒ€ ì†ì‹¤ í—ˆìš©
    """
    risk_krw = total_equity * risk_pct
    per_unit_loss = max(entry_price - stop_price,
                        entry_price * 0.01)  # ìµœì†Œ 1% ë°©ì–´
    qty = risk_krw / per_unit_loss
    return max(qty, 0)


def place_market_buy(market, krw_amount):
    """KRW ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ìˆ˜ (ord_type=price)"""
    body = {
        "market": market,
        "side": "bid",
        "ord_type": "price",
        "price": str(int(krw_amount))  # ì‚¬ìš©í•  KRW ê¸ˆì•¡
    }
    return upbit_private_post("/v1/orders", body)


def place_market_sell(market, volume):
    """ìˆ˜ëŸ‰ ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ë„"""
    body = {
        "market": market,
        "side": "ask",
        "ord_type": "market",
        "volume": str(volume)
    }
    return upbit_private_post("/v1/orders", body)


def sell_market(market, volume, max_attempts=3):
    """
    ì‹œì¥ê°€ ë§¤ë„ with ì¬ì‹œë„ ë¡œì§
    - market: ì¢…ëª© ì½”ë“œ
    - volume: ë§¤ë„ ìˆ˜ëŸ‰
    - max_attempts: ìµœëŒ€ ì‹œë„ íšŸìˆ˜ (ê¸°ë³¸ 3íšŒ)
    """
    for attempt in range(1, max_attempts + 1):
        try:
            res = place_market_sell(market, volume)
            if res and res.get("uuid"):
                # ì„±ê³µ: OPEN_POSITIONS ì—…ë°ì´íŠ¸
                with _POSITION_LOCK:
                    pos = OPEN_POSITIONS.get(market)
                    if pos:
                        current_vol = pos.get("volume", 0)
                        new_vol = max(0, current_vol - volume)
                        if new_vol > 0:
                            pos["volume"] = new_vol
                            OPEN_POSITIONS[market] = pos
                        else:
                            # ì „ëŸ‰ ë§¤ë„ â†’ í¬ì§€ì…˜ ì œê±°
                            OPEN_POSITIONS.pop(market, None)
                print(f"[SELL_OK] {market} ë§¤ë„ ì„±ê³µ: {volume:.6f} (ì‹œë„ {attempt}/{max_attempts})")
                return True
            else:
                print(f"[SELL_WARN] {market} ë§¤ë„ ì‘ë‹µ ì´ìƒ (ì‹œë„ {attempt}/{max_attempts}): {res}")
        except Exception as e:
            print(f"[SELL_ERR] {market} ë§¤ë„ ì‹¤íŒ¨ (ì‹œë„ {attempt}/{max_attempts}): {e}")
            if attempt < max_attempts:
                time.sleep(0.5 * attempt)  # ì¬ì‹œë„ ì „ ëŒ€ê¸° (0.5ì´ˆ, 1ì´ˆ, 1.5ì´ˆ...)

    # ëª¨ë“  ì‹œë„ ì‹¤íŒ¨
    tg_send(f"âš ï¸ <b>ë§¤ë„ ì‹¤íŒ¨</b> {market}\nìˆ˜ëŸ‰: {volume:.6f}\nì‚¬ìœ : sell failed after {max_attempts} attempts")
    return False


def final_price_guard(m, initial_price, max_drift=0.07):
    """
    ì£¼ë¬¸ ì§ì „ ê°€ê²© ì¬í™•ì¸
    - initial_price: ì‹ í˜¸ ë°œìƒ ì‹œ ê¸°ì¤€ ê°€ê²© (pre['price'])
    - max_drift: ì‹ í˜¸ê°€ ëŒ€ë¹„ í—ˆìš© ìƒìŠ¹ë¥  (ê¸°ë³¸ 1.8%)
    - AGGRESSIVE_MODE=True ì¸ ê²½ìš°, max_drift~max_drift+1.5% êµ¬ê°„ì€
      'ì¶”ê²© ì§„ì…'ìœ¼ë¡œ ì†Œì•¡/í”¼ë¼ë¯¸ë”© ê¸°ë°˜ ì§„ì… í—ˆìš©
    """
    try:
        js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        if not js:
            print(f"[GUARD] {m} í‹°ì»¤ ì¡°íšŒ ì‹¤íŒ¨ â†’ ê°€ë“œ ìŠ¤í‚µ")
            return True, initial_price

        current_price = js[0].get("trade_price", initial_price)
        drift = (current_price / initial_price - 1.0)

        if drift > max_drift:
            # í‰ì†Œë¼ë©´ ê³ ì  ì¶”ê²©ìœ¼ë¡œ ì»·
            # í•˜ì§€ë§Œ ê³µê²© ëª¨ë“œë©´ ì¼ì • êµ¬ê°„ê¹Œì§€ëŠ” í—ˆìš©
            if AGGRESSIVE_MODE and drift <= (max_drift + 0.015):
                print(
                    f"[GUARD][AGGR] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% "
                    f"â†’ ê³µê²© ëª¨ë“œ: ì¶”ê²© ì§„ì… í—ˆìš© (ì†Œì•¡/í”¼ë¼ë¯¸ë”© ì „ì œ)"
                )
                return True, current_price

            # ì´ ì´ìƒì€ ì§„ì§œ ë„ˆë¬´ íŠ„ ê±°ë¼ ì»·
            print(f"[GUARD] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% â†’ ì§„ì… ì·¨ì†Œ")
            return False, current_price

        return True, current_price

    except Exception as e:
        print(f"[GUARD_ERR] {m}: {e}")
        return True, initial_price

# =========================
# ğŸ”¥ ìë™ ë§¤ìˆ˜ ì§„ì…
# =========================
def open_auto_position(m, pre, dyn_stop, eff_sl_pct):
    """
    ì´ˆì…Â·ê³µê²©ëª¨ë“œ ëŒ€ì‘ ìë™ ë§¤ìˆ˜ ì§„ì…
    """
    if not AUTO_TRADE:
        return

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        print("[AUTO] API í‚¤ ë¯¸ì„¤ì • â†’ ìë™ë§¤ìˆ˜ ìŠ¤í‚µ")
        return

    # ì´ë¯¸ í¬ì§€ì…˜ ìˆìœ¼ë©´ ìŠ¤í‚µ
    with _POSITION_LOCK:
        if m in OPEN_POSITIONS:
            print(f"[AUTO] ì´ë¯¸ {m} í¬ì§€ì…˜ ë³´ìœ ì¤‘ â†’ ì‹ ê·œ ì§„ì… ìŠ¤í‚µ")
            return

    signal_price = pre.get("price")
    if not signal_price:
        print(f"[AUTO] {m} pre['price'] ì—†ìŒ â†’ ì§„ì… ìŠ¤í‚µ")
        return

    # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì…ëª¨ë“œ ë°˜ì˜ ===
    entry_mode = pre.get("entry_mode", "confirm")

    if entry_mode == "probe":
        entry_fraction = 0.1   # ì „ì²´ ë¦¬ìŠ¤í¬ì˜ 35%ë§Œ ì‚¬ìš© (íƒìƒ‰ìš©)
        mode_emoji = "ğŸ§­"
    elif entry_mode == "confirm":
        entry_fraction = 1.0    # ì „ì²´ ê¸ˆì•¡ (í™•ì • ì§„ì…)
        mode_emoji = "ğŸ”¥"
    else:
        entry_fraction = 1.0
        mode_emoji = "ğŸ¤–"

    # â˜… ê³µê²©ëª¨ë“œì¼ ê²½ìš° ê°€ê²© ê°€ë“œ ì™„í™”
    max_drift = 0.012 if not AGGRESSIVE_MODE else 0.025

    ok_guard, current_price = final_price_guard(m, signal_price, max_drift=max_drift)
    if not ok_guard:
        tg_send(
            f"âš ï¸ <b>ì§„ì… ì·¨ì†Œ</b> {m}\n"
            f"â€¢ ì‹ í˜¸ê°€: {signal_price:,.0f}ì›\n"
            f"â€¢ í˜„ì¬ê°€: {current_price:,.0f}ì›\n"
            f"â€¢ ìƒìŠ¹ë¥ : {((current_price / signal_price - 1) * 100):.2f}%\n"
            f"â€¢ ì‚¬ìœ : ê°€ê²© ê¸‰ë“± (ì´ˆì… ì¶”ê²© ìœ„í—˜)"
        )
        return

    # === ê³„ì¢Œ & ì£¼ë¬¸ê¸ˆì•¡ ê³„ì‚° ===
    accounts = get_account_info()
    if not accounts:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
        return

    krw_bal = 0.0
    for a in accounts:
        if a.get("currency") == "KRW":
            krw_bal = float(a.get("balance", "0"))
            break

    if krw_bal < 6000:
        print(f"[AUTO] KRW ë¶€ì¡± ({krw_bal:,.0f}) â†’ ìŠ¤í‚µ")
        return

    entry_price = current_price
    stop_price = dyn_stop

    # âœ… ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë™ì  ë¦¬ìŠ¤í¬
    adaptive_risk = get_adaptive_risk()

    # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… êµ¬ì¡° ===
    risk_to_use = adaptive_risk * SEED_RISK_FRACTION if USE_PYRAMIDING else adaptive_risk
    risk_to_use *= entry_fraction  # probeëŠ” ë¦¬ìŠ¤í¬ ì¶•ì†Œ ë°˜ì˜

    base_qty = calc_position_size(
        entry_price,
        stop_price,
        krw_bal,
        risk_to_use,
    )

    krw_to_use = base_qty * entry_price
    if krw_to_use < 5000:
        print(f"[AUTO] ì£¼ë¬¸ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ")
        return

    krw_to_use = int(krw_to_use)

    # === ë§¤ìˆ˜ ===
    try:
        res = place_market_buy(m, krw_to_use)
        print("[AUTO_BUY_RES]", json.dumps(res, ensure_ascii=False))  # â˜…ì¶”ê°€
        oid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(oid, timeout_sec=6) if oid else None
        print("[AUTO_BUY_ORDER]", json.dumps(od, ensure_ascii=False))  # â˜…ì¶”ê°€

        if od:
            volume_filled = float(od.get("executed_volume") or "0")
        else:
            volume_filled = 0.0

        if volume_filled <= 0:
            msg = f"[AUTO] {m} ìë™ë§¤ìˆ˜ ì²´ê²° 0 â†’ í¬ì§€ì…˜ ìƒì„± ì•ˆ í•¨"
            print(msg)
            tg_send(f"âš ï¸ {msg}")
            return

        # í‰ê· ê°€ ê³„ì‚°
        trades = od.get("trades") or []
        if trades:
            total_krw = sum(float(tr["price"]) * float(tr["volume"]) for tr in trades)
            total_vol = sum(float(tr["volume"]) for tr in trades)
            avg_price = total_krw / total_vol if total_vol > 0 else entry_price
        else:
            avg_price = float(entry_price)  # ëª…ì‹œì  float

    except Exception as e:
        print("[AUTO BUY ERR]", e)
        tg_send(f"âš ï¸ ë§¤ìˆ˜ ì‹¤íŒ¨ {m}\n{e}")
        return

    # === í¬ì§€ì…˜ ì €ì¥ ===
    with _POSITION_LOCK:
        OPEN_POSITIONS[m] = {
            "entry_price": avg_price,
            "volume": volume_filled,
            "stop": stop_price,
            "sl_pct": eff_sl_pct,
            "state": "open",
            "last_add_ts": 0.0,
            "entry_mode": pre.get("entry_mode", "confirm"),  # â˜… ì¶”ê°€
        }

    slip_pct = (avg_price / signal_price - 1.0) if signal_price else 0.0

    tg_send(
        f"{mode_emoji} <b>ìë™ë§¤ìˆ˜ ì²´ê²° ({entry_mode})</b> {m}\n"
        f"â€¢ ì‹ í˜¸ê°€: {signal_price:,.0f}ì›\n"
        f"â€¢ ì²´ê²°ê°€: {avg_price:,.0f}ì›\n"
        f"â€¢ ìŠ¬ë¦¬í”¼ì§€: {slip_pct*100:+.3f}%\n"
        f"â€¢ ì£¼ë¬¸ê¸ˆì•¡: {krw_to_use:,.0f}ì› ({entry_fraction*100:.0f}% ë¹„ì¤‘)\n"
        f"â€¢ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
        f"â€¢ ì†ì ˆê°€: {stop_price:,.0f}ì›\n"
        f"{link_for(m)}"
    )

def add_auto_position(m, cur_price):
    """
    ì´ë¯¸ seed í¬ì§€ì…˜ì´ ìˆì„ ë•Œ, ê°•í•œ ì¶”ì„¸ì—ì„œ 1íšŒ ì¶”ë§¤(add) ìˆ˜í–‰
    - ADD_RISK_FRACTION ë¹„ìœ¨ë§Œí¼ RISK_PER_TRADEë¥¼ ë‹¤ì‹œ ì‚¬ìš©
    - í‰ê· ë‹¨ê°€ ì¬ê³„ì‚°
    """
    if not AUTO_TRADE:
        return False, None

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        return False, None

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            return False, None
        if pos.get("added"):
            # ì´ë¯¸ í•œ ë²ˆ ì¶”ë§¤í•œ í¬ì§€ì…˜
            return False, None
        last_add_ts = pos.get("last_add_ts", 0.0)

    now = time.time()
    if (now - last_add_ts) < PYRAMID_ADD_COOLDOWN_SEC:
        return False, None

    accounts = get_account_info()
    if not accounts:
        print("[AUTO_ADD] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
        return False, None

    krw_bal = 0.0
    for a in accounts:
        if a.get("currency") == "KRW":
            krw_bal = float(a.get("balance", "0"))
            break

    if krw_bal < 6000:
        print(f"[AUTO_ADD] KRW ë¶€ì¡±({krw_bal:,.0f}) â†’ ì¶”ë§¤ ìŠ¤í‚µ")
        return False, None

    entry_price_old = pos["entry_price"]
    stop_price = pos["stop"]

    add_risk_pct = max(0.0001, RISK_PER_TRADE * ADD_RISK_FRACTION)
    qty_theoretical = calc_position_size(cur_price, stop_price, krw_bal, add_risk_pct)
    krw_to_use = qty_theoretical * cur_price

    if krw_to_use < 5000:
        print(f"[AUTO_ADD] ì£¼ë¬¸ ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ")
        return False, None

    krw_to_use = int(krw_to_use)

    print(
        f"[AUTO_ADD] {m} ì¶”ë§¤ ì‹œë„: {krw_to_use:,.0f} KRW "
        f"(ì´ë¡ ìˆ˜ëŸ‰â‰ˆ{qty_theoretical:.6f}, í˜„ì¬ê°€ {cur_price:,.0f})"
    )

    volume_filled = 0.0
    avg_price_add = cur_price

    try:
        res = place_market_buy(m, krw_to_use)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid, timeout_sec=6.0) if order_uuid else None

        if od:
            try:
                volume_filled = float(od.get("executed_volume") or "0")
            except Exception:
                volume_filled = 0.0

            trades = od.get("trades") or []
            if trades and volume_filled > 0:
                total_krw = 0.0
                total_vol = 0.0
                for tr in trades:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                    total_krw += p * v
                    total_vol += v
                if total_vol > 0:
                    avg_price_add = total_krw / total_vol
            else:
                if volume_filled > 0:
                    avg_price_add = krw_to_use / volume_filled

        if volume_filled <= 0:
            msg = f"[AUTO_ADD] {m} ì¶”ë§¤ ì²´ê²° 0 â†’ ë¬´ì‹œ"
            print(msg)
            tg_send(f"âš ï¸ {msg}")
            return False, None

    except Exception as e:
        print("[AUTO_ADD ERR]", e)
        tg_send(f"âš ï¸ <b>ì¶”ë§¤ ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")
        return False, None

    # í‰ê· ë‹¨ê°€ ê°±ì‹ 
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos:
            return False, None
        old_vol = pos.get("volume", 0.0)
        new_vol = old_vol + volume_filled
        if new_vol <= 0:
            return False, None
        new_entry_price = (entry_price_old * old_vol + avg_price_add * volume_filled) / new_vol

        pos["entry_price"] = new_entry_price
        pos["volume"] = new_vol
        pos["added"] = True
        pos["last_add_ts"] = time.time()
        pos["entry_mode"] = "confirm"  # âœ… probe â†’ confirm ìŠ¹ê²© ìë™ë°˜ì˜

    tg_send(
        f"ğŸ“ˆ <b>ì¶”ë§¤ ì²´ê²°</b> {m}\n"
        f"â€¢ ì¶”ê°€ ì²´ê²°ê°€: {avg_price_add:,.0f}ì›\n"
        f"â€¢ ì¶”ê°€ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
        f"â€¢ ì´ ìˆ˜ëŸ‰: {new_vol:.6f}\n"
        f"â€¢ ìƒˆë¡œìš´ í‰ë‹¨: {new_entry_price:,.0f}ì›\n"
        f"{link_for(m)}"
    )

    return True, new_entry_price

# =========================
# ğŸ”¥ ìë™ ì²­ì‚°
# =========================
def close_auto_position(m, reason=""):
    """
    ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ ë§¤ë„
    """
    if not AUTO_TRADE:
        print(f"[AUTO] AUTO_TRADE=0 â†’ ì²­ì‚° ìŠ¤í‚µ ({m}, reason={reason})")
        return

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)

    if not pos:
        print(f"[AUTO] OPEN_POSITIONSì— {m} í¬ì§€ì…˜ ì—†ìŒ â†’ ì²­ì‚° ìŠ¤í‚µ (reason={reason})")
        tg_send_mid(f"âš ï¸ {m} ì²­ì‚° ì‹œë„í–ˆëŠ”ë° OPEN_POSITIONSì— í¬ì§€ì…˜ ì—†ìŒ")
        return

    tg_send_mid(f"ğŸ’£ {m} ìë™ì²­ì‚° ì‹œë„ (reason={reason}, vol={pos.get('volume',0):.6f})")

    vol = pos.get("volume", 0)
    if vol <= 0:
        print(f"[AUTO] {m} volume<=0 ({vol}) â†’ í¬ì§€ì…˜ ì œê±°ë§Œ ìˆ˜í–‰")
        with _POSITION_LOCK:
            OPEN_POSITIONS.pop(m, None)
        return

    entry_price = pos.get("entry_price", 0)

    # í˜„ì¬ê°€(ì²­ì‚° ì „ ê¸°ì¤€) ì¡°íšŒ
    try:
        cur_js = upbit_private_get("/v1/ticker", {"markets": m})
        cur_price = cur_js[0].get("trade_price",
                                  entry_price) if cur_js else entry_price
    except Exception:
        cur_price = entry_price

    # ì„  ê³„ì‚°(ëŒ€ëµ)
    ret_pct = (cur_price / entry_price -
               1.0) * 100.0 if entry_price > 0 else 0.0
    est_entry_value = entry_price * vol
    est_exit_value = cur_price * vol
    pl_value = est_exit_value - est_entry_value

    print(
        f"[AUTO] {m} ì²­ì‚° ì‹œë„: volume={vol}, reason={reason}, PnL(ì„ ê³„ì‚°)={ret_pct:+.2f}%"
    )

    exit_price_used = cur_price  # ì‹¤ì œ ì²´ê²°ê°€ ì„±ê³µ ì‹œ êµì²´

    try:
        res = place_market_sell(m, vol)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        if order_uuid:
            od = get_order_result(order_uuid, timeout_sec=6.0)
        else:
            od = None

        # ì‹¤ì œ ì²´ê²°ê°€ ê³„ì‚°
        if od:
            trades = od.get("trades") or []
            total_krw = 0.0
            total_vol = 0.0
            for tr in trades:
                try:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                except Exception:
                    continue
                total_krw += p * v
                total_vol += v
            if total_vol > 0:
                exit_price_used = total_krw / total_vol

        # ì‹¤ì œ ì²´ê²°ê°€ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ê³„ì‚°
        est_exit_value = exit_price_used * vol
        pl_value = est_exit_value - est_entry_value
        ret_pct = (exit_price_used / entry_price -
                   1.0) * 100.0 if entry_price > 0 else 0.0

        # âœ… ê±°ë˜ ê²°ê³¼ ê¸°ë¡ (ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹ì— ì‚¬ìš©)
        try:
            record_trade(m, ret_pct)
        except Exception as _e:
            print("[TRADE_RECORD_ERR]", _e)

        tg_send(
            f"ğŸ’¥ <b>ìë™ì²­ì‚°</b> {m}\n"
            f"â€¢ ì‚¬ìœ : {reason}\n"
            f"â€¢ ìˆ˜ëŸ‰: {vol:.6f}\n"
            f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {entry_price:,.0f}ì›\n"
            f"â€¢ ì‹¤ë§¤ë„ê°€(í‰ê· ): {exit_price_used:,.0f}ì›\n"
            f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡(ì¶”ì •): {est_entry_value:,.0f}ì›\n"
            f"â€¢ ì²­ì‚°ê¸ˆì•¡(ì¶”ì •): {est_exit_value:,.0f}ì›\n"
            f"â€¢ ì‹¤í˜„ì†ìµ(ì¶”ì •): {pl_value:,.0f}ì›\n"
            f"â€¢ ìˆ˜ìµë¥ : {ret_pct:+.2f}%\n"
            f"{link_for(m)}"
        )

    except Exception as e:
        print("[AUTO SELL ERR]", e)
        tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")

    with _POSITION_LOCK:
        OPEN_POSITIONS.pop(m, None)


def safe_partial_sell(m, sell_ratio=0.5, reason=""):
    """
    ë¶€ë¶„ ì²­ì‚° ê³µìš© í•¨ìˆ˜
    - sell_ratio: 0.5 â†’ 50%, 0.3 â†’ 30% ë“±
    - partial_done í”Œë˜ê·¸ë¡œ 1íšŒë§Œ ë¶€ë¶„ì²­ì‚°/ë¶€ë¶„ìµì ˆ í—ˆìš©
    ë°˜í™˜: (ì„±ê³µì—¬ë¶€:bool, ë©”ì‹œì§€:str, ì²´ê²°ëŸ‰:float)
    """
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: í¬ì§€ì…˜ ì—†ìŒ/ìˆ˜ëŸ‰ 0"
            print(msg)
            return False, msg, 0.0
        if pos.get("partial_done"):
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì´ë¯¸ ìˆ˜í–‰ë¨ â†’ ìŠ¤í‚µ"
            print(msg)
            return False, msg, 0.0
        current_volume = pos["volume"]

    sell_volume = current_volume * sell_ratio
    if sell_volume <= 0:
        msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: sell_volume<=0"
        print(msg)
        return False, msg, 0.0

    try:
        res = place_market_sell(m, sell_volume)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid,
                              timeout_sec=6.0) if order_uuid else None

        executed = 0.0
        if od:
            try:
                executed = float(od.get("executed_volume") or "0")
            except Exception:
                executed = 0.0

        if executed <= 0:
            msg = f"[PARTIAL_SELL_ERR] {m}: executed_volume=0 (ìš”ì²­ {sell_volume:.6f})"
            print(msg)
            # â— ë¶€ë¶„ì²­ì‚° ì‹ í˜¸ëŠ” ê³„ì† ì˜¤ëŠ”ë° ì‹¤ì œ ë§¤ë„ê°€ ì•ˆ ë˜ëŠ” ê²½ìš°ë¥¼ ëˆˆì— ë³´ì´ê²Œ
            tg_send_mid(f"âš ï¸ <b>ë¶€ë¶„ì²­ì‚° ì£¼ë¬¸ ì‹¤íŒ¨</b> {m}\n"
                        f"â€¢ ìš”ì²­ ë¹„ìœ¨: {sell_ratio*100:.0f}%\n"
                        f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {sell_volume:.6f}\n"
                        f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: 0 (ì‹¤íŒ¨)\n"
                        f"â†’ ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± / ì£¼ë¬¸ê±°ì ˆ ê°€ëŠ¥ì„±")
            return False, msg, 0.0

        remaining_volume = max(current_volume - executed, 0.0)

        with _POSITION_LOCK:
            pos2 = OPEN_POSITIONS.get(m)
            if pos2:
                pos2["volume"] = remaining_volume
                pos2["partial_done"] = True

        msg = (f"[REMONITOR] {m} ë¶€ë¶„ ì²­ì‚° ì‹¤í–‰ {sell_ratio*100:.0f}% "
               f"(ì²´ê²° {executed:.6f}) ì”ì—¬ {remaining_volume:.6f}")
        print(msg)

        tg_send(
            f"ğŸ¯ <b>ë¶€ë¶„ ì²­ì‚°</b> {m}\n"
            f"â€¢ ì‚¬ìœ : {reason or 'ë¶€ë¶„ì²­ì‚°'}\n"
            f"â€¢ ë§¤ë„ ë¹„ìœ¨: {sell_ratio*100:.0f}%\n"
            f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: {executed:.6f}\n"
            f"â€¢ ì”ì—¬ ìˆ˜ëŸ‰: {remaining_volume:.6f}\n"
        )

        return True, msg, executed

    except Exception as e:
        msg = f"[PARTIAL_SELL_ERR] {m}: {e}"
        print(msg)
        return False, msg, 0.0


def remonitor_until_close(m, entry_price, pre, tight_mode=False):
    """
    ëì•ŒëŒ ì´í›„ ìë™ì²­ì‚° ì‹ í˜¸ê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ ëª¨ë‹ˆí„°ë§
    """
    CYCLE_SEC = 300
    cycle = 0

    while True:
        cycle += 1
        print(f"[REMONITOR] {m} {cycle}íšŒì°¨ ì¬ëª¨ë‹ˆí„°ë§ ì‹œì‘")

        verdict, action, rationale, ret_pct, last_price, maxrun, maxdd = \
            monitor_position(
                m, entry_price, pre,
                tight_mode=tight_mode,
                horizon=CYCLE_SEC,
                reentry=True
            )

        should_close = False
        reason = verdict or action or "ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ"

        # 1) ê¸‰ë½ / ì†ì ˆ ê¶Œê³ 
        if verdict and ("ê¸‰ë½" in verdict or "ì†ì ˆ" in verdict):
            should_close = True

        # 2) ì „ëŸ‰ ì²­ì‚° ê¶Œê³ 
        elif action and "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ " in action:
            should_close = True

        # 3) ìˆ˜ìµ ì‹¤í˜„:
        #    - 2.5% ì´ìƒ: ì „ëŸ‰ ì²­ì‚°
        #    - 1.5% ~ 2.5%: 30% ë¶€ë¶„ìµì ˆ(í¬ì§€ì…˜ë‹¹ 1íšŒ)
        elif ret_pct is not None and ret_pct >= 2.5:
            should_close = True
            reason = f"ìˆ˜ìµì‹¤í˜„ {ret_pct:.2f}%"

        elif ret_pct is not None and ret_pct >= 1.5:
            # ì¤‘ê°„ êµ¬ê°„: 30% ë¶€ë¶„ ìˆ˜ìµì‹¤í˜„ í›„ ê³„ì† ë³´ìœ 
            ok, msg, executed = safe_partial_sell(
                m, sell_ratio=0.3, reason=f"ë¶€ë¶„ ìˆ˜ìµì‹¤í˜„ {ret_pct:.2f}%")
            if ok and executed > 0:
                print(msg)
            # ë¶€ë¶„ìµì ˆ í›„ì—ëŠ” ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
            continue

        # 4) ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³ ëŠ” â†’ ì²­ì‚° ì•ˆ í•˜ê³  ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif verdict and verdict.startswith("ì²­ì‚° ê¶Œê³ ("):
            continue

        # 5) ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³  â†’ ì‹¤ì œ 50% ë§¤ë„ í›„ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ ":
            ok, msg, executed = safe_partial_sell(m,
                                                  sell_ratio=0.5,
                                                  reason="ëì•ŒëŒ ë¶€ë¶„ì²­ì‚° 50%")
            if ok and executed > 0:
                print(msg)
            continue

        # 6) ìœ ì§€ ê¶Œê³  â†’ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ìœ ì§€ ê¶Œê³ ":
            continue

        # 7) ê·¸ëƒ¥ ì‹œê°„ ë§Œë£Œë©´ â†’ ë‹¤ì‹œ í•œ ë²ˆ ì‚¬ì´í´
        elif verdict == "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)":
            continue

        if should_close:
            print(f"[REMONITOR] {m} ìë™ì²­ì‚° ì¡°ê±´ ì¶©ì¡± â†’ ì²­ì‚° ({reason})")
            close_auto_position(m, reason)
            return True


# =========================
# ì–¼ëŸ¿ ì •ì±…
# =========================
SILENT_MIDDLE_ALERTS = True


def tg_send_mid(t):
    if not SILENT_MIDDLE_ALERTS:
        return tg_send(t)
    else:
        print("[SILENT]", t)
        return True

def send_remonitor_alert(m, text):
    """
    ì¬ëª¨ë‹ˆí„°ë§ / ì»¨í…ìŠ¤íŠ¸ìš© ìš”ì•½ ì•ŒëŒ
    - í…”ë ˆê·¸ë¨ ê³¼ë‹¤ ë°©ì§€: TG ì „ì†¡ì€ ë¹„í™œì„±í™”, ì½˜ì†”ë§Œ ë‚¨ê¹€
    """
    now = time.time()
    last = REMONITOR_LAST_ALERT.get(m, 0)
    elapsed = now - last

    # 5ë¶„ ì´ë‚´ë©´ ì™„ì „íˆ ìŠ¤í‚µ (ì½˜ì†”ì—ë„ ì¶œë ¥í•˜ì§€ ì•ŠìŒ)
    if elapsed < REMONITOR_COOLDOWN_SEC:
        return

    REMONITOR_LAST_ALERT[m] = now
    print(f"[REMONITOR_INFO] {m} {text}")  # ì½˜ì†”ë§Œ ë‚¨ê¹€
    return  # TG ì „ì†¡ ë¹„í™œì„±í™”

# =========================
# í•„í„° íŒŒë¼ë¯¸í„° (Conservative-Balanced)ã„¹
# =========================
# ê±°ë˜/ê°€ê²© ê¸°ë°˜
MIN_VOLUME_KRW = 450_000  # 400k -> 700k (í—ˆìˆ˜ ì €ê°)
MIN_RELATIVE_KRW_X = 1.08  # 1.18 -> 1.25 (ê³¼ê±°ëŒ€ë¹„ ì¦ê°€ìœ¨)

# í‹±/ì²´ê²° ê¸°ë°˜
TAPE_WINDOW_SEC = 15
MIN_TICKS_COUNT = 3
MIN_TURNOVER = 0.018
TICKS_BUY_RATIO = 0.56

# ìœ„í—˜ ê´€ë¦¬ (ìŠ¤í”„ë ˆë“œ)
MAX_SPREAD_BASE = 0.70  # 0.60 -> 0.45
MAX_SPREAD_FAST = 1.00  # 1.10 -> 0.80
MIN_DEPTH_KRW = 6_000_000

# í—ˆìˆ˜ ë°©ì–´
MIN_SUSTAINED_SECONDS = 120
MIN_REAL_TRADES = 10
MAX_FADE_RATIO = 0.70

# ì†ì ˆ/ëª¨ë‹ˆí„°ë§
STOP_LOSS_PCT = 0.008
RECHECK_SEC = 5
MONITOR_MAX = 180

# Ignition
IGN_BREAK_LOOKBACK = 12
IGN_MIN_BODY = 0.006
IGN_MIN_BUY = 0.60
USE_5M_CONTEXT = True

# Bot-aware
BOT_PINGPONG_MAX_BAND = 0.0015
BOT_PINGPONG_MIN_ALT = 0.90
BOT_WASH_REPEAT_VOL_N = 5
BOT_TWAP_MAX_CV = 0.48
BOT_TWAP_MAX_PSTD = 0.0018
BOT_ACCUM_MIN_BUY = 0.54
BOT_ACCUM_MAX_BUY = 0.68
BOT_ACCUM_MIN_TURN = 0.030

# íŠ¸ë Œë“œ ê°€ë“œ
USE_TREND_GUARD = False

# Early Entry
USE_EARLY_ENTRY = True
EARLY_MIN_VWAP_GAP = 0.0005
EARLY_MIN_BUY = 0.50
EARLY_MIN_TURN = 0.012
EARLY_MIN_TICKS = 2
EARLY_FLOW_MIN_KRWPSEC = 26_000  # 45k -> 38k
EARLY_MAX_VWAP_GAP = 0.018  # 1ë¶„ë´‰ê°€-VWAP ìµœëŒ€ ê´´ë¦¬ (1.8%) í—ˆìš©
EARLY_MAX_EMA5_GAP = 0.022

# í‹± ê¸°ë°˜ ì¡°ê¸° ë¸Œë ˆì´í¬
USE_TICK_BREAK = True
TICK_BREAK_GAP = 0.0020

# ì ì‘ì‹ ë³¼ë¥¨ ì„œì§€
ABS_SURGE_KRW = 2_200_000   # ì ˆëŒ€ ê±°ë˜ëŒ€ê¸ˆ ì„œì§€ ê¸°ì¤€ (2.2M KRW)
RELAXED_X = 1.08            # ê³¼ê±°ëŒ€ë¹„ ê±°ë˜ëŒ€ê¸ˆ ì™„í™” ë°°ìœ¨

# ì¿¨ë‹¤ìš´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
REARM_MIN_SEC = 45
REARM_PRICE_GAP = 0.009
REARM_PULLBACK_MAX = 0.004
REARM_REBREAK_MIN = 0.0028

# í¬ìŠ¤íŠ¸ì²´í¬(í—ˆìˆ˜ 2ì°¨)
POSTCHECK_ENABLED = False
POSTCHECK_WINDOW_SEC = 3
POSTCHECK_MIN_BUY = 0.46  # 0.52 -> 0.54
POSTCHECK_MIN_RATE = 0.16  # 0.18 -> 0.26
POSTCHECK_MAX_PSTD = 0.0028  # 0.0028 -> 0.0022
POSTCHECK_MAX_CV = 0.72  # 0.70 -> 0.60
POSTCHECK_MAX_DD = 0.018

# ë™ì  ì†ì ˆ(ATR)
ATR_PERIOD = 14
ATR_EMA_PERIOD = 20
ATR_MULT = 0.85
DYN_SL_MIN = STOP_LOSS_PCT
DYN_SL_MAX = 0.022

# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ (ìš°íšŒ ì—„ê²©í™”)
ULTRA_RELAX_ON_MEGA = True
MEGA_BREAK_MIN_GAP = 0.022  # 1.2% -> 2.0%
MEGA_MIN_1M_CHG = 0.025  # 1.8% -> 2.8%
MEGA_VOL_Z = 2.8  # 2.2 -> 2.8
MEGA_ABS_KRW = 4_000_000  # 2.0M -> 4.0M

# =========================
# ì„¸ì…˜/ìš”ì²­(ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”)
# =========================
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter


def _new_session():
    s = requests.Session()
    retry = Retry(total=3,
                  backoff_factor=0.3,
                  status_forcelist=[429, 500, 502, 503, 504],
                  allowed_methods=frozenset(["GET", "POST"]))
    adapter = HTTPAdapter(pool_connections=256,
                          pool_maxsize=256,
                          max_retries=retry)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({
        "Connection": "keep-alive",
        "User-Agent": "UpbitSniper/3.2.7-hh+...+netRetry"
    })
    return s


SESSION = _new_session()
KST = timezone(timedelta(hours=9))

def now_kst():
    return datetime.now(KST)

def now_kst_str():
    return now_kst().strftime("%Y-%m-%d %H:%M:%S KST")

# =========================
# ğŸ”¥ ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ê°„ê²©
# =========================
def get_scan_interval():
    """
    ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ì£¼ê¸°(ì´ˆ)
    - 09ì‹œëŒ€: 3ì´ˆ (ì´ˆë™ ë³€ë™ì„± ëŒ€ì‘)
    - 10~14ì‹œ: 5ì´ˆ
    - ê·¸ ì™¸: ê¸°ë³¸ 6ì´ˆ
    """
    h = now_kst().hour
    if h == 9:
        return 3
    elif 10 <= h <= 14:
        return 5
    else:
        return SCAN_INTERVAL  # ê¸°ë³¸ê°’(6ì´ˆ)

def link_for(m):
    return f"https://upbit.com/exchange?code=CRIX.UPBIT.{m}"


# í† í°ë²„í‚·
_BUCKET = {"tokens": 6.0, "last": time.time(), "cap": 6.0, "rate": 4.5}
_req_lock = threading.Lock()
REQ_STATS = {"ok": 0, "http429": 0, "http5xx": 0, "errors": 0, "conn_err": 0}
_CONSEC_CONN_ERR = 0


def _throttle():
    while True:
        with _req_lock:
            now = time.time()
            delta = now - _BUCKET["last"]
            _BUCKET["last"] = now
            rate = max(float(_BUCKET.get("rate", 0.0)), 0.1)
            cap = max(float(_BUCKET.get("cap", 1.0)), 1.0)
            tokens = min(cap, max(0.0, _BUCKET["tokens"] + delta * rate))
            if tokens >= 1.0:
                _BUCKET["tokens"] = tokens - 1.0
                return
            _BUCKET["tokens"] = tokens
            need = 1.0 - tokens
        base_wait = need / rate
        time.sleep(min(1.2, max(0.05, base_wait)) * (1.0 + 0.2 * rnd()))


def _refresh_session():
    global SESSION, _CONSEC_CONN_ERR
    try:
        SESSION.close()
    except Exception:
        pass
    SESSION = _new_session()
    _CONSEC_CONN_ERR = 0
    print("[NET] session refreshed")


def upbit_get(url, params=None, timeout=7):
    global _CONSEC_CONN_ERR
    for attempt in range(3):  # 4 -> 3 ìœ ì§€
        try:
            _throttle()
            r = SESSION.get(url, params=params, timeout=timeout)
            if r.status_code == 429:
                REQ_STATS["http429"] += 1
                # ì§€ìˆ˜ì  ë°±ì˜¤í”„ + ë²„í‚· ì†ë„ í•˜í–¥(ë³´ë‹¤ ê³µê²©ì ìœ¼ë¡œ)
                backoff = min(1.2 * (2**attempt), 6.0)
                time.sleep(backoff)
                # â†“ rateë¥¼ ë” ê°•í•˜ê²Œ ì¤„ì´ê³ , capë„ ì ê¹ ì¤„ì—¬ í­ì£¼ ì–µì œ
                _BUCKET["rate"] = max(3.0, _BUCKET["rate"] - 0.4)
                _BUCKET["cap"] = max(4.0, _BUCKET["cap"] - 0.5)
                continue
            if 500 <= r.status_code < 600:
                REQ_STATS["http5xx"] += 1
                time.sleep(0.35 * (2**attempt))
                continue
            r.raise_for_status()
            REQ_STATS["ok"] += 1
            _CONSEC_CONN_ERR = 0
            return r.json()
        except requests.exceptions.Timeout:
            if attempt == 2: return None
            time.sleep(0.35 * (2**attempt))
        except requests.exceptions.ConnectionError:
            REQ_STATS["errors"] += 1
            REQ_STATS["conn_err"] += 1
            _CONSEC_CONN_ERR += 1
            if _CONSEC_CONN_ERR >= 3:
                _refresh_session()
                time.sleep(0.6)
            else:
                time.sleep(0.4 * (2**attempt))
            if attempt == 2: return None
        except Exception:
            REQ_STATS["errors"] += 1
            if attempt == 2: return None
            time.sleep(0.2 * (2**attempt))
    return None

# =========================================================
# ğŸ§© ì•ˆì „ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ë˜í¼ (ìë™ ì¬ì‹œë„ + ë°±ì˜¤í”„)
# =========================================================
def safe_upbit_get(url, params=None, timeout=6, retries=3, backoff=1.5):
    """
    ì—…ë¹„íŠ¸ API ìš”ì²­ìš© ì•ˆì „ ë˜í¼
    - ì¼ì‹œì  ì—°ê²° ì‹¤íŒ¨ë‚˜ 429 ì‘ë‹µì—ë„ ìë™ ì¬ì‹œë„
    - 3íšŒê¹Œì§€ ì¬ì‹œë„ (1.5ì´ˆì”© ì¦ê°€í•˜ëŠ” ëŒ€ê¸°)
    """
    for i in range(retries):
        try:
            js = upbit_get(url, params, timeout=timeout)
            if js:
                return js
        except Exception as e:
            print(f"[SAFE_GET] {url.split('/')[-1]} ì‹¤íŒ¨ ({e}) â†’ ì¬ì‹œë„ {i+1}/{retries}")
        time.sleep(backoff * (i + 1))
    print(f"[SAFE_GET_FAIL] {url.split('/')[-1]} ìµœì¢… ì‹¤íŒ¨")
    return None

def req_summary():
    print(
        f"[REQ] ok:{REQ_STATS['ok']}  429:{REQ_STATS['http429']}  5xx:{REQ_STATS['http5xx']}  err:{REQ_STATS['errors']}"
    )


def aligned_sleep(interval):
    t = time.time()
    nxt = math.ceil(t / interval) * interval
    time.sleep(max(0, nxt - t))


# =========================
# ì§€í‘œ ìœ í‹¸
# =========================
def vwap_from_candles_1m(c1, n=20):
    seg = c1[-n:] if len(c1) >= n else c1[:]
    pv = sum(x["trade_price"] * x["candle_acc_trade_volume"] for x in seg)
    vol = sum(x["candle_acc_trade_volume"] for x in seg)
    return pv / max(vol, 1e-12)


def zscore_krw_1m(c1, win=30):
    seg = c1[-win:] if len(c1) >= win else c1[:]
    arr = [x["candle_acc_trade_price"] for x in seg]
    if len(arr) < 3: return 0.0
    m = sum(arr) / len(arr)
    sd = (sum((a - m)**2 for a in arr) / max(len(arr) - 1, 1))**0.5
    return (arr[-1] - m) / max(sd, 1e-9)


def uptick_streak_from_ticks(ticks, need=2):
    t = sorted(ticks[:need + 4], key=lambda x: x.get("timestamp", 0))
    return sum(1 for a, b in zip(t, t[1:])
               if b.get("trade_price", 0) > a.get("trade_price", 0)) >= need


def last_two_ticks_fresh(ticks, max_age=2.0):
    if len(ticks) < 2: return False
    h = now_kst().hour
    if 0 <= h < 6:
        max_age = max_age + 0.8
    now = int(time.time() * 1000)
    return all(
        (now - x.get("timestamp", 0)) / 1000.0 <= max_age for x in ticks[:2])


def body_ratio(c):
    try:
        return max((c["trade_price"] - c["opening_price"]) /
                   max(c["opening_price"], 1), 0)
    except:
        return 0


# ---- 5ë¶„ ì»¨í…ìŠ¤íŠ¸: LRU ìºì‹œ ----
class LRUCache:

    def __init__(self, maxsize=100):
        self.cache = OrderedDict()
        self.maxsize = maxsize
        self.lock = threading.Lock()

    def get(self, key):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
                return self.cache[key]
            return None

    def set(self, key, value):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.maxsize:
                self.cache.popitem(last=False)

    def clear(self):
        with self.lock:
            self.cache.clear()

    def purge_older_than(self, max_age_sec=3.0):
        cutoff = int(time.time() * 1000) - int(max_age_sec * 1000)
        with self.lock:
            drop = [
                k for k, v in self.cache.items()
                if isinstance(v, dict) and v.get("ts", 0) < cutoff
            ]
            for k in drop:
                self.cache.pop(k, None)


_TICKS_CACHE = LRUCache(maxsize=100)
_TICKS_TTL = 4.5
_C5_CACHE = LRUCache(maxsize=300)


def five_min_context_ok(m):
    if not USE_5M_CONTEXT:
        return True
    hit = _C5_CACHE.get(m)
    if hit and (time.time() - hit.get("ts", 0) <= 3.0):
        c5 = hit["c"]
    else:
        c5 = get_minutes_candles(5, m, 6)
        _C5_CACHE.set(m, {"ts": time.time(), "c": c5})
    if len(c5) < 4:
        return True
    try:
        close = [c["trade_price"] for c in c5]
        slope3 = close[-1] - close[-3]
        recent_break = c5[-1]["high_price"] > max(x["high_price"]
                                                  for x in c5[-4:-1])
        return (slope3 > 0) or recent_break
    except:
        return True

def get_dynamic_thresholds():
    h = now_kst().hour
    if 0 <= h < 6:
        return {
            "zscore": 0.90,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0008,
            "uptick": 2,
            "min_change": 0.0004,  # ê¸°ì¡´ 0.0005
            "bidask_min": 1.06
        }
    elif 6 <= h < 12:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0006,  # ê¸°ì¡´ 0.0007
            "bidask_min": 1.07
        }
    elif 12 <= h < 18:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,    # ê¸°ì¡´ 0.0010
            "uptick": 2,
            "min_change": 0.0008,  # ê¸°ì¡´ 0.0010
            "bidask_min": 1.075    # ì‚´ì§ ì™„í™”
        }
    else:
        return {
            "zscore": 0.92,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0007,
            "bidask_min": 1.07
        }

# =========================
# â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
# =========================
def relax_knob():
    """
    0.0 ~ 1.5 ìŠ¤ì¼€ì¼.
    + BTC 5ë¶„ ìˆ˜ìµ > 0.6%ë©´ +1.0, > 0.3%ë©´ +0.5
    + ì•¼ê°„(00~06h)ë©´ +0.5
    """
    try:
        b5 = btc_5m_change()
    except:
        b5 = 0.0
    h = now_kst().hour
    f = 0.0
    if b5 >= 0.006: f += 1.0
    elif b5 >= 0.003: f += 0.5
    if 0 <= h < 6: f += 0.5
    return min(1.5, f)


# =========================
# ë°ì´í„° ìˆ˜ì§‘/ìºì‹œ
# =========================
MKTS_CACHE_TTL = 90
_MKTS_CACHE = {"ts": 0.0, "mkts": []}


def get_top_krw_by_24h(n=TOP_N):
    now = time.time()
    if _MKTS_CACHE["mkts"] and (now - _MKTS_CACHE["ts"] <= MKTS_CACHE_TTL):
        mkts = _MKTS_CACHE["mkts"]
    else:
        allm = [
            d["market"]
            for d in upbit_get("https://api.upbit.com/v1/market/all") or []
            if d["market"].startswith("KRW-")
        ]
        acc = []
        for i in range(0, len(allm), 50):
            info = upbit_get("https://api.upbit.com/v1/ticker",
                             {"markets": ",".join(allm[i:i + 50])})
            if not info: continue
            for t in info:
                v = t.get("acc_trade_price_24h", 0)
                if v > 0: acc.append((t["market"], v))
        acc.sort(key=lambda x: x[1], reverse=True)
        mkts = [m for m, _ in acc]
        _MKTS_CACHE["mkts"] = mkts
        _MKTS_CACHE["ts"] = now
    return mkts[:n]


def get_minutes_candles(u, m, c):
    js = upbit_get(f"https://api.upbit.com/v1/candles/minutes/{u}", {
        "market": m,
        "count": c
    },
                   timeout=6)
    return list(reversed(js)) if js else []

def get_recent_ticks(m, c=100, allow_network=True):
    now_ms = int(time.time() * 1000)
    hit = _TICKS_CACHE.get(m)
    if hit and (now_ms - hit["ts"] <= _TICKS_TTL * 1000):
        return hit["ticks"]
    if not allow_network:
        return hit["ticks"] if hit else []

    # âœ… ì•ˆì „ ë˜í¼ë¡œ ë³€ê²½
    js = safe_upbit_get("https://api.upbit.com/v1/trades/ticks", {
        "market": m,
        "count": c
    },
                        timeout=6)

    if not js or not isinstance(js, list):
        return hit["ticks"] if hit else []
    js_sorted = sorted(js, key=lambda t: t.get("timestamp", 0), reverse=True)
    _TICKS_CACHE.set(m, {"ts": now_ms, "ticks": js_sorted})
    return js_sorted

def micro_tape_stats_from_ticks(ticks, sec):
    if not ticks:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    n = 0
    krw = 0.0
    buys = 0
    oldest_ts = newest_ts
    for x in ticks:
        ts = x.get("timestamp", 0)
        if ts < cutoff:
            break
        p = x.get("trade_price", 0.0)
        v = x.get("trade_volume", 0.0)
        krw += p * v
        n += 1
        if x.get("ask_bid") == "BID": buys += 1
        if ts < oldest_ts: oldest_ts = ts

    if n == 0:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    now_ms = int(time.time() * 1000)
    age = (now_ms - newest_ts) / 1000.0 if newest_ts else 999
    duration = max((newest_ts - (oldest_ts or newest_ts)) / 1000.0, 1.0)
    rate = n / duration
    krw_per_sec = krw / duration
    return {
        "krw": krw,
        "n": n,
        "buy_ratio": buys / n,
        "age": age,
        "rate": rate,
        "krw_per_sec": krw_per_sec
    }


# ===== Bot Heuristics =====
def _pct(a, b):
    try:
        return abs(a / b - 1.0)
    except:
        return 0.0


def inter_arrival_stats(ticks, sec=30):
    if not ticks: return {"cv": 9.9, "count": 0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"cv": 9.9, "count": 0}
    cutoff = newest_ts - sec * 1000
    ts = [x["timestamp"] for x in ticks if x["timestamp"] >= cutoff]
    ts = sorted(ts)
    if len(ts) < 4: return {"cv": 9.9, "count": len(ts)}
    gaps = [(b - a) / 1000.0 for a, b in zip(ts, ts[1:])]
    mu = sum(gaps) / len(gaps)
    if mu <= 0: return {"cv": 9.9, "count": len(ts)}
    var = sum((g - mu)**2 for g in gaps) / len(gaps)
    cv = (var**0.5) / mu
    return {"cv": cv, "count": len(ts)}


def price_band_std(ticks, sec=30):
    if not ticks: return 9.9
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 9.9
    cutoff = newest_ts - sec * 1000
    ps = [x["trade_price"] for x in ticks if x["timestamp"] >= cutoff]
    if len(ps) < 3: return 9.9
    m = sum(ps) / len(ps)
    var = sum((p - m)**2 for p in ps) / len(ps)
    std = (var**0.5) / max(m, 1)
    return std


def bot_pingpong_score(ticks, sec=20, band=BOT_PINGPONG_MAX_BAND):
    if not ticks: return 0.0
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 0.0
    cutoff = newest_ts - sec * 1000
    win = [x for x in reversed(ticks) if x["timestamp"] >= cutoff]
    if len(win) < 6: return 0.0
    prices = [x["trade_price"] for x in win]
    pr_min, pr_max = min(prices), max(prices)
    if _pct(pr_max, pr_min) > band:
        return 0.0
    alt = sum(1 for a, b in zip(win, win[1:])
              if a["ask_bid"] != b["ask_bid"]) / max(len(win) - 1, 1)
    return alt


def wash_trade_pattern(ticks, sec=30, repeats=BOT_WASH_REPEAT_VOL_N):
    if not ticks: return False
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return False
    cutoff = newest_ts - sec * 1000
    vols = {}
    for x in ticks:
        if x["timestamp"] < cutoff: break
        v = round(x["trade_volume"], 6)
        vols[v] = vols.get(v, 0) + 1
    if not vols: return False
    top = max(vols.values())
    return top >= repeats


def bot_accum_trigger_ok(m, ticks, ob, c1):
    if not ticks or not ob or not c1: return (False, "BOTACC_INIT_FAIL")
    t30 = micro_tape_stats_from_ticks(ticks, 30)
    if not (BOT_ACCUM_MIN_BUY <= t30["buy_ratio"] <= BOT_ACCUM_MAX_BUY):
        return (False, "BOTACC_BUY_RANGE")
    ia = inter_arrival_stats(ticks, 30)
    if ia["cv"] > BOT_TWAP_MAX_CV or ia["count"] < 6:
        return (False, "BOTACC_CV_LOWCOUNT")
    if price_band_std(ticks, 30) > BOT_TWAP_MAX_PSTD:
        return (False, "BOTACC_PSTD")
    if not uptick_streak_from_ticks(ticks, need=2):
        return (False, "BOTACC_NO_UPTICK")
    try:
        raw = ob["raw"]["orderbook_units"][:3]
        bid = sum(u["bid_price"] * u["bid_size"] for u in raw)
        ask = sum(u["ask_price"] * u["ask_size"] for u in raw)
        if bid / max(ask, 1) < 1.10:
            return (False, "BOTACC_BIDASK_WEAK")
    except:
        pass
    cur = c1[-1]
    if cur["trade_price"] <= cur["opening_price"]:
        return (False, "BOTACC_NOT_GREEN")
    return (True, "BOTACC_OK")


def _win_stats(ticks, start_s, end_s):
    if not ticks:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    lo = newest_ts - end_s * 1000
    hi = newest_ts - start_s * 1000
    win = [x for x in ticks if lo <= x.get("timestamp", 0) <= hi]
    if len(win) < 2:
        return {
            "n": len(win),
            "buy_ratio": 0.0,
            "rate": 0.0,
            "krw_per_sec": 0.0
        }
    win = sorted(win, key=lambda t: t["timestamp"])
    dur = max((win[-1]["timestamp"] - win[0]["timestamp"]) / 1000.0, 1.0)
    buys = sum(1 for x in win if x.get("ask_bid") == "BID")
    krw = sum(x["trade_price"] * x["trade_volume"] for x in win)
    return {
        "n": len(win),
        "buy_ratio": buys / max(len(win), 1),
        "rate": len(win) / dur,
        "krw_per_sec": krw / dur
    }


def buy_decay_flag(ticks):
    early = _win_stats(ticks, start_s=10, end_s=20)
    now = _win_stats(ticks, start_s=0, end_s=5)
    if early["n"] < 4 or now["n"] < 2:
        return False, {"early": early, "now": now}
    drop_buy = early["buy_ratio"] - now["buy_ratio"]
    cond = (drop_buy >= 0.12 and now["rate"] <= early["rate"] * 0.80
            and now["krw_per_sec"] <= early["krw_per_sec"] * 0.70)
    return cond, {"early": early, "now": now, "drop_buy": drop_buy}


# =========================
# ì‹œì¥ í•„í„°
# =========================
def btc_5m_change():
    c = get_minutes_candles(5, "KRW-BTC", 3)
    if len(c) < 2: return 0.0
    return c[-1]["trade_price"] / max(c[-2]["trade_price"], 1) - 1

# =========================
# ë³´ì¡°: ìº”ë“¤/ATR/EMA
# =========================
def wick_body_ratio(c):
    try:
        rng = c["high_price"] - c["low_price"]
        body = abs(c["trade_price"] - c["opening_price"])
        if rng <= 0: return 1.0
        return body / rng
    except:
        return 1.0


def ema_series(vals, period):
    if not vals: return []
    k = 2 / (period + 1)
    out = []
    ema = vals[0]
    for v in vals:
        ema = v * k + ema * (1 - k)
        out.append(ema)
    return out


def ema_last(vals, period):
    if len(vals) == 0: return None
    return ema_series(vals, period)[-1]


def atr14_from_candles(candles, period=14):
    if len(candles) < period + 1:
        return None
    trs = []
    for i in range(1, len(candles)):
        h = candles[i]["high_price"]
        l = candles[i]["low_price"]
        pc = candles[i - 1]["trade_price"]
        tr = max(h - l, abs(h - pc), abs(l - pc))
        trs.append(tr)
    return sum(trs[-period:]) / period if len(trs) >= period else None


# =========================
# â˜… ê·¸ë¼ì¸ë“œ(ê³„ë‹¨ì‹ ìƒìŠ¹) ì˜ˆì™¸
# =========================
# === PATCH: grind detector ===
def grind_break_ok(c1, ticks):
    """ê³„ë‹¨ì‹(ê·¸ë¼ì¸ë“œ) ìƒìŠ¹ ì˜ˆì™¸:
       - ìµœê·¼ 8ë´‰ ì¤‘ 7ë´‰ ì´ìƒì´ EMA5 ìœ„
       - ë§¤ìˆ˜ë¹„(15s) >= 0.56
       - ì²´ê²°ê°„ ê°„ê²© ë³€ë™ê³„ìˆ˜(CV, 30s) <= 0.95 (ë„ˆë¬´ ê³ ë¥¸ TWAP/ë´‡ ì œì™¸)
    """
    if len(c1) < 10 or not ticks:
        return False
    closes = [x["trade_price"] for x in c1]
    e5 = ema_series(closes, 5)
    last8 = list(zip(c1[-8:], e5[-8:]))
    above = sum(1 for c, e in last8 if c["trade_price"] >= e)
    ema_slope = (e5[-1] - e5[-4]) if len(e5) >= 4 else 0
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    ia = inter_arrival_stats(ticks, 30)
    return (above >= 7 and ema_slope > 0 and t15.get("buy_ratio", 0) >= 0.56
            and ia.get("cv", 9.9) <= 0.95)


# =========================
# ì»· ë¡œê¹…
# =========================
DEBUG_CUT = os.getenv("DEBUG_CUT", "0") == "1"
CUT_COUNTER = {
    k: 0
    for k in [
        "SURGE_LOW", "VOL_LOW", "SPREAD_HIGH", "PRICE_LOW", "ZSC_LOW",
        "VWAP_GAP_LOW", "UPTICK_FAIL", "FAKE_PUMP", "TICKS_LOW", "TURN_LOW",
        "BUY_WEAK", "BUY_WEAK_MANYT", "FRESH_FAIL", "BIDASK_WEAK",
        "IGNITION_OK", "BOT_PINGPONG", "BOT_WASH", "BOTACC_OK", "WICK_SPIKE",
        "ATR_OVERSHOOT", "EMA15M_DOWN", "BUY_DECAY", "EARLY_OK",
        "EARLY_LIGHT_FAIL", "PEAK_CHASE", "POSTCHECK_DROP", "MEGA_PASS"
    ]
}


def cut(reason, detail):
    CUT_COUNTER[reason] = CUT_COUNTER.get(reason, 0) + 1
    if DEBUG_CUT:
        now_str = now_kst().strftime("%H:%M:%S")
        print(f"[FILTER][{now_str}] {reason:<16} | {detail}")


def cut_summary():
    parts = [
        f"{k}:{v}" for k, v in sorted(
            CUT_COUNTER.items(), key=lambda x: x[1], reverse=True) if v > 0
    ]
    if parts:
        print(f"[CUT_SUMMARY] {' , '.join(parts)}")


# =========================
# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ íŒì •
# =========================
def is_mega_breakout(c1):
    if not ULTRA_RELAX_ON_MEGA or len(c1) < 6:
        return False
    cur = c1[-1]
    prev_high = max(x["high_price"] for x in c1[-6:-1])
    gap = cur["high_price"] / max(prev_high, 1) - 1
    chg_1m = cur["trade_price"] / max(c1[-2]["trade_price"], 1) - 1 if len(
        c1) >= 2 else 0
    z = zscore_krw_1m(c1, 30)
    abs_krw = cur.get("candle_acc_trade_price", 0)
    return (gap >= MEGA_BREAK_MIN_GAP) and (chg_1m >= MEGA_MIN_1M_CHG) and (
        (z >= MEGA_VOL_Z) or (abs_krw >= MEGA_ABS_KRW))


# =========================
# í—ˆìˆ˜ ë°©ì–´ / ì í™” / ì¡°ê¸° ë¸Œë ˆì´í¬
# =========================
def _turn_needed(ob_depth_krw):
    if ob_depth_krw >= 30_000_000:
        return 0.022
    elif ob_depth_krw >= 15_000_000:
        return 0.026
    elif ob_depth_krw >= 8_000_000:
        return 0.025
    else:
        return 0.023

def is_fake_pump(m,
                 current_volume,
                 current_price,
                 ob_snapshot,
                 tape30,
                 ticks=None,
                 c1=None):
    h = now_kst().hour
    min_depth = 6_000_000 if (0 <= h < 6) else MIN_DEPTH_KRW
    if not ob_snapshot or ob_snapshot.get("depth_krw", 0) < min_depth:
        return True
    if tape30.get("n", 0) < MIN_REAL_TRADES:
        return True
    if ticks:
        if wash_trade_pattern(ticks, 30, BOT_WASH_REPEAT_VOL_N):
            cut("BOT_WASH", f"{m} wash-like repeat vol")
            return True
        pp = bot_pingpong_score(ticks, 20, BOT_PINGPONG_MAX_BAND)
        if pp >= BOT_PINGPONG_MIN_ALT:
            ia = inter_arrival_stats(ticks, 30)
            pstd = price_band_std(ticks, 30)
            buy = micro_tape_stats_from_ticks(ticks, 30).get("buy_ratio", 0)
            if (pstd <= 0.0009) and (ia["cv"] <= 0.35) and (buy < 0.45
                                                            or buy > 0.75):
                cut(
                    "BOT_PINGPONG",
                    f"{m} alt {pp:.2f} | buy {buy:.2f} | cv {ia['cv']:.2f} | pstd {pstd:.4f}"
                )
                return True
    if c1 is None:
        c1 = get_minutes_candles(1, m, 5)
    if len(c1) >= 3:
        v = [c["candle_acc_trade_price"] for c in c1[-3:]]
        if len(v) >= 2 and v[-1] < v[-2] * 0.3:
            return True
    return False


def ignition_trigger_ok(m, c1, ticks, ob):
    if not c1 or not ticks or not ob:
        return False, "IGN_INIT_FAIL"
    cur = c1[-1]
    try:
        prev_high = max(x["high_price"]
                        for x in c1[-(IGN_BREAK_LOOKBACK + 1):-1])
    except:
        prev_high = 0
    if cur["high_price"] <= prev_high:
        return False, "IGN_NO_BREAK"
    if body_ratio(cur) < IGN_MIN_BODY:
        return False, "IGN_BODY_SMALL"
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    turn = t15["krw"] / max(ob.get("depth_krw", 1), 1)
    if t15["buy_ratio"] < IGN_MIN_BUY:
        return False, "IGN_BUY_WEAK"
    if turn < _turn_needed(ob.get("depth_krw", 0)):
        return False, "IGN_TURN_LOW"
    if ob.get("spread", 999) > MAX_SPREAD_FAST:
        return False, "IGN_SPREAD"
    if not five_min_context_ok(m):
        return False, "IGN_5M_WEAK"
    return True, "IGNITION_OK"


def tick_breakout_ok(m, c1, ticks, ob, lookback=12):
    if not (USE_TICK_BREAK and c1 and ticks and ob): return False
    try:
        prev_high = max(x["high_price"] for x in c1[-(lookback + 1):-1])
    except:
        return False
    last_prices = [x["trade_price"] for x in ticks[:20]]
    if not last_prices: return False
    cur_max = max(last_prices)
    gap = cur_max / max(prev_high, 1) - 1
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    depth_ok = ob.get("depth_krw", 0) >= 12_000_000
    return (gap >= TICK_BREAK_GAP) and (t15["buy_ratio"]
                                        >= 0.60) and uptick_streak_from_ticks(
                                            ticks, need=2) and depth_ok


def meets_volume_surge(current_volume, past_volumes):
    avg_past = statistics.mean(
        past_volumes) if past_volumes else current_volume / 8
    rel_x = current_volume / max(avg_past, 1)
    return (rel_x >= MIN_RELATIVE_KRW_X) or (current_volume >= ABS_SURGE_KRW
                                             and rel_x >= RELAXED_X)


# =========================
# ê°ì§€ / ê²€ì¦
# =========================
def detect_leader_stock(m, obc, c1, tight_mode=False):
    """
    í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… íƒì§€ ì—”ì§„:
      - Probe(ì†Œì•¡): ì™„í™”ëœ early íë¦„ ê°ì§€ â†’ ì´ˆê¸° ì—¼íƒ ì§„ì…
      - Confirm(ì¶”ì„¸): ê°•í•œ ì í™”/ë§¤ì§‘/ëŒíŒŒ â†’ í™•ì • ì§„ì…
    """
    if len(c1) < 3:
        return None

    # === ë™ì¼ ì¢…ëª© ì¤‘ë³µ ì§„ì… ë°©ì§€ (ìµœê·¼ ì§„ì… í›„ 2ë¶„ê°„ ë¬´ì‹œ) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
    if pos:
        last_add_ts = pos.get("last_add_ts", 0)
        last_exit_ts = pos.get("last_exit_ts", 0)
        # ìµœê·¼ 120ì´ˆ(2ë¶„) ë‚´ ì§„ì… or ì²­ì‚° ê¸°ë¡ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ
        if time.time() - max(last_add_ts, last_exit_ts) < 120:
            return None

    # === í‹± ê¸°ë°˜ ì´ˆë´‰(10ì´ˆ) ì„ í–‰ ì§„ì… ì‹œê·¸ë„ ===
    ticks_now = get_recent_ticks(m, 80)
    if ticks_now:
        t10s = micro_tape_stats_from_ticks(ticks_now, 10)
        t30s = micro_tape_stats_from_ticks(ticks_now, 30)

        sudden_burst = (
            t10s["krw_per_sec"] >= 1.8 * t30s["krw_per_sec"]
            and t10s["buy_ratio"] >= 0.58
            and t10s["n"] >= 3
        )

        fresh = uptick_streak_from_ticks(ticks_now, need=1)

        if sudden_burst and fresh:
            cut("PROBE_TICK", f"{m} í‹± ì´ˆì… ê°ì§€ â†’ probe ì‹ í˜¸ (ë§¤ìˆ˜ë¹„ {t10s['buy_ratio']:.2f})")
            pre = {
                "price": ticks_now[0]["trade_price"],
                "ob": obc.get(m),
                "ticks": ticks_now,
                "entry_mode": "probe",
                "early_ok": True,
            }
            return pre

    # (ì´í•˜ ê¸°ì¡´ detect_leader_stock ì½”ë“œ ê³„ì†)

    ob = obc.get(m)
    if not ob or not isinstance(ob.get("raw"), dict):
        return None
    if not ob.get("raw", {}).get("orderbook_units"):
        return None
    if ob.get("depth_krw", 0) <= 0:
        return None

    mega = is_mega_breakout(c1)
    th = get_dynamic_thresholds()
    cur, prev = c1[-1], c1[-2]
    price_change = (cur["trade_price"] / max(prev["trade_price"], 1) - 1)

    # ìŠ¤í”„ë ˆë“œ ì»·
    if ob["spread"] > (MAX_SPREAD_FAST if mega else MAX_SPREAD_BASE):
        cut("SPREAD_HIGH", f"{m} spread {ob['spread']:.2f}%")
        return None

    # ê±°ë˜ëŸ‰ ì¡°ê±´
    current_volume = cur.get("candle_acc_trade_price", 0)
    if current_volume < MIN_VOLUME_KRW and not mega:
        cut("VOL_LOW", f"{m} vol {int(current_volume)}")
        return None

    # ê±°ë˜ ì¦ê°€ìœ¨ ì²´í¬
    past_volumes = [c["candle_acc_trade_price"] for c in c1[-7:-2] if c["candle_acc_trade_price"] > 0]
    if not meets_volume_surge(current_volume, past_volumes) and not mega:
        ticks_tmp = get_recent_ticks(m, 100)
        t15_tmp = micro_tape_stats_from_ticks(ticks_tmp, 15)
        t45_tmp = micro_tape_stats_from_ticks(ticks_tmp, 45)
        if not (t15_tmp["krw_per_sec"] >= max(55_000, 1.15 * t45_tmp["krw_per_sec"])):
            cut("SURGE_LOW", f"{m} vol_surge_fail")
            return None

    # ì•½ìƒìŠ¹ ì»·
    if price_change < th["min_change"] and not mega:
        cut("PRICE_LOW", f"{m} {price_change*100:.2f}%")
        return None

    # í‹± í™•ë³´
    ticks = get_recent_ticks(m, 100)
    if not ticks:
        cut("TICKS_LOW", f"{m} no ticks")
        return None

    # === í…Œì´í”„Â·EMA ê³µí†µ ì§€í‘œ ===
    tape_stats = {k: micro_tape_stats_from_ticks(ticks, k) for k in [10, 15, 30, 45]}
    closes_1m = [x["trade_price"] for x in c1]
    ema5 = ema_last(closes_1m, 5) if closes_1m else None
    dist_ema5 = (cur["trade_price"] / ema5 - 1.0) if ema5 else 0.0
    t10, t15, t30, t45 = tape_stats[10], tape_stats[15], tape_stats[30], tape_stats[45]
    last_upticks_ok = uptick_streak_from_ticks(ticks, need=2)

    # === ì í™”/ë¸Œë ˆì´í¬ì•„ì›ƒ ê³„ì—´ ===
    ign_ok, ign_reason = ignition_trigger_ok(m, c1, ticks, ob)
    tick_break = tick_breakout_ok(m, c1, ticks, ob)
    ign_ok = ign_ok or tick_break

    botacc_ok, botacc_reason = bot_accum_trigger_ok(m, ticks, ob, c1)
    two_green_and_break = (
        sum(1 for c in c1[-3:] if c["trade_price"] > c["opening_price"]) >= 2
        and c1[-1]["high_price"] > max(c["high_price"] for c in c1[-4:-1])
    )

    # === Early (Probe) ì§„ì… íŒë‹¨ ===
    r = relax_knob()
    twin = t15 if t15["krw_per_sec"] >= t45["krw_per_sec"] else t45
    vgap = (cur["trade_price"] / max(vwap_from_candles_1m(c1, 20), 1) - 1)
    turn = twin["krw"] / max(ob["depth_krw"], 1)
    flow_floor = int(EARLY_FLOW_MIN_KRWPSEC * (0.80 if r >= 1.0 else 1.0))

    early_conds = [
        vgap >= max(th["vwap_gap"] - 0.0003, EARLY_MIN_VWAP_GAP),
        vgap <= EARLY_MAX_VWAP_GAP,
        price_change <= 0.020,
        (ema5 is None) or (dist_ema5 <= EARLY_MAX_EMA5_GAP),
        twin["buy_ratio"] >= max(EARLY_MIN_BUY, 0.51),
        twin["krw_per_sec"] >= flow_floor,
        turn >= max(EARLY_MIN_TURN, 0.015),
        twin["n"] >= EARLY_MIN_TICKS,
        last_two_ticks_fresh(ticks),
    ]

    early_ok = all(early_conds)

    # === Confirm (í™•ì • ì§„ì… íŒë‹¨) ===
    confirm_ok = (
        ign_ok or botacc_ok or mega or two_green_and_break
        or (early_ok and twin["buy_ratio"] >= 0.58 and uptick_streak_from_ticks(ticks, need=3))
    )

    # === Probe/Confirm ê²°ê³¼ ===
    if not (early_ok or confirm_ok):
        cut("NO_SIGNAL", f"{m} no entry cond")
        return None

    entry_mode = "confirm" if confirm_ok else "probe"

    # === ê²°ê³¼ íŒ¨í‚¤ì§• ===
    pre = {
        "price": cur["trade_price"],
        "change": price_change,
        "current_volume": current_volume,
        "volume_surge": (current_volume / max(statistics.mean(past_volumes) if past_volumes else current_volume / 8, 1)),
        "ob": ob,
        "tape": twin,
        "ticks": ticks,
        "ema5_gap": dist_ema5,
        "ign_ok": ign_ok,
        "botacc_ok": botacc_ok,
        "two_green_break": two_green_and_break,
        "early_ok": early_ok,
        "entry_mode": entry_mode,
    }
    if mega:
        pre["mega_ok"] = True

    return pre

def final_check_leader(m, pre, tight_mode=False):
    # â˜…â˜…â˜… ì™„í™” ë…¸ë¸Œ ì ìš©
    r = relax_knob()
    t = pre["tape"]
    ob = pre["ob"]
    ticks = pre["ticks"]
    MIN_TURNOVER_LOCAL = max(0.020, _turn_needed(ob.get("depth_krw", 0)))
    if tight_mode:
        MIN_TURNOVER_LOCAL += 0.003
    if 0 <= now_kst().hour < 6:
        MIN_TURNOVER_LOCAL = max(0.018, MIN_TURNOVER_LOCAL - 0.004)
    MIN_TURNOVER_LOCAL = max(0.020, MIN_TURNOVER_LOCAL - 0.002 * r)  # â˜… ì¶”ê°€

    TICKS_BUY_RATIO_LOCAL = max(
        0.56, TICKS_BUY_RATIO + (0.02 if tight_mode else 0.0))
    TICKS_BUY_RATIO_LOCAL = max(0.54,
                                TICKS_BUY_RATIO_LOCAL - 0.015 * r)  # â˜… ì¶”ê°€

    if t["n"] < MIN_TICKS_COUNT:
        cut("TICKS_LOW", f"{m} {t['n']}")
        return None
    turn = t["krw"] / max(ob["depth_krw"], 1)
    if turn < MIN_TURNOVER_LOCAL:
        cut("TURN_LOW", f"{m} turn {turn:.3f}")
        return None
    if t["buy_ratio"] < TICKS_BUY_RATIO_LOCAL:
        cut("BUY_WEAK", f"{m} buy {t['buy_ratio']:.2f}")
        return None
    if t["n"] >= 10 and t["buy_ratio"] < 0.63:
        cut("BUY_WEAK_MANYT", f"{m} weak many")
        return None
    if not last_two_ticks_fresh(ticks):
        cut("FRESH_FAIL", f"{m} stale")
        return None

    th = get_dynamic_thresholds()
    raw_ob = ob["raw"]["orderbook_units"][:3]
    bid_sum = sum(u["bid_size"] * u["bid_price"] for u in raw_ob)
    ask_sum = sum(u["ask_size"] * u["ask_price"] for u in raw_ob)
    if bid_sum / max(ask_sum, 1) < th["bidask_min"]:
        cut("BIDASK_WEAK", f"{m} bidask weak")
        return None

    max_spread = MAX_SPREAD_FAST if t.get("rate",
                                          0) >= 0.7 else MAX_SPREAD_BASE
    if ob["spread"] > max_spread:
        cut("SPREAD_HIGH", f"{m} spread {ob['spread']:.2f}%")
        return None

    price_change = pre.get("change", 0.0)

    return {
        "price": pre["price"],
        "chg": round(price_change * 100, 2),
        "current_volume": int(pre["current_volume"]),
        "volume_surge": round(pre.get("volume_surge", 0.0), 2),
        "buy": round(t["buy_ratio"] * 100, 1),
        "n": t["n"],
        "spread": round(ob["spread"], 2),
        "turn": round((t['krw'] / max(ob['depth_krw'], 1)) * 100, 2)
    }


# =========================
# === [DL LOGGING]
# =========================
LOG_PATH = os.path.join(os.getcwd(), os.getenv("DL_LOG_PATH",
                                               "signals_log.csv"))
_CSV_LOCK = threading.Lock()

DL_FIELDS = [
    "ts", "market", "entry_price", "chg_1m", "chg_5m", "chg_15m", "zscore_1m",
    "vwap_gap", "t15_buy", "t15_n", "t15_rate", "t15_krw", "turn", "spread",
    "depth_krw", "bidask_ratio", "volume_surge", "btc_1m", "btc_5m", "hour",
    "dow", "two_green_break", "ignition_ok", "early_ok", "uptick_ok", "ret_3m",
    "ret_10m", "ret_15m", "maxdd_10m", "maxrun_10m", "label_win10",
    "label_fail10"
]


def append_csv(row: dict):
    with _CSV_LOCK:
        new = not os.path.exists(LOG_PATH)
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=DL_FIELDS)
            if new: w.writeheader()
            for k in DL_FIELDS:
                if k not in row: row[k] = ""
            w.writerow(row)


def snapshot_row(m, entry_price, payload, pre, c1, ob, t15, btc1m, btc5m,
                 flags):
    try:
        raw_ob = ob["raw"]["orderbook_units"][:3]
        bid_sum = sum(u["bid_size"] * u["bid_price"] for u in raw_ob)
        ask_sum = sum(u["ask_size"] * u["ask_price"] for u in raw_ob)
        bidask_ratio = bid_sum / max(ask_sum, 1)
    except:
        bidask_ratio = 0.0

    row = {
        "ts": now_kst_str(),
        "market": m,
        "entry_price": int(entry_price),
        "chg_1m": round(flags.get("chg_1m", 0.0), 4),
        "chg_5m": flags.get("chg_5m", ""),
        "chg_15m": flags.get("chg_15m", ""),
        "zscore_1m": flags.get("zscore", ""),
        "vwap_gap": flags.get("vwap_gap", ""),
        "t15_buy": round(t15.get("buy_ratio", 0.0), 4),
        "t15_n": t15.get("n", 0),
        "t15_rate": round(t15.get("rate", 0.0), 4),
        "t15_krw": int(t15.get("krw", 0)),
        "turn": flags.get("turn", ""),
        "spread": payload.get("spread", ""),
        "depth_krw": ob.get("depth_krw", ""),
        "bidask_ratio": round(bidask_ratio, 3),
        "volume_surge": payload.get("volume_surge", ""),
        "btc_1m": btc1m,
        "btc_5m": btc5m,
        "hour": now_kst().hour,
        "dow": now_kst().weekday(),
        "two_green_break": 1 if flags.get("two_green_break") else 0,
        "ignition_ok": 1 if flags.get("ign_ok") else 0,
        "early_ok": 1 if flags.get("early_ok") else 0,
        "uptick_ok": 1 if flags.get("uptick_ok") else 0,
        "ret_3m": "",
        "ret_10m": "",
        "ret_15m": "",
        "maxdd_10m": "",
        "maxrun_10m": "",
        "label_win10": "",
        "label_fail10": ""
    }
    return row


# =========================
# í¬ìŠ¤íŠ¸ì²´í¬ 6ì´ˆ
# =========================
from collections import deque


def postcheck_6s(m, pre):
    if not POSTCHECK_ENABLED:
        return True, "SKIP"
    if pre.get("ign_ok") or pre.get("two_green_break") or pre.get(
            "mega_ok", False):
        return True, "BYPASS_STRONG_BREAK"

    # â˜…â˜…â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
    r = relax_knob()
    pc_min_buy = max(0.46, POSTCHECK_MIN_BUY - 0.05 * r)   # 0.48 -> 0.46, ì™„í™”í­ ì‚´ì§â†‘
    pc_min_rate = max(0.14, POSTCHECK_MIN_RATE - 0.09 * r) # 0.16 -> 0.14
    pc_max_pstd = POSTCHECK_MAX_PSTD + 0.0005 * r          # ì‚´ì§ ë” ê´€ëŒ€
    pc_max_cv = POSTCHECK_MAX_CV + 0.18 * r
    pc_max_dd = POSTCHECK_MAX_DD + 0.005 * r

    window = POSTCHECK_WINDOW_SEC
    start = time.time()
    acc = deque(maxlen=400)  # ëˆ„ìˆ˜ ë°©ì§€
    seen = set()  # ì¤‘ë³µ ì°¨ë‹¨

    last_fetch = 0.0
    net_calls = 0  # â˜… ì´ë²ˆ postcheckì—ì„œ ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜
    # ë°¤ì—ëŠ” ì¡°ê¸ˆ ëŠìŠ¨, ì£¼ê°„ì—” ì•½ê°„ ë¹ ë¥´ê²Œ
    fetch_interval = 2.0 if (0 <= now_kst().hour < 6) else 1.6
    ok_streak = 0

    base_price = pre["price"]
    peak = base_price
    trough_after_peak = base_price  # í”¼í¬ ì´í›„ ìµœì €ê°€ ì¶”ì 

    # â˜…â˜…â˜… ì—¬ê¸° í•œ ì¤„ ì¶”ê°€ (postcheck ì¤‘ ìµœëŒ€ í—ˆìš© ê¸‰ë“±)
    MAX_SURGE = 0.015  # 1.5% ì´ìƒì´ë©´ ê³ ì  ì¶”ê²©ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ì»·

    while True:
        now = time.time()
        if now - start > window:
            break

        # ìºì‹œ ì¬ì‚¬ìš© + ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜ ì œí•œ
        if (now - last_fetch >= fetch_interval) and (net_calls < 2):
            # ìµœëŒ€ 2ë²ˆê¹Œì§€ë§Œ ì‹¤ì œ API í˜¸ì¶œ
            ticks = get_recent_ticks(m, 100, allow_network=True)
            last_fetch = now
            net_calls += 1
        else:
            # ë‚˜ë¨¸ì§€ëŠ” ìºì‹œë§Œ ì‚¬ìš©
            ticks = get_recent_ticks(m, 100, allow_network=False)

        if not ticks:
            time.sleep(0.45)
            continue

        # accì— ìµœì‹  í‹±ë§Œ ì¤‘ë³µì—†ì´ ì¶•ì 
        for x in ticks[:12]:
            key = (x.get("timestamp"), x.get("trade_price"),
                   x.get("trade_volume"))
            if key in seen:
                continue
            seen.add(key)
            acc.appendleft(x)  # ìµœì‹ ì´ ì•

        curp = ticks[0].get("trade_price", base_price)

        # â˜…â˜…â˜… ê°€ê²© ê¸‰ë“± ì»· ì¶”ê°€
        if base_price > 0:
            surge = (curp / base_price - 1.0)
            if surge >= MAX_SURGE:
                return False, f"SURGE_IN_POST({surge*100:.2f}%)"

        if curp > peak:
            peak = curp
            trough_after_peak = curp  # ìƒˆ í”¼í¬ê°€ ìƒê¸°ë©´ íŠ¸ë¡œí”„ ë¦¬ì…‹
        else:
            trough_after_peak = min(trough_after_peak, curp)

        # âœ” DDëŠ” í”¼í¬ ëŒ€ë¹„ í•˜ë½ë¥ (ìŒìˆ˜)ë¡œ ì²´í¬
        dd = (curp / peak - 1.0)

        t10 = micro_tape_stats_from_ticks(list(acc), 10)
        ia = inter_arrival_stats(list(acc), 20)
        pstd = price_band_std(list(acc), 20)

        # â˜… ê°€ë³€ ì„ê³„ì¹˜ ì ìš©
        pass_now = (t10["buy_ratio"] >= pc_min_buy
                    and t10["rate"] >= pc_min_rate and pstd <= pc_max_pstd
                    and ia["cv"] <= pc_max_cv and dd >= -pc_max_dd)

        if pass_now:
            ok_streak += 1
            if ok_streak >= 2:
                return True, "OK_EARLY"
        else:
            ok_streak = 0

        # í‹±ì´ ì¶©ë¶„íˆ ëŠë¦¬ë©´ ìŠ¬ë¦½ì„ ë” ê¸¸ê²Œ
        time.sleep(0.6 if t10["rate"] >= 0.6 else 1.0)

    if not acc:
        return False, "POST_NO_TICKS"

    # ì¢…ë£Œ ì‹œì  ì¬í‰ê°€ (acc ê¸°ë°˜ìœ¼ë¡œ í”¼í¬/íŠ¸ë¡œí”„ ê³„ì‚°)
    prices = [x.get("trade_price", base_price) for x in list(acc)]
    if prices:
        peak2 = max(prices + [base_price])
        curp2 = prices[0]
        dd2 = (curp2 / peak2 - 1.0)
    else:
        dd2 = 0.0

    t10 = micro_tape_stats_from_ticks(list(acc), 10)
    ia = inter_arrival_stats(list(acc), 20)
    pstd = price_band_std(list(acc), 20)

    # â˜… ìµœì¢… íŒì •ë„ ê°€ë³€ ì„ê³„ì¹˜ë¡œ
    if t10["buy_ratio"] < pc_min_buy:
        return False, f"BUY_LOW({t10['buy_ratio']:.2f})"
    if t10["rate"] < pc_min_rate: return False, f"RATE_LOW({t10['rate']:.2f})"
    if pstd > pc_max_pstd: return False, f"PSTD_HIGH({pstd:.4f})"
    if ia["cv"] > pc_max_cv: return False, f"CV_HIGH({ia['cv']:.2f})"
    if dd2 < -pc_max_dd: return False, f"DD_TOO_DEEP({dd2:.4f})"
    return True, "OK"

# =========================
# ë™ì  ì†ì ˆ
# =========================
def dynamic_stop_loss(entry_price, c1, signal_type=None, current_price=None):
    atr = atr14_from_candles(c1, ATR_PERIOD)
    if not atr or atr <= 0:
        return entry_price * (1 - STOP_LOSS_PCT), STOP_LOSS_PCT

    pct = min(max((atr / max(entry_price, 1)) * ATR_MULT, DYN_SL_MIN), DYN_SL_MAX * 0.9)

    # ğŸš€ ì‹ í˜¸ ìœ í˜•ë³„ ì™„í™”
    if signal_type in ("early", "ign", "mega"):
        pct *= 1.3

    # ğŸ’ ìµì ˆ ì¤‘ì´ë©´ ì†ì ˆí­ ë” ì™„í™” (ëˆŒë¦¼ ë°©ì§€)
    if current_price and current_price > entry_price * 1.008:
        pct *= 1.5  # ìˆ˜ìµ ì¤‘ì—ëŠ” SLì„ ë” ë©€ë¦¬ ë‘ 

    return entry_price * (1 - pct), pct

# =========================
# ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì²­ì‚° ì ìˆ˜
# =========================
def context_exit_score(m, ticks, ob_depth_krw, entry_price, last_price, c1):
    """
    íœ˜í•‘ ë°©ì§€í˜• ì»¨í…ìŠ¤íŠ¸ ì ìˆ˜:
    - ë‹¨ì¼ ì‹ í˜¸ë¡œ ì²­ì‚° ìœ ë„ ê¸ˆì§€ (ë³µí•© ì¡°ê±´ ëˆ„ì )
    - ì¶”ì„¸ ì—­ì „(EMA5/VWAP ì´íƒˆ + uptick ë¶€ì¬) ìª½ì— ê°€ì¤‘ì¹˜
    """
    score = 0
    reasons = []

    # í…Œì´í”„ ë³€í™”
    w_now = _win_stats(ticks, 0, 10)
    w_early = _win_stats(ticks, 10, 30)
    decay, _ = buy_decay_flag(ticks)

    if w_now["krw_per_sec"] < w_early["krw_per_sec"] * 0.60:
        score += 1
        reasons.append("FLOW_DROP")
    if not uptick_streak_from_ticks(ticks, need=2):
        score += 1
        reasons.append("NO_UPTICK")
    if w_now["rate"] < 0.25:  # ë„ˆë¬´ ëŠë¦¬ë©´ 1ì 
        score += 1
        reasons.append("RATE_SLOW")

    # ê°€ê²©/ì»¨í…ìŠ¤íŠ¸
    vwap = vwap_from_candles_1m(c1, 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in c1], 5) if c1 else 0
    if vwap and last_price < vwap:
        score += 1
        reasons.append("VWAP_LOSS")
    if ema5 and last_price < ema5:
        score += 1
        reasons.append("EMA5_LOSS")

    # ğŸ’ ì•½ìƒìŠ¹/íš¡ë³´ ì‹œ ì²­ì‚° ì ìˆ˜ ì™„í™”
    gain_now = (last_price / entry_price - 1.0)
    if -0.004 <= gain_now <= 0.008:  # ì™„í™” ë²”ìœ„ í™•ëŒ€
        score = max(0, score - 1)
        reasons.append("MILD_GAIN_RELAX")

    # ìˆ˜ìµ êµ¬ê°„ì—ì„œì˜ ê¸‰ê°
    if last_price > entry_price * 1.008 and decay:
        score += 1
        reasons.append("DECAY_AFTER_GAIN")

    return score, reasons

# =========================
# â˜… ëª¨ë‹ˆí„°ë§ ì‹œê°„ ê²°ì • (ì‹ ê·œ ì¶”ê°€)
# =========================
def decide_monitor_secs(pre: dict, tight_mode: bool = False) -> int:
    """
    í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì´ ì‹œê°„(ì´ˆ)ì„ ìƒí™©ë³„ë¡œ ê²°ì •.
    - early_ok: ë¹„êµì  ì§§ê²Œ ì¶”ì„¸ í™•ì¸
    - ignition_ok / mega_ok: ìƒëŒ€ì ìœ¼ë¡œ ê¸¸ê²Œ (ì¶”ì„¸ ì´ì–´ì§ˆ ê°€ëŠ¥ì„±)
    - ì‹œì¥ ëª¨ë“œ(TIGHT), ì•¼ê°„, BTC ëª¨ë©˜í…€, ì˜¤ë”ë¶ ê¹Šì´ ë“±ì— ë”°ë¼ ê°€/ê°
    """
    try:
        r = relax_knob()  # 0.0 ~ 1.5
    except Exception:
        r = 0.0

    base = 150  # ê¸°ë³¸ê°’

    # ì‹ í˜¸ ìœ í˜• ê°€ì¤‘
    if pre.get("mega_ok"):
        base = 300
    elif pre.get("ign_ok"):
        base = 240
    elif pre.get("botacc_ok"):
        base = 210
    elif pre.get("early_ok"):
        base = 180
    elif pre.get("two_green_break"):
        base = 210

    # ì˜¤ë”ë¶ ê¹Šì´ ê¸°ë°˜ (ê¹Šìœ¼ë©´ ì—¬ìœ  ìˆê²Œ)
    ob_depth = 0
    try:
        ob_depth = pre.get("ob", {}).get("depth_krw", 0) or 0
    except Exception:
        pass
    if ob_depth >= 30_000_000:
        base += 30
    elif ob_depth <= 6_000_000:
        base -= 30

    # BTC 5ë¶„ ëª¨ë©˜í…€
    try:
        b5 = btc_5m_change()
    except Exception:
        b5 = 0.0
    if b5 >= 0.006:
        base += 30
    elif b5 <= -0.008:
        base -= 30

    # ì•¼ê°„(00~06 KST)ì—” í”ë“¤ë¦¼ ëŒ€ë¹„ ì•½ê°„ ë‹¨ì¶•
    h = now_kst().hour
    if 0 <= h < 6:
        base -= 15

    # ì¥ì„¸ ì™„í™” ë…¸ë¸Œ ë°˜ì˜
    base += int(10 * r)

    # íƒ€ì´íŠ¸ ëª¨ë“œ(ê¸‰ë½ ë°©ì–´)ë©´ ë‹¨ì¶•
    if tight_mode:
        base -= 30

    # í•˜í•œ/ìƒí•œ í´ë¨í”„
    base = max(90, min(base, 360))
    return int(base)


# =========================
# ëì•ŒëŒ ê¶Œê³  ìƒì„± (END RECO)
# =========================
def _end_reco(entry_price, last_price, c1, ticks, ob_depth_krw, ctx_thr=3):
    """
    ëì•ŒëŒìš© ê¶Œê³  ìƒì„±:
      - ìˆ˜ìµ/ì†ì‹¤, ì»¨í…ìŠ¤íŠ¸, í…Œì´í”„ íë¦„ ì¢…í•©ìœ¼ë¡œ
        ğŸ‘‰ ìœ ì§€ / ë¶€ë¶„ì²­ì‚° / ì „ëŸ‰ì²­ì‚° ì„¸ ê°€ì§€ ì•¡ì…˜ ì œì•ˆ
    """
    try:
        ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
    except:
        ret_pct = 0.0

    # ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´(ì¶”ì„¸ì—­ì „ ì‹ í˜¸ë“¤)
    try:
        ctx_score, ctx_reasons = context_exit_score(
            "KRW-XXX",
            ticks or [],
            ob_depth_krw or 10_000_000,
            entry_price,
            last_price,
            c1 or [],
        )
    except Exception:
        ctx_score, ctx_reasons = (0, [])

    # í…Œì´í”„(ìµœê·¼ 15s)
    t15 = micro_tape_stats_from_ticks(ticks or [], 15)
    buy = t15.get("buy_ratio", 0.0)
    n = t15.get("n", 0)

    # ì»¨í…ìŠ¤íŠ¸(EMA5 / VWAP)
    vwap = vwap_from_candles_1m(c1 or [], 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in (c1 or [])], 5) if c1 else 0
    vwap_ok = bool(vwap and last_price >= vwap)
    ema_ok = bool(ema5 and last_price >= ema5)

    # ğŸ’ ê±°ë˜ ë‘”í™” + ì•½ìƒìŠ¹ â†’ ë³¸ì ˆ ìµì ˆ ìœ ë„
    if -0.2 <= ret_pct <= 0.4 and t15.get("krw_per_sec", 0) < 12000 and ctx_score <= ctx_thr:
        action = "ë¶€ë¶„ ì²­ì‚°(ë³¸ì ˆ)"
        rationale = f"ê±°ë˜ë‘”í™” êµ¬ê°„ ë³¸ì ˆ ìµì ˆ ({ret_pct:+.2f}%)"
        return action, rationale

    # -----------------------------
    # 1) ì „ëŸ‰ ì²­ì‚° ê¶Œê³  ì¡°ê±´ (ê°•í•œ ì²­ì‚°)
    # -----------------------------
    full_exit = False
    why_full = []

    # (1) ì†ì‹¤ì´ ë§ì´ ì»¤ì¡Œì„ ë•Œ
    if ret_pct <= -2.0:
        full_exit = True
        why_full.append(f"ì†ì‹¤ {ret_pct:+.2f}%")

    # (2) ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´ê°€ ì„ê³„ì¹˜ë³´ë‹¤ ë§ì´ ë†’ê³ , VWAP/EMAë„ ê¹¨ì ¸ ìˆì„ ë•Œ
    if ctx_score >= (ctx_thr + 1) and not vwap_ok and not ema_ok:
        full_exit = True
        why_full.append(f"ì»¨í…ìŠ¤íŠ¸ {ctx_score}/{ctx_thr}")

    # (3) ì•½ì†ì‹¤ ìƒíƒœì—ì„œ ë§¤ìˆ˜ì„¸Â·í…Œì´í”„ê°€ ë§ì´ ì£½ì€ ê²½ìš°
    if ret_pct < -0.8 and buy < 0.50 and n >= 4:
        full_exit = True
        why_full.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    if full_exit:
        action = "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ "
        rationale = " Â· ".join(why_full) if why_full else "ë¦¬ìŠ¤í¬ ìš°ìœ„"
        return action, rationale

    # -----------------------------
    # 2) ë¶€ë¶„ ì²­ì‚° ê¶Œê³  (ì• ë§¤/ê²½ê³  êµ¬ê°„)
    # -----------------------------
    partial_exit = False
    why_partial = []

    # ìˆ˜ìµì´ í¬ì§€ ì•Šì€ êµ¬ê°„
    if -0.8 < ret_pct < 0.8:
        partial_exit = True
        why_partial.append(f"ìˆ˜ìµ {ret_pct:+.2f}%")

    # ì»¨í…ìŠ¤íŠ¸ ê²½ê³  ë ˆë²¨
    if ctx_score == ctx_thr:
        partial_exit = True
        why_partial.append(f"ì»¨í…ìŠ¤íŠ¸ ê²½ê³  {ctx_score}/{ctx_thr}")

    # ë§¤ìˆ˜ë¹„ ì•½í•˜ê³  í‹±ì€ ë§ì€ ê²½ìš°
    if buy < 0.55 and n >= 6:
        partial_exit = True
        why_partial.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    # ğŸš€ ê±°ë˜ë‘”í™” ì‹œ ìë™ ë¶€ë¶„ìµì ˆ ê¶Œê³ 
    if ret_pct >= 1.5 and t15["krw_per_sec"] < 15000:
        partial_exit = True
        why_partial.append(f"ê±°ë˜ì†ë„ ë‘”í™” {t15['krw_per_sec']:.0f} KRW/s")

    # VWAP/EMA ë‘˜ ë‹¤ í•˜ë°©ì¼ ë•Œ
    if not vwap_ok and not ema_ok:
        partial_exit = True
        why_partial.append("VWAPÂ·EMA5 í•˜ë°©")

    if partial_exit:
        action = "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ "
        rationale = " Â· ".join(why_partial) if why_partial else "ë¶ˆí™•ì‹¤ êµ¬ê°„"
        return action, rationale

    # -----------------------------
    # 3) ìœ ì§€ ê¶Œê³  (ì¶”ì„¸ ìœ ì§€)
    # -----------------------------
    why_keep = [f"ìˆ˜ìµ {ret_pct:+.2f}%"]
    if vwap_ok:
        why_keep.append("VWAP ìƒë°©")
    if ema_ok:
        why_keep.append("EMA5 ìƒë°©")
    if buy >= 0.60 and n >= 4:
        why_keep.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    rationale = " Â· ".join(why_keep)
    return "ìœ ì§€ ê¶Œê³ ", rationale


# =========================
# ëª¨ë‹ˆí„°ë§(ìµœì¢…í˜•)
# =========================
def monitor_position(m,
                     entry_price,
                     pre,
                     tight_mode=False,
                     horizon=None,
                     reentry=False):
    c1 = get_minutes_candles(1, m, 20)
    base_stop, eff_sl_pct = dynamic_stop_loss(entry_price, c1)

    # horizonì´ ì•ˆ ë“¤ì–´ì˜¤ë©´ ìë™ ê²°ì •, ë“¤ì–´ì˜¤ë©´ ê·¸ ê°’ ì‚¬ìš©
    if horizon is None:
        horizon = decide_monitor_secs(pre, tight_mode=tight_mode)
    start_ts = time.time()

    # ë””ë°”ìš´ìŠ¤/íŠ¸ë ˆì¼ ìƒíƒœ
    # ì†ì ˆ ë””ë°”ìš´ìŠ¤ìš©
    stop_first_seen_ts = 0.0
    stop_hits = 0
    # ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ë””ë°”ìš´ìŠ¤ìš©
    ctx_first_seen_ts = 0.0
    ctx_hits = 0

    trail_armed = False
    trail_stop = 0.0

    # ìŠ¤íŒŒì´í¬/ê·¸ë ˆì´ìŠ¤ ê¸°ì¡´ ë¡œì§ ì¬í™œìš©
    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 10
    grace_used = False
    spike_recovery_used = False

    ob = pre.get("ob")
    ob_depth_default = ob.get("depth_krw", 10_000_000) if ob else 10_000_000

    last_price = entry_price
    best = entry_price
    worst = entry_price

    # ì‹¤ì œ ë³´ìœ  ìˆ˜ëŸ‰ í™•ë³´ (ìµì ˆ ì‹œ ë§¤ë„ìš©)
    with _POSITION_LOCK:
        entry_volume = OPEN_POSITIONS.get(m, {}).get("volume", 0.0)

    verdict = None
    outcome_extra = ""

    # === í¬ì§€ì…˜ ëª¨ë“œ (probe / confirm) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m, {})
    entry_mode = pos.get("entry_mode", "confirm")

    try:
        while time.time() - start_ts <= horizon:
            time.sleep(RECHECK_SEC)

            ticks = get_recent_ticks(m, 100)
            if not ticks or len(ticks) < 3:
                consecutive_failures += 1
                if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                    time.sleep(3)
                    ticks = get_recent_ticks(m, 100)
                    if not ticks:
                        verdict = "ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨"
                        break
                    consecutive_failures = 0
                continue
            consecutive_failures = 0

            # í˜„ì¬ê°€
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            if not cur_js or len(cur_js) == 0:
                continue
            curp = cur_js[0].get("trade_price", last_price)
            last_price = curp
            best = max(best, curp)
            worst = min(worst, curp)

            # === 1) ì›œì—… êµ¬ê°„: ì†Œí­ ë˜ëŒë¦¼ ë¬´ì‹œ (ë‹¨, ê¸‰ë½ì€ ì¦‰ì‹œ ì»·)
            alive_sec = time.time() - start_ts
            dd_now = (curp / best - 1.0)
            if alive_sec < WARMUP_SEC:
                if (curp / entry_price - 1.0) <= -HARD_STOP_DD:
                    verdict = "ê¸‰ë½ ì¦‰ì‹œ ì†ì ˆ"
                    outcome_extra = f"(DD {dd_now*100:.2f}%)"
                    break  # ì²­ì‚°ì€ finallyì—ì„œ í•œ ë²ˆë§Œ
                # ì›œì—… ì¤‘ì—” ì†Œí”„íŠ¸ ìŠ¤íƒ‘ ë¯¸ì ìš©
                continue

            # === 2) íŠ¸ë ˆì¼ë§ ì†ì ˆ: ì´ìµì´ ë‚˜ì•¼ë§Œ ë¬´ì¥
            gain_from_entry = (curp / entry_price - 1.0)
            
            # === PROBE â†’ CONFIRM ì „í™˜ ë¡œì§ ===
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m, {})

            if pos.get("entry_mode") == "probe":
                # ì „í™˜ ì¡°ê±´: ì¼ì • ìˆ˜ìµ ì´ìƒ + ê±°ë˜ì†ë„ ì •ìƒ + ë§¤ìˆ˜ì„¸ ìœ ì§€
                t15_now = micro_tape_stats_from_ticks(ticks, 15)
                from decimal import Decimal, getcontext
                getcontext().prec = 10  # ì†Œìˆ˜ì  ì •ë°€ë„ ì„¤ì •

                gain_now = (Decimal(curp) / Decimal(entry_price) - Decimal(1))

                strong_flow = (
                    t15_now["buy_ratio"] >= 0.58
                    and t15_now["krw_per_sec"] >= 18000
                    and uptick_streak_from_ticks(ticks, need=2)
                )

                if gain_now >= 0.012 and strong_flow:
                    ok_add, new_entry = add_auto_position(m, curp)
                    if ok_add and new_entry:
                        # ì§„ì…ëª¨ë“œ ìŠ¹ê²©
                        with _POSITION_LOCK:
                            pos["entry_mode"] = "confirm"
                            pos["entry_price"] = new_entry
                            pos["added"] = True
                            pos["last_add_ts"] = time.time()
                            OPEN_POSITIONS[m] = pos

                        tg_send_mid(
                            f"ğŸ”¥ {m} ìƒìŠ¹ í™•ì • â†’ probe âœ confirm ì „í™˜\n"
                            f"ì¶”ë§¤ í›„ í‰ë‹¨: {fmt6(new_entry)}ì›"
                        )

                        # ë™ì  ì†ì ˆ ì¬ê³„ì‚°
                        c1_for_sl = get_minutes_candles(1, m, 20)
                        base_stop, eff_sl_pct = dynamic_stop_loss(new_entry, c1_for_sl)
                        trail_armed = False  # ìƒˆ ê¸°ì¤€ìœ¼ë¡œ íŠ¸ë ˆì¼ë§ ë¦¬ì…‹

            if (not trail_armed) and gain_from_entry >= TRAIL_ARM_GAIN:
                trail_armed = True
                # ì´ˆê¸° íŠ¸ë ˆì¼: ATR ê¸°ì¤€ í˜¹ì€ ìµœì†Œê±°ë¦¬
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(TRAIL_DISTANCE_MIN,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = TRAIL_DISTANCE_MIN
                trail_stop = curp * (1.0 - trail_dist)

            # === 2-1) í”¼ë¼ë¯¸ë”©(ì¶”ë§¤): ì™„í™”í˜• ë¡œì§ (ë¶€ë¶„ì²­ì‚° í›„ ì¬ìƒìŠ¹ ëŒ€ì‘) ===
            if USE_PYRAMIDING and AUTO_TRADE:
                t15_now = micro_tape_stats_from_ticks(ticks, 15)

                # ğŸ’¡ ì¡°ê±´ ì™„í™” â€” ì•½ìƒìŠ¹ì—ì„œë„ ë°˜ì‘í•˜ë„ë¡
                add_cond_price = gain_from_entry >= max(0.005, PYRAMID_ADD_MIN_GAIN * 0.8)
                add_cond_flow = (
                    t15_now["buy_ratio"] >= 0.55 and
                    t15_now["krw_per_sec"] >= PYRAMID_ADD_FLOW_MIN_KRWPSEC * 0.8 and
                    last_two_ticks_fresh(ticks)
                )

                # ğŸ“Š ë‹¨ê¸° EMA ê¸°ì¤€ìœ¼ë¡œ ë‹¨ê¸° ìƒìŠ¹ ì „í™˜ ê°ì§€ (1ë¶„ë´‰)
                c1m = get_minutes_candles(1, m, 20)
                ema3 = ema_last([c["trade_price"] for c in c1m], 3)
                ema8 = ema_last([c["trade_price"] for c in c1m], 8)
                short_term_up = ema3 > ema8

                if add_cond_price and add_cond_flow and short_term_up:
                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        already_added = pos.get("added") if pos else True
                        last_add_ts = pos.get("last_add_ts", 0.0) if pos else 0.0

                    # ì¿¨ë‹¤ìš´ì„ 40% ë‹¨ì¶•í•´ ì¬ì§„ì…ì„± í–¥ìƒ
                    cooldown_ok = (time.time() - last_add_ts) >= (PYRAMID_ADD_COOLDOWN_SEC * 0.6)

                    if pos and (not already_added) and cooldown_ok:
                        ok_add, new_entry = add_auto_position(m, curp)
                        if ok_add and new_entry:
                            entry_price = new_entry
                            c1_for_sl = get_minutes_candles(1, m, 20)
                            base_stop, eff_sl_pct = dynamic_stop_loss(entry_price, c1_for_sl)
                            tg_send_mid(
                                f"â• <b>{m}</b> ì¬ìƒìŠ¹ ê°ì§€ â†’ ì¶”ë§¤ ì²´ê²°<br>"
                                f"ğŸ’µ ìƒˆ í‰ë‹¨ {entry_price:,.0f}ì›<br>"
                                f"ğŸ§¯ ì†ì ˆ {base_stop:,.0f}ì› ({eff_sl_pct*100:.2f}%)"
                            )

            # íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸(ì´ìµ í™•ëŒ€ ì‹œì—ë§Œ ìƒí–¥)
            if trail_armed and curp > best:
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(TRAIL_DISTANCE_MIN,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = TRAIL_DISTANCE_MIN
                trail_stop = max(trail_stop, curp * (1.0 - trail_dist))

            # ìœ íš¨ ìŠ¤íƒ‘ = max(ê¸°ë³¸ ë™ì  SL, íŠ¸ë ˆì¼ë§)
            effective_stop = max(base_stop, trail_stop if trail_armed else 0.0)

            # === ğŸ”¥ í”„ë¡œ ë§¤ë„ ë¡œì§ (ì†ì‹¤ ìµœì†Œí™” + ìµì ˆ ìµœëŒ€í™”) ===
            t15 = micro_tape_stats_from_ticks(ticks, 15)
            t30 = micro_tape_stats_from_ticks(ticks, 30)

            cur_gain = (curp / entry_price - 1.0)
            drop_from_high = (best - curp) / best

            # ATR ê³„ì‚° (ë™ì  ì¡°ì •ìš©)
            atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
            atr_ratio = (atr / max(curp, 1)) if atr and atr > 0 else 0.01

            # ë¶€ë¶„ìµì ˆ í”Œë˜ê·¸ (1íšŒë§Œ í—ˆìš©)
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m, {})
                partial_done = pos.get("partial_done", False)

            # ========================================
            # ìš°ì„ ìˆœìœ„ 1: ì†ì ˆ (í•˜ë“œìŠ¤í†± + ë™ì  ì†ì ˆ)
            # ========================================
            # í•˜ë“œ ìŠ¤í†± (-1.5%)
            if cur_gain <= -0.015:
                sell_market(m, entry_volume)
                tg_send_mid(f"ğŸ©¸ {m} ê¸‰ë½ -1.5% í•˜ë“œìŠ¤í†±")
                verdict = "HARD_STOP"
                break

            # ë™ì  ì†ì ˆ (base_stop í„°ì¹˜)
            if curp <= base_stop:
                sell_market(m, entry_volume)
                tg_send_mid(f"ğŸ›‘ {m} ë™ì  ì†ì ˆ ({fmt6(base_stop)}ì›) í„°ì¹˜ â†’ ì†ì ˆ")
                verdict = "DYNAMIC_STOP"
                break

            # ========================================
            # ìš°ì„ ìˆœìœ„ 2: BE(ë³¸ì ˆ) ìŠ¹ê²© (ì†ì‹¤ ìµœì†Œí™” í•µì‹¬)
            # ========================================
            # ìˆ˜ì •: 0.6% â†’ 1.0% ëŠ¦ì¶¤, FEE*2 â†’ FEE*1 (ë¯¸ì„¸ì†ì ˆ ë°©ì§€)
            if cur_gain >= 0.010:
                be_lock = entry_price * (1 + FEE_RATE)  # ë³¸ì ˆ + ìˆ˜ìˆ˜ë£Œë§Œ
                base_stop = max(base_stop, be_lock)

            # ========================================
            # ìš°ì„ ìˆœìœ„ 3: ë¶€ë¶„ìµì ˆ 3ë‹¨ê³„ (ìµì ˆ ìµœëŒ€í™”)
            # ========================================
            # TP1: 1.2% or ATR*1.5 ì¤‘ í° ê°’ (ê¸°ì¡´ 0.8% â†’ 1.2% ìƒí–¥)
            tp1 = entry_price * (1 + max(0.012, atr_ratio * 1.5))
            # TP2: 2.0% or ATR*2.2 ì¤‘ í° ê°’ (ê¸°ì¡´ 1.5% â†’ 2.0% ìƒí–¥)
            tp2 = entry_price * (1 + max(0.020, atr_ratio * 2.2))

            if not partial_done and curp >= tp1 and curp < tp2:
                # TP1 ë„ë‹¬: 30% ë¶€ë¶„ìµì ˆ
                partial_volume = entry_volume * 0.3
                if sell_market(m, partial_volume):
                    entry_volume = entry_volume * 0.7
                    with _POSITION_LOCK:
                        if m in OPEN_POSITIONS:
                            OPEN_POSITIONS[m]["partial_done"] = True
                            OPEN_POSITIONS[m]["volume"] = entry_volume
                    # stop ìŠ¹ê²©
                    base_stop = max(base_stop, entry_price * 1.005)  # ë³¸ì ˆ+0.5%
                    tg_send_mid(f"ğŸ’° {m} TP1 ë„ë‹¬ â†’ 30% ìµì ˆ (ë‚¨ì€ 70%ëŠ” íŠ¸ë ˆì¼)")
                    verdict = "TP1_PARTIAL"
                continue

            if not partial_done and curp >= tp2:
                # TP2 ë„ë‹¬: 40% ë¶€ë¶„ìµì ˆ
                partial_volume = entry_volume * 0.4
                if sell_market(m, partial_volume):
                    entry_volume = entry_volume * 0.6
                    with _POSITION_LOCK:
                        if m in OPEN_POSITIONS:
                            OPEN_POSITIONS[m]["partial_done"] = True
                            OPEN_POSITIONS[m]["volume"] = entry_volume
                    # stop ìŠ¹ê²© + íŠ¸ë ˆì¼ í™œì„±í™”
                    base_stop = max(base_stop, entry_price * 1.005)  # ë³¸ì ˆ+0.5%
                    trail_armed = True
                    trail_stop = max(trail_stop, curp * (1.0 - max(0.010, atr_ratio * 1.25)))
                    tg_send_mid(f"ğŸš€ {m} TP2 ë„ë‹¬ â†’ 40% ìµì ˆ + íŠ¸ë ˆì¼ í™œì„±í™” (ë‚¨ì€ 60%)")
                    verdict = "TP2_PARTIAL"
                continue

            # ========================================
            # ìš°ì„ ìˆœìœ„ 4: í…Œì´í”„ íˆ¬í‘œ ì „ëŸ‰ë§¤ë„ (íë¦„ ë¶•ê´´)
            # ========================================
            # ì´ˆë°˜ 30ì´ˆëŠ” ì›œì—… ê¸°ê°„ (ë…¸ì´ì¦ˆ ë¬´ì‹œ)
            alive_sec = time.time() - start_ts
            flow_votes = 0

            if alive_sec >= 30:  # 30ì´ˆ ì´í›„ë§Œ íˆ¬í‘œ ì‹¤í–‰
                flow_votes += int(t15["krw_per_sec"] < 0.65 * t30["krw_per_sec"])  # ê±°ë˜ëŸ‰ ê¸‰ë½
                flow_votes += int(t15["buy_ratio"] < 0.52)  # ë§¤ìˆ˜ì„¸ ì•½í™”
                flow_votes += int(not uptick_streak_from_ticks(ticks, need=2))  # uptick ë¶€ì¬

                # ìˆ˜ì •: 2/3 â†’ 3/3 (ëª¨ë“  ì‹ í˜¸ê°€ ë‚˜ë¹ ì•¼ ì „ëŸ‰ë§¤ë„)
                if flow_votes >= 3 and cur_gain > -0.005:
                    sell_market(m, entry_volume)
                    tg_send_mid(f"ğŸ“Š {m} í…Œì´í”„ íˆ¬í‘œ (3/3 ì „ë¶€ ë‚˜ì¨) â†’ íë¦„ ë¶•ê´´ ì „ëŸ‰ë§¤ë„")
                    verdict = "FLOW_VOTED_EXIT"
                    break

            # ========================================
            # ìš°ì„ ìˆœìœ„ 5: ê³ ì  ë˜ëŒë¦¼ ë§¤ë„
            # ========================================
            # ìˆ˜ì •: -0.5% â†’ -0.8% ì™„í™”, ìµœì†Œ ì´ìµ ì¡°ê±´ ì¶”ê°€
            if drop_from_high >= 0.008 and t15["buy_ratio"] < 0.53 and not partial_done and cur_gain >= 0.006:
                # -0.5% ë˜ëŒë¦¼ + ë§¤ìˆ˜ì„¸ ì•½í™” â†’ ë¶€ë¶„ 30%
                partial_volume = entry_volume * 0.3
                if sell_market(m, partial_volume):
                    entry_volume = entry_volume * 0.7
                    with _POSITION_LOCK:
                        if m in OPEN_POSITIONS:
                            OPEN_POSITIONS[m]["partial_done"] = True
                            OPEN_POSITIONS[m]["volume"] = entry_volume
                    tg_send_mid(f"ğŸ“‰ {m} ê³ ì  ëŒ€ë¹„ -0.8% ë˜ëŒë¦¼ â†’ 30% ë¶€ë¶„ë§¤ë„")
                    verdict = "PEAK_FADE_PARTIAL"
                continue

            # ìˆ˜ì •: -1.0% â†’ -1.5% ì™„í™”, ìµœì†Œ ì´ìµ ì¡°ê±´ ì¶”ê°€
            if drop_from_high >= 0.015 and cur_gain >= 0.008:
                # -1.5% ë˜ëŒë¦¼ + ìµœì†Œ 0.8% ì´ìµ â†’ ì „ëŸ‰
                sell_market(m, entry_volume)
                tg_send_mid(f"ğŸš¨ {m} ê³ ì  ëŒ€ë¹„ -1.5% í•˜ë½ â†’ ì „ëŸ‰ìµì ˆ")
                verdict = "PEAK_CASCADE"
                break

            # ========================================
            # ìš°ì„ ìˆœìœ„ 6: ì´ìµë½ (ATR ê¸°ë°˜ ë™ì )
            # ========================================
            if cur_gain >= 0.015:
                # 1.5% ì´ìƒ: ê³ ì  ëŒ€ë¹„ ATR*1.0 (ìµœì†Œ 0.8%)
                profit_lock = best * (1.0 - max(0.008, atr_ratio * 1.0))
            elif cur_gain >= 0.010:
                # 1.0% ì´ìƒ: ê³ ì  ëŒ€ë¹„ ATR*0.8 (ìµœì†Œ 0.6%)
                profit_lock = best * (1.0 - max(0.006, atr_ratio * 0.8))
            else:
                profit_lock = base_stop

            if curp <= profit_lock and cur_gain > 0:
                sell_market(m, entry_volume)
                tg_send_mid(f"ğŸ’ {m} ì´ìµë½ ë°œë™ ({fmt6(profit_lock)}ì›) â†’ ì „ëŸ‰ì²­ì‚°")
                verdict = "PROFIT_LOCK"
                break

            # ========================================
            # ìš°ì„ ìˆœìœ„ 7: íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ATR ê¸°ë°˜ ë™ì )
            # ========================================
            if trail_armed and curp > best:
                # ATR ê¸°ë°˜ ë™ì  íŠ¸ë ˆì¼ ê±°ë¦¬ (ìµœì†Œ 1.0%)
                trail_dist = max(0.010, atr_ratio * 1.25)
                trail_stop = max(trail_stop, curp * (1.0 - trail_dist))

            if trail_armed and curp <= trail_stop:
                sell_market(m, entry_volume)
                tg_send_mid(f"ğŸ“‰ {m} íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ({fmt6(trail_stop)}) í„°ì¹˜ â†’ ì „ëŸ‰ì²­ì‚°")
                verdict = "TRAIL_EXIT"
                break

            # ========================================
            # ì¶”ê°€: ì¬ì§„ì… ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
            # ========================================
            if drop_from_high >= 0.008 and uptick_streak_from_ticks(ticks, need=3):
                tg_send_mid(f"ğŸ”„ {m} ëˆŒë¦¼ í›„ ì¬ìƒìŠ¹ ê°ì§€ â†’ ì¬ì§„ì…")
                open_auto_position(m, pre, base_stop, eff_sl_pct)

        # ========================================
        # ì‹œê°„ ë§Œë£Œ ì‹œ ë§¤ë„ ì•ˆì „ì¥ì¹˜ (ë§¤ë„ ë¯¸ì‹¤í–‰ ë°©ì§€)
        # ========================================
        if verdict is None:
            # ìˆ˜ì •: 0.3% â†’ -0.25% (ì†ì‹¤ì¼ ë•Œë§Œ ê°•ì œì²­ì‚°, ìˆ˜ìµì€ ìœ ì§€)
            if cur_gain <= -0.0025:  # ì§„ì§œ ì†ì‹¤ì¼ ë•Œë§Œ â†’ ì „ëŸ‰ë§¤ë„
                sell_market(m, entry_volume)
                tg_send_mid(f"â±ï¸ {m} ì‹œê°„ë§Œë£Œ + ì†ì‹¤ â†’ ì•ˆì „ì²­ì‚° ({cur_gain*100:.2f}%)")
                verdict = "TIME_EXPIRED_SAFE_EXIT"
            else:
                # ìˆ˜ìµ/ë³¸ì ˆ êµ¬ê°„ì€ ê°•ì œ ì²­ì‚° ì—†ìŒ (ì¬ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ê¸°íšŒ ë³´ì¡´)
                verdict = "ì‹œê°„ ë§Œë£Œ(ìœ ì§€)"

    finally:
        # ================================
        # 1) ìµœì‹  ìƒíƒœ / ìˆ˜ìµë¥  ê³„ì‚°
        # ================================
        ticks = get_recent_ticks(m, 100)
        t15 = micro_tape_stats_from_ticks(ticks, 15) if ticks else {
            "buy_ratio": 0,
            "krw": 0,
            "n": 0,
            "krw_per_sec": 0
        }

        ob = pre.get("ob") or {}
        ob_depth_krw = ob.get("depth_krw", 10_000_000)

        try:
            ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
        except:
            ret_pct = 0.0

        maxrun = (best / entry_price - 1.0) * 100.0
        maxdd = (worst / entry_price - 1.0) * 100.0

        # ================================
        # 2) ëì•ŒëŒ ë¬¸êµ¬ ìƒì„±
        # ================================
        action, rationale = _end_reco(entry_price,
                                      last_price,
                                      c1,
                                      ticks,
                                      ob_depth_krw,
                                      ctx_thr=CTX_EXIT_THRESHOLD)

        # ===========================================
        # ëì•ŒëŒ / ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™”
        #  (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ê³¼ë‹¤ ë°©ì§€)
        # ===========================================
        if not reentry:
            pass  # ëì•ŒëŒ ë¹„í™œì„±í™”
        else:
            pass  # ì¬ëª¨ë‹ˆí„°ë§ ìš”ì•½ ë¹„í™œì„±í™”

        # ===========================================
        # ì¬ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
        #  - ìµœì´ˆ ëª¨ë‹ˆí„°ë§ì—ì„œë§Œ í˜¸ì¶œ
        #  - remonitor_until_close()ì—ì„œ ì¬í˜¸ì¶œëœ ê²½ìš°(reentry=True)ëŠ” ë‹¤ì‹œ ì•ˆ ë“¤ì–´ê°
        # ===========================================
        # âœ… ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™” (ë¶ˆí•„ìš”í•œ ë°˜ë³µ ë©”ì‹œì§€ ë°©ì§€)
        # (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ, ì•Œë¦¼ ë°œì†¡ë§Œ ì°¨ë‹¨)
        if AUTO_TRADE and m in OPEN_POSITIONS and not reentry:
            remonitor_until_close(m, entry_price, pre, tight_mode)

        # ===========================================
        # 3) probe ì†ì ˆ í›„ ë¹ ë¥¸ ì¬ì§„ì… í—ˆìš© ë¡œì§
        # ===========================================
        if AUTO_TRADE and verdict and "ì†ì ˆ" in verdict:
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m)
                if pos and pos.get("entry_mode") == "probe":
                    # probe ì†ì ˆ ì‹œ ì¬ì§„ì… ì¿¨ë‹¤ìš´ ìµœì†Œí™”
                    REMONITOR_QUICK_COOLDOWN_SEC = 120  # 2ë¶„ ì¿¨ë‹¤ìš´
                    REMONITOR_WINDOW_MINUTES = 10       # 10ë¶„ ë‚´ ë™ì¼ ì¢…ëª© ì¬ê¸°íšŒ í—ˆìš©

                    # ìµœê·¼ ì¢…ë£Œ ì‹œê° ê¸°ë¡
                    pos["last_exit_ts"] = time.time()
                    OPEN_POSITIONS[m] = pos

                    # ğŸŒ€ probe ì†ì ˆ ê°ì§€ â†’ ì¬ì§„ì… ëª¨ë“œ (ì•Œë¦¼ ë¹„í™œì„±í™”)

                    # ë¹ ë¥¸ ì¬ëª¨ë‹ˆí„°ë§ ì˜ˆì•½
                    time.sleep(REMONITOR_QUICK_COOLDOWN_SEC)
                    remonitor_until_close(m, entry_price, pre, tight_mode)

        # ğŸ‘‡ ì´ return ì€ if ë°”ê¹¥ì—ì„œ í•­ìƒ ì‹¤í–‰ë˜ê²Œ
        return (
            verdict,
            action,
            rationale,
            ret_pct,
            last_price,
            maxrun,
            maxdd,
        )


# =========================
# ì•Œë¦¼
# =========================
def tg_send(t, retry=1):
    # TG_TOKEN ì—†ê±°ë‚˜ CHAT_IDSê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì½˜ì†”ì—ë§Œ ì¶œë ¥
    if not TG_TOKEN or not CHAT_IDS:
        print(t)
        return True

    ok_any = False
    for cid in CHAT_IDS:
        payload = {
            "chat_id": cid,
            "text": t,
            "parse_mode": "HTML",
            "disable_web_page_preview": True,
        }
        for _ in range(retry + 1):
            try:
                r = SESSION.post(
                    f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                    json=payload,
                    timeout=4,
                )
                if r.status_code == 200:
                    js = r.json()
                    if js.get("ok") is True:
                        ok_any = True
                        break
                else:
                    # ë””ë²„ê¹…ìš©
                    print(f"[TG][{cid}] status={r.status_code} body={r.text}")
            except Exception as e:
                print(f"[TG][{cid}] exception: {e}")
            time.sleep(0.25 + rnd() * 0.25)
    return ok_any


# =========================
# ë©”ì¸ ë£¨í”„ ì¤€ë¹„
# =========================
last_signal_at = {}
recent_alerts = {}
last_price_at_alert = {}
last_reason = {}
ALERT_TTL = 1800

# =========================
# ì‹œê°„ëŒ€ë³„ ì¿¨ë‹¤ìš´ ì„¤ì •
# =========================
def get_cooldown_sec(market: str) -> int:
    """
    ê°™ì€ ì¢…ëª© ì¬ì§„ì… ëŒ€ê¸° ì‹œê°„(ì´ˆ)
    - 09ì‹œëŒ€: 3ë¶„
    - 10~14ì‹œ: 5ë¶„
    - ê·¸ ì™¸: ê¸°ë³¸ COOLDOWN(8ë¶„)
    """
    h = now_kst().hour

    if h == 9:
        return 180  # 3ë¶„
    elif 10 <= h <= 14:
        return 300  # 5ë¶„
    else:
        return COOLDOWN  # ì „ì—­ ê¸°ë³¸ê°’(480)

def cooldown_ok(market, price=None, reason=None):
    now = time.time()
    last = last_signal_at.get(market, 0)

    # âœ… ì‹œê°„ëŒ€ë³„ ë™ì  ì¿¨ë‹¤ìš´ ì ìš©
    cooldown = get_cooldown_sec(market)

    # ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì¡°ê±´
    if (now - last) >= cooldown:
        return True

    # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(ì¬ëŒíŒŒ/ë˜ëŒë¦¼ ì¬ì§„ì… í—ˆìš©)ëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
    if (now - last) >= REARM_MIN_SEC:
        lp = last_price_at_alert.get(market)
        rebreak = (price and lp and (price >= lp * (1.0 + REARM_PRICE_GAP)))
        reason_changed = (last_reason.get(market) != reason)
        rebreak_small = (price and lp
                         and (price >= lp * (1.0 + REARM_REBREAK_MIN))
                         and not reason_changed)
        pullback = (price and lp
                    and (price <= lp * (1.0 - REARM_PULLBACK_MAX)))
        if rebreak or rebreak_small or (pullback and reason_changed):
            return True
    return False

def cleanup_expired(dic, ttl):
    now = time.time()
    drop = [k for k, v in dic.items() if now - v >= ttl]
    for k in drop:
        dic.pop(k, None)


# =========================
# ì„¤ì • ê²€ì¦
# =========================
def validate_config():
    errors = []
    warnings = []
    if TOP_N > 200: errors.append(f"TOP_N={TOP_N} ë„ˆë¬´ í¼ (â‰¤200 ê¶Œì¥)")
    if STOP_LOSS_PCT >= 0.05:
        warnings.append(f"STOP_LOSS_PCT={STOP_LOSS_PCT*100:.1f}% í¼ (<5%)")
    if PARALLEL_WORKERS > 30:
        warnings.append(f"PARALLEL_WORKERS={PARALLEL_WORKERS} ê³¼ë‹¤")
    if MIN_TURNOVER <= 0 or MIN_TURNOVER >= 1:
        errors.append(f"MIN_TURNOVER={MIN_TURNOVER} ë²”ìœ„ ì˜¤ë¥˜ (0~1)")
    if TICKS_BUY_RATIO < 0.5 or TICKS_BUY_RATIO > 1:
        errors.append(f"TICKS_BUY_RATIO={TICKS_BUY_RATIO} ë²”ìœ„ ì˜¤ë¥˜ (0.5~1)")
    if not TG_TOKEN or not CHAT_IDS: warnings.append("í…”ë ˆê·¸ë¨ ë¯¸ì„¤ì • - ì½˜ì†” ì¶œë ¥ë§Œ ì‚¬ìš©")
    if _BUCKET.get("rate", 0) <= 0: warnings.append("í† í°ë²„í‚· rate<=0 â†’ 0.1ë¡œ í´ë¨í”„")
    if _BUCKET.get("cap", 0) <= 0: warnings.append("í† í°ë²„í‚· cap<=0 â†’ 1.0ë¡œ í´ë¨í”„")
    if warnings:
        print("[CONFIG_WARNING]")
        for w in warnings:
            print("  âš ï¸", w)
    if errors:
        print("[CONFIG_ERROR]")
        for e in errors:
            print("  âŒ", e)
        sys.exit(1)
    print("âœ… ì„¤ì • ê²€ì¦ ì™„ë£Œ")


# =========================
# í—¬ìŠ¤ì²´í¬ ì„œë²„(ì˜µì…˜)
# =========================
from http.server import HTTPServer, BaseHTTPRequestHandler

bot_start_time = 0


class HealthHandler(BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        if self.path == "/health":
            status = {
                "status":
                "running",
                "version":
                "3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry",
                "uptime_sec":
                int(time.time() - bot_start_time),
                "uptime_str":
                str(timedelta(seconds=int(time.time() - bot_start_time))),
                "last_scan":
                now_kst_str(),
                "req_stats":
                REQ_STATS,
                "alerts_count":
                len(last_signal_at),
                "cache_size":
                len(_TICKS_CACHE.cache)
                if hasattr(_TICKS_CACHE, 'cache') else 0,
                "config": {
                    "top_n": TOP_N,
                    "scan_interval": SCAN_INTERVAL,
                    "stop_loss_pct": STOP_LOSS_PCT
                }
            }
            self.send_response(200)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(
                json.dumps(status, ensure_ascii=False).encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_health_server(port=8080):
    for p in range(port, port + 5):
        try:
            server = HTTPServer(("0.0.0.0", p), HealthHandler)
            thread = threading.Thread(target=server.serve_forever, daemon=True)
            thread.start()
            print(f"ğŸ¥ Health check server: http://localhost:{p}/health")
            return
        except OSError:
            continue
    print("[HEALTH_ERR] í¬íŠ¸ ì‚¬ìš© ë¶ˆê°€ (8080~8084)")

# ===== ì˜¤ë”ë¶ ìºì‹œ =====
def fetch_orderbook_cache(mkts):
    cache = {}
    for i in range(0, len(mkts), 15):
        js = safe_upbit_get("https://api.upbit.com/v1/orderbook",
            {"markets": ",".join(mkts[i:i + 15])},
            timeout=6)
        if not js: continue
        for ob in js:
            try:
                units = ob["orderbook_units"][:3]
                ask, bid = units[0]["ask_price"], units[0]["bid_price"]
                spread = (ask - bid) / max((ask + bid) / 2, 1) * 100
                askv = sum(u["ask_price"] * u["ask_size"] for u in units)
                bidv = sum(u["bid_price"] * u["bid_size"] for u in units)
                cache[ob["market"]] = {
                    "spread": spread,
                    "depth_krw": askv + bidv,
                    "raw": ob
                }
            except:
                pass
    return cache


# =========================
# ë©”ì¸
# =========================
SHARD_SIZE = TOP_N
_cursor = 0


def main():
    global _cursor
    tg_send(
        f"ğŸš€ ëŒ€ì¥ì´ˆì… í—Œí„° v3.2.7 (Conservative-Balanced) ì‹œì‘ | TOP {TOP_N} | {now_kst_str()}"
    )

    while True:
        try:
            # BTC_guard ì œê±° â€” í•­ìƒ ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰
            tight_mode = False

            for k in list(CUT_COUNTER.keys()):
                CUT_COUNTER[k] = 0

            cleanup_expired(recent_alerts, ALERT_TTL)
            cleanup_expired(last_signal_at, COOLDOWN)
            _TICKS_CACHE.purge_older_than(max_age_sec=2.5)
            _C5_CACHE.purge_older_than(max_age_sec=2.5)

            mkts_all = get_top_krw_by_24h(TOP_N)
            if not mkts_all:
                aligned_sleep(SCAN_INTERVAL)
                continue

            start = _cursor
            end = _cursor + SHARD_SIZE
            shard = mkts_all[start:end]
            if len(shard) < SHARD_SIZE:
                shard += mkts_all[:(SHARD_SIZE - len(shard))]
            _cursor = (end) % len(mkts_all)

            obc = fetch_orderbook_cache(shard)

            c1_cache = {}
            use_workers = min(PARALLEL_WORKERS, len(shard))
            with ThreadPoolExecutor(max_workers=use_workers) as exe:
                futures = {
                    exe.submit(get_minutes_candles, 1, m, 20): m
                    for m in shard
                }
                for f in as_completed(futures):
                    m = futures[f]
                    try:
                        c1_cache[m] = f.result() or []
                    except:
                        c1_cache[m] = []

            found = 0
            for m in shard:
                c1 = c1_cache.get(m, [])
                if not c1: continue

                pre = detect_leader_stock(m, obc, c1, tight_mode=tight_mode)
                if not pre: continue

                # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… ëª¨ë“œ ì¶”ê°€ (probe/confirm ë¶„ë¦¬) ===
                buy_ratio = pre["tape"]["buy_ratio"]
                turn = pre["tape"]["krw"] / max(pre["ob"]["depth_krw"], 1)
                if buy_ratio >= 0.55 and turn >= 0.018:
                    pre["entry_mode"] = "confirm"
                elif buy_ratio >= 0.50 and turn >= 0.015:
                    pre["entry_mode"] = "probe"
                else:
                    continue

                payload = final_check_leader(m, pre, tight_mode=tight_mode)
                if not payload: continue

                # === 6ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ ===
                ok_post, post_reason = postcheck_6s(m, pre)
                if not ok_post:
                    cut("POSTCHECK_DROP", f"{m} postcheck fail: {post_reason}")
                    continue

                if m in recent_alerts and time.time(
                ) - recent_alerts[m] < ALERT_TTL:
                    continue

                reason = "ign" if pre.get("ign_ok") else (
                    "early" if pre.get("early_ok") else
                    ("mega" if pre.get("mega_ok") else "normal"))
                if not cooldown_ok(m, pre['price'], reason=reason):
                    continue

                last_signal_at[m] = time.time()
                recent_alerts[m] = time.time()
                last_price_at_alert[m] = pre['price']
                last_reason[m] = reason

                # ë™ì  ì†ì ˆê°€
                dyn_stop, eff_sl_pct = dynamic_stop_loss(pre['price'], c1)

                txt = (
                    f"âš¡ <b>ì´ˆì… ì‹ í˜¸</b> {m} <code>#{reason}</code>\n"
                    f"ğŸ’µ <b>í˜„ì¬ê°€</b> {fmt6(pre['price'])}ì›\n"
                    f"ğŸ“Š ë“±ë½ {payload['chg']}% | ê±°ë˜ì¦ê°€ {payload['volume_surge']}ë°° | íšŒì „ {payload['turn']}%\n"
                    f"ğŸ”¸ë§¤ìˆ˜ {payload['buy']}% | í‹± {payload['n']} | ìŠ¤í”„ë ˆë“œ {payload['spread']}%\n"
                    f"ğŸ§¯ ì†ì ˆê°€: {fmt6(dyn_stop)} (ë™ì SL {eff_sl_pct*100:.2f}%)\n"
                    f"ğŸ§  ê·¼ê±°: {( 'ì í™”/5mëŒíŒŒ' if pre.get('ign_ok') else ('ì´ˆê¸°ëˆ„ì (TWAP)' if pre.get('botacc_ok') else ('ë©”ê°€ë¸Œë ˆì´í¬ì•„ì›ƒ' if pre.get('mega_ok') else ('ì´ˆê¸°íë¦„(early)' if pre.get('early_ok') else 'íŒ¨í„´ì¢…í•©'))) )}\n"
                    f"{link_for(m)}")

                sent = tg_send(txt, retry=2)

                if sent:
                    found += 1
                    # --- ë¡œê·¸ CSV ê¸°ë¡ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ) ---
                    try:
                        c5 = get_minutes_candles(5, m, 2) or []
                        c15 = get_minutes_candles(15, m, 2) or []
                        chg_1m = (c1[-1]["trade_price"] /
                                  max(c1[-2]["trade_price"], 1) -
                                  1) if len(c1) >= 2 else 0.0
                        chg_5m = (c5[-1]["trade_price"] /
                                  max(c5[-2]["trade_price"], 1) -
                                  1) if len(c5) >= 2 else ""
                        chg_15m = (c15[-1]["trade_price"] /
                                   max(c15[-2]["trade_price"], 1) -
                                   1) if len(c15) >= 2 else ""

                        cbtc1 = get_minutes_candles(1, "KRW-BTC", 2) or []
                        btc1m = (cbtc1[-1]["trade_price"] /
                                 max(cbtc1[-2]["trade_price"], 1) -
                                 1) if len(cbtc1) >= 2 else 0.0
                        cbtc5 = get_minutes_candles(5, "KRW-BTC", 2) or []
                        btc5m = (cbtc5[-1]["trade_price"] /
                                 max(cbtc5[-2]["trade_price"], 1) -
                                 1) if len(cbtc5) >= 2 else 0.0

                        t15_now = micro_tape_stats_from_ticks(pre["ticks"], 15)
                        ob = pre["ob"]
                        flags = {
                            "chg_1m":
                            chg_1m,
                            "chg_5m":
                            chg_5m,
                            "chg_15m":
                            chg_15m,
                            "zscore":
                            zscore_krw_1m(c1, 30),
                            "vwap_gap": (c1[-1]["trade_price"] /
                                         max(vwap_from_candles_1m(c1, 20), 1) -
                                         1) if len(c1) >= 1 else 0.0,
                            "turn":
                            round((t15_now["krw"] / max(ob["depth_krw"], 1)) *
                                  100, 2),
                            "two_green_break":
                            pre.get("two_green_break", False),
                            "ignition_ok":
                            pre.get("ign_ok", False),
                            "early_ok":
                            pre.get("early_ok", False),
                            "uptick_ok":
                            True
                        }
                        row = snapshot_row(m, pre["price"], payload, pre, c1,
                                           ob, t15_now, btc1m, btc5m, flags)
                        append_csv(row)
                    except Exception as e:
                        print("[LOG_ERR]", e)

                    # --- ğŸ”¥ ìë™ë§¤ìˆ˜ ì§„ì… ---
                    try:
                        open_auto_position(m, pre, dyn_stop, eff_sl_pct)
                    except Exception as e:
                        print("[AUTO_OPEN_ERR]", e)

                    # --- í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ì²­ì‚°ê¹Œì§€ ì´ì–´ì§) ---
                    try:
                        monitor_position(m,
                                         pre["price"],
                                         pre,
                                         tight_mode=tight_mode)
                    except Exception as e:
                        print("[MON_ERR]", e)

            cut_summary()
            if found == 0:
                req_summary()
            # ì‹œê°„ëŒ€ë³„ ë™ì  ìŠ¤ìº” ê°„ê²© ì ìš©
            aligned_sleep(get_scan_interval())

        except KeyboardInterrupt:
            print("Stopped by user.")
            break
        except Exception as e:
            print("[MAIN_ERR]", e)
            traceback.print_exc()
            print("[MAIN] 5ì´ˆ í›„ ì¬ì‹œì‘...")
            time.sleep(5)
            continue  # ğŸ’¡ ë‹¤ì‹œ ë£¨í”„ ì‹œì‘

if __name__ == "__main__":
    validate_config()
    bot_start_time = time.time()
    start_health_server()
    main()
