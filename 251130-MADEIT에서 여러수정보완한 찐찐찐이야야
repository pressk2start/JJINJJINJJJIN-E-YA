# -*- coding: utf-8 -*-
import os, time, math, requests, statistics, traceback, threading, csv, sys, json, random
from datetime import datetime, timedelta, timezone
from collections import deque, OrderedDict
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlencode

import uuid
import hashlib
import hmac
import jwt

# ğŸ”§ PyJWT íŒ¨í‚¤ì§€ ê²€ì¦ (ë™ëª…ì´ì¸ íŒ¨í‚¤ì§€ í˜¼ë™ ë°©ì§€)
try:
    _jwt_ver = getattr(jwt, "__version__", "unknown")
    assert hasattr(jwt, "encode") and callable(jwt.encode), "jwt.encode ì—†ìŒ"
    print(f"[JWT] PyJWT v{_jwt_ver} ë¡œë“œë¨")
except Exception as e:
    print(f"[JWT_ERR] PyJWT íŒ¨í‚¤ì§€ ë¬¸ì œ: {e}")
    print("[JWT_ERR] pip install PyJWT ë¡œ ì„¤ì¹˜ í•„ìš”")
    sys.exit(1)


def rnd():
    return random.random()  # â† ì´ ì¤„ì´ 4ì¹¸(ìŠ¤í˜ì´ìŠ¤) ë“¤ì—¬ì“°ê¸° ë˜ì–´ì•¼ í•¨

def fmt6(x):
    """
    ìˆ«ìë¥¼ ë³´ê¸° ì¢‹ê²Œ í‘œì‹œ:
    - ì •ìˆ˜ëŠ” ì†Œìˆ˜ì  ì—†ì´
    - ì†Œìˆ˜ì ì´ ìˆëŠ” ê²½ìš° ìµœëŒ€ 6ìë¦¬ê¹Œì§€ í‘œì‹œ
    """
    if isinstance(x, (int, float)):
        if abs(x - int(x)) < 1e-6:
            return f"{int(x):,}"
        else:
            s = f"{x:,.6f}".rstrip('0').rstrip('.')
            return s
    return str(x)

# =========================
# ì„¤ì • (24ì‹œê°„ ë‹¨íƒ€ ìµœì í™” + Bot-aware, 3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry)
# =========================
TOP_N = 60
SCAN_INTERVAL = 6
COOLDOWN = 480
PARALLEL_WORKERS = 12

# ==== Exit Control (anti-whipsaw) ====
WARMUP_SEC = 5  # ì§„ì… í›„ 5ì´ˆ ì›œì—…
WARMUP_STOP = -0.002  # ğŸ”§ ì›œì—… ì¤‘ -0.2% ì†ì ˆ
HARD_STOP_DD = 0.015  # -1.5% ê¸‰ë½ ì‹œ ì¦‰ì‹œ ì»· (strict ê¸°ì¤€)
EXIT_DEBOUNCE_SEC = 8  # ì²­ì‚° ì‹ í˜¸ ì§€ì† í™•ì¸ ì‹œê°„
EXIT_DEBOUNCE_N = 4  # ì—°ì† NíšŒ ì¡°ê±´ ì¶©ì¡± í•„ìš”

# ğŸ”§ í†µí•© ì²´í¬í¬ì¸íŠ¸: íŠ¸ë ˆì¼ë§/ì–‡ì€ìˆ˜ìµ/Plateau ë°œë™ ê¸°ì¤€
PROFIT_CHECKPOINT = 0.0025  # +0.25% (ì´ ê°’ í•˜ë‚˜ë§Œ ë°”ê¾¸ë©´ ì „ì²´ ì ìš©)

# ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¡œì§ (ì§„ì… í›„ ì¼ì •ì‹œê°„ íš¡ë³´ ì‹œ ë¯¸ë‹ˆíŠ¸ë ˆì¼ë§ìœ¼ë¡œ íƒˆì¶œ)
SIDEWAYS_TIMEOUT = 60       # íš¡ë³´ íŒì • ì‹œê°„ (ì´ˆ) - ì´í›„ ê³ ì  ì¶”ì  ì‹œì‘

# íŠ¸ë ˆì¼ë§ ì†ì ˆ ì„¤ì •
TRAIL_ATR_MULT = 0.8  # ATR ê¸°ë°˜ ì—¬ìœ í­ (íƒ€ì´íŠ¸)
TRAIL_DISTANCE_MIN = 0.002  # ê¸°ë³¸ íŠ¸ë ˆì¼ ê°„ê²© (fallbackìš©)

# ğŸ”§ ë‹¨ê³„ë³„ íƒ€ì´íŠ¸ íŠ¸ë ˆì¼ë§ (ì‹¤ì „ë¶„ì„: +0.11% avg vs 0.2% ê³ ì • +0.02%)
# (gain_threshold, trail_pct) - ìˆ˜ìµë¥  êµ¬ê°„ë³„ íŠ¸ë ˆì¼ ê°„ê²©
TRAIL_TIERS = [
    (0.007, 0.002),   # 0.7%+ ìˆ˜ìµ ì‹œ 0.2% íŠ¸ë ˆì¼
    (0.004, 0.0015),  # 0.4%+ ìˆ˜ìµ ì‹œ 0.15% íŠ¸ë ˆì¼
    (0.002, 0.001),   # 0.2%+ ìˆ˜ìµ ì‹œ 0.1% íŠ¸ë ˆì¼
    (0.0, 0.0005),    # ê¸°ë³¸ 0.05% íŠ¸ë ˆì¼
]

def get_tiered_trail_dist(gain_pct: float) -> float:
    """ìˆ˜ìµë¥ ì— ë”°ë¥¸ ë‹¨ê³„ë³„ íŠ¸ë ˆì¼ ê°„ê²© ë°˜í™˜"""
    for threshold, trail in TRAIL_TIERS:
        if gain_pct >= threshold:
            return trail
    return TRAIL_DISTANCE_MIN

# === ìˆ˜ìˆ˜ë£Œ ì„¤ì • (ì™•ë³µ 0.1% ë°˜ì˜) ===
FEE_RATE = 0.001  # 0.05% ë§¤ìˆ˜ + 0.05% ë§¤ë„

# === í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ ì „ì—­ ì„¤ì • (âœ… ì¤‘ë³µ ì œê±°, ì¼ì›í™”) ===
USE_5M_CONTEXT = True         # 5ë¶„ ì»¨í…ìŠ¤íŠ¸ í™œì„±í™”
POSTCHECK_ENABLED = False     # ì´ˆì… ë‹¨ê³„ í¬ìŠ¤íŠ¸ì²´í¬ ë¹„í™œì„±í™”
EARLY_FLOW_MIN_KRWPSEC = 24_000  # ì´ˆê¸° ê±°ë˜ì†ë„ (22k~26k ì ˆì¶©)

# --- í™˜ê²½ë³€ìˆ˜(.env ì§€ì›) ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

# ==== Exit Profile (gentle/ balanced / strict) ====
EXIT_PROFILE = os.getenv("EXIT_PROFILE", "strict").lower()


def _apply_exit_profile():
    """
    í”„ë¡œíŒŒì¼ë³„ ì²­ì‚° ë¯¼ê°ë„ ì„¸íŒ…
    - gentle  : ëŠìŠ¨(íœ©ì˜ ë‚´ì„±â†‘, ìˆ˜ìµ ìµœëŒ€í™” ì§€í–¥)
    - balanced: ê¸°ë³¸ê°’(í˜„ì¬ ë„¤ ì„¸íŒ… ê¸°ì¤€)
    - strict  : ì—„ê²©(ë³´ìˆ˜ì , ì†ì‹¤ì¶•ì†Œ ì§€í–¥)
    """
    global WARMUP_SEC, HARD_STOP_DD, EXIT_DEBOUNCE_SEC, EXIT_DEBOUNCE_N
    global TRAIL_ATR_MULT, TRAIL_DISTANCE_MIN
    global SPIKE_RECOVERY_WINDOW, SPIKE_RECOVERY_MIN_BUY
    global CTX_EXIT_THRESHOLD

    prof = EXIT_PROFILE

    if prof == "gentle":
        WARMUP_SEC = 14
        HARD_STOP_DD = 0.024
        EXIT_DEBOUNCE_SEC = 10
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 1.0
        TRAIL_DISTANCE_MIN = 0.0025  # 0.25% ê°„ê²©
        SPIKE_RECOVERY_WINDOW = 4
        SPIKE_RECOVERY_MIN_BUY = 0.56
        CTX_EXIT_THRESHOLD = 4

    elif prof == "strict":
        WARMUP_SEC = 3  # ë” ë¹ ë¥¸ ë°˜ì‘
        HARD_STOP_DD = 0.012  # -1.2% ì†ì ˆ
        EXIT_DEBOUNCE_SEC = 4
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 0.7
        TRAIL_DISTANCE_MIN = 0.0015  # 0.15% ê°„ê²© (ê°€ì¥ íƒ€ì´íŠ¸)
        SPIKE_RECOVERY_WINDOW = 2
        SPIKE_RECOVERY_MIN_BUY = 0.65
        CTX_EXIT_THRESHOLD = 2  # ì»¨í…ìŠ¤íŠ¸ ì—­ì „ ë” ë¯¼ê°

    else:  # balanced (í˜„ì¬ ê°’ì— ê·¼ì ‘)
        WARMUP_SEC = 12
        HARD_STOP_DD = 0.022
        EXIT_DEBOUNCE_SEC = 8
        EXIT_DEBOUNCE_N = 2
        TRAIL_ATR_MULT = 0.8
        TRAIL_DISTANCE_MIN = 0.002  # 0.2% ê°„ê²©
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.58
        CTX_EXIT_THRESHOLD = 3


_apply_exit_profile()

TG_TOKEN = os.getenv("TELEGRAM_TOKEN") or os.getenv("TG_TOKEN") or ""

# ğŸ“Œ ì—¬ëŸ¬ ëª…ì—ê²Œ ë³´ë‚´ê¸°ìš© chat_id ëª©ë¡
_raw_chats = (
    os.getenv("TG_CHATS")  # ìƒˆë¡œ ì“¸ ì¶”ì²œ í‚¤: "id1,id2,-100xxx"
    or os.getenv("TELEGRAM_CHAT_ID")  # ì˜ˆì „ ë‹¨ì¼ í‚¤ë„ í˜¸í™˜
    or os.getenv("TG_CHAT") or "")

CHAT_IDS = []
for part in _raw_chats.split(","):
    part = part.strip()
    if not part:
        continue
    try:
        CHAT_IDS.append(int(part))
    except Exception:
        print(f"[WARN] ì˜ëª»ëœ chat_id ê°’ ë¬´ì‹œë¨: {part}")

print("[DEBUG] CHAT_IDS =", CHAT_IDS)  # ì‹¤í–‰ ì‹œ í•œ ë²ˆ ì°í˜€ì„œ í™•ì¸ìš©

# =========================
# ğŸ”¥ ì í™” ê°ì§€ (Ignition Detection) ì „ì—­ ë³€ìˆ˜
# =========================
_IGNITION_LAST_SIGNAL = {}  # {market: timestamp_ms} ë§ˆì§€ë§‰ ì í™” ì‹ í˜¸ ì‹œê°
_IGNITION_BASELINE_TPS = {}  # {market: tps} ì¢…ëª©ë³„ í‰ì‹œ í‹±/ì´ˆ
_IGNITION_LOCK = threading.Lock()

# =========================
# ğŸ” í”„ë¡œì„¸ìŠ¤ ê°„ ì¤‘ë³µ ì§„ì… ë°©ì§€ (íŒŒì¼ë½ + ë©”ëª¨ë¦¬ë½)
# =========================
_MEMORY_ENTRY_LOCKS = {}  # ë©”ëª¨ë¦¬ ê¸°ë°˜ ë½ (ìŠ¤ë ˆë“œ ê°„)
_MEMORY_LOCK = threading.Lock()  # ë©”ëª¨ë¦¬ ë½ ë³´í˜¸ìš©

def _entry_lock_path(market: str) -> str:
    return f"/tmp/bot_entry_{market.replace('-', '_')}.lock"

def _try_acquire_entry_lock(market: str, ttl_sec: int = 60, reentrant: bool = False) -> bool:
    """ë½ íšë“ ì‹œë„. ì„±ê³µí•˜ë©´ True, ì´ë¯¸ ë½ ìˆìœ¼ë©´ False

    ğŸ”§ FIX: ì›ìì  íŒŒì¼ ìƒì„± (O_CREAT | O_EXCL) + ë©”ëª¨ë¦¬ ë½ ì´ì¤‘ ë³´í˜¸
    ğŸ”§ reentrant=True: ì´ë¯¸ ë½ì„ ê°€ì§€ê³  ìˆìœ¼ë©´ True ë°˜í™˜ (ì¬ì§„ì… í—ˆìš©)
    """
    # 1ï¸âƒ£ ë©”ëª¨ë¦¬ ë½ ë¨¼ì € ì²´í¬ (ê°™ì€ í”„ë¡œì„¸ìŠ¤ ë‚´ ìŠ¤ë ˆë“œ ê°„)
    with _MEMORY_LOCK:
        if market in _MEMORY_ENTRY_LOCKS:
            if time.time() - _MEMORY_ENTRY_LOCKS[market] < ttl_sec:
                # ğŸ”§ FIX: reentrant ëª¨ë“œë©´ ì´ë¯¸ ë½ì„ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ True ë°˜í™˜
                if reentrant:
                    return True
                return False
        _MEMORY_ENTRY_LOCKS[market] = time.time()

    # 2ï¸âƒ£ íŒŒì¼ ë½ (í”„ë¡œì„¸ìŠ¤ ê°„)
    path = _entry_lock_path(market)
    try:
        # ê¸°ì¡´ ë½ íŒŒì¼ì´ ìˆìœ¼ë©´ TTL ì²´í¬
        if os.path.exists(path):
            if (time.time() - os.path.getmtime(path)) < ttl_sec:
                # ë©”ëª¨ë¦¬ ë½ ë¡¤ë°±
                with _MEMORY_LOCK:
                    _MEMORY_ENTRY_LOCKS.pop(market, None)
                return False
            # TTL ë§Œë£Œëœ ë½ íŒŒì¼ ì œê±°
            try:
                os.remove(path)
            except Exception:
                pass

        # ì›ìì  íŒŒì¼ ìƒì„± ì‹œë„ (O_CREAT | O_EXCL = ì´ë¯¸ ì¡´ì¬í•˜ë©´ ì‹¤íŒ¨)
        fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
        os.write(fd, str(time.time()).encode())
        os.close(fd)
        return True
    except FileExistsError:
        # ë‹¤ë¥¸ ìŠ¤ë ˆë“œ/í”„ë¡œì„¸ìŠ¤ê°€ ë¨¼ì € ìƒì„±í•¨
        with _MEMORY_LOCK:
            _MEMORY_ENTRY_LOCKS.pop(market, None)
        return False
    except Exception:
        with _MEMORY_LOCK:
            _MEMORY_ENTRY_LOCKS.pop(market, None)
        return False

def _release_entry_lock(market: str):
    """ë½ í•´ì œ (íŒŒì¼ ì‚­ì œ + ë©”ëª¨ë¦¬ ë½ í•´ì œ)"""
    # ë©”ëª¨ë¦¬ ë½ í•´ì œ
    with _MEMORY_LOCK:
        _MEMORY_ENTRY_LOCKS.pop(market, None)

    # íŒŒì¼ ë½ í•´ì œ
    path = _entry_lock_path(market)
    try:
        if os.path.exists(path):
            os.remove(path)
    except Exception:
        pass


def cleanup_stale_entry_locks(max_age_sec=300):
    """ì˜¤ë˜ëœ ì—”íŠ¸ë¦¬ ë½íŒŒì¼ ì •ë¦¬ (ê¸°ë³¸ 5ë¶„)"""
    try:
        nowt = time.time()
        cleaned = 0
        for name in os.listdir("/tmp"):
            if not name.startswith("bot_entry_"):
                continue
            path = f"/tmp/{name}"
            try:
                if nowt - os.path.getmtime(path) > max_age_sec:
                    os.remove(path)
                    cleaned += 1
            except Exception:
                pass
        if cleaned > 0:
            print(f"[LOCK_CLEAN] {cleaned}ê°œ ì˜¤ë˜ëœ ë½íŒŒì¼ ì •ë¦¬ë¨")
    except Exception as e:
        print(f"[LOCK_CLEAN_ERR] {e}")


from contextlib import contextmanager

@contextmanager
def entry_lock(market: str, ttl_sec: int = 60, reentrant: bool = False):
    """ì—”íŠ¸ë¦¬ ë½ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € - ì•ˆì „í•œ ë½ íšë“/í•´ì œ

    ğŸ”§ reentrant=True: ì¬ì§„ì… ëª¨ë“œ (ì´ë¯¸ ë½ì„ ê°€ì§€ê³  ìˆìœ¼ë©´ True, í•´ì œ ì•ˆ í•¨)
    """
    got = _try_acquire_entry_lock(market, ttl_sec=ttl_sec, reentrant=reentrant)
    try:
        yield got
    finally:
        # ğŸ”§ FIX: reentrant ëª¨ë“œì—ì„œëŠ” ë½ í•´ì œ ì•ˆ í•¨ (ì›ë˜ íšë“í•œ ê³³ì—ì„œ í•´ì œ)
        if got and not reentrant:
            _release_entry_lock(market)


def get_available_krw(accounts) -> float:
    """KRW ê°€ìš©ì”ê³  ê³„ì‚° (locked ë°˜ì˜)"""
    for a in accounts:
        if a.get("currency") == "KRW":
            bal = float(a.get("balance", "0") or 0)
            locked = float(a.get("locked", "0") or 0)
            return max(0.0, bal - locked)
    return 0.0


# =========================
# ğŸ”¥ ì—…ë¹„íŠ¸ Private API (ì£¼ë¬¸/ì”ê³ /í¬ì§€ì…˜ ê´€ë¦¬)
# =========================
# import uuid, hashlib, jwt  # ìƒë‹¨(8-11ì¤„)ì—ì„œ ì´ë¯¸ importë¨
# from urllib.parse import urlencode  # ìƒë‹¨(6ì¤„)ì—ì„œ ì´ë¯¸ importë¨

UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY", "")
UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY", "")

# ğŸ”§ ë³´ì•ˆ: í‚¤ ê¸¸ì´ ë¡œê¹…ì€ ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ
if os.getenv("DEBUG_KEYS") == "1":
    print(
        "[UPBIT_KEYS] access_len=",
        len(UPBIT_ACCESS_KEY),
        "secret_len=",
        len(UPBIT_SECRET_KEY),
    )

# AUTO_TRADE = 1 ì´ë©´ ì‹¤ì œ ì£¼ë¬¸, 0ì´ë©´ ì•Œë¦¼ + ëª¨ë‹ˆí„°ë§ë§Œ
AUTO_TRADE = os.getenv("AUTO_TRADE", "0") == "1"
RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.003"))  # ê³„ì¢Œì˜ 0.3% ë¦¬ìŠ¤í¬

print(f"[BOT_MODE] AUTO_TRADE={AUTO_TRADE}, RISK_PER_TRADE={RISK_PER_TRADE}")

# === ê³µê²© ëª¨ë“œ / í”¼ë¼ë¯¸ë”© ì„¤ì • ===
AGGRESSIVE_MODE = os.getenv("AGGRESSIVE_MODE", "1") == "1"

# ì†Œì•¡ ì„ ì§„ì… + ì¶”ë§¤ êµ¬ì¡° (ì†Œì•¡ í”„ë¡œë¸Œê°€ ë” ì•ˆì •ì )
USE_PYRAMIDING = os.getenv("USE_PYRAMIDING", "1") == "1"

# RISK_PER_TRADEë¥¼ ìª¼ê°œì„œ ì‚¬ìš© (seed + add)
# ì˜ˆ: RISK_PER_TRADE=0.003, SEED=0.55, ADD=0.55 ë©´ ëŒ€ëµ 1.1ë°° ì •ë„ ë¦¬ìŠ¤í¬ ì‚¬ìš©
SEED_RISK_FRACTION = float(os.getenv("SEED_RISK_FRACTION", "0.55"))
ADD_RISK_FRACTION = float(os.getenv("ADD_RISK_FRACTION", "0.55"))

# ì¶”ë§¤ íŠ¸ë¦¬ê±° ì¡°ê±´
PYRAMID_ADD_MIN_GAIN = float(os.getenv("PYRAMID_ADD_MIN_GAIN", "0.008"))  # +0.8% ì´ìƒì—ì„œ ì¶”ë§¤
PYRAMID_ADD_FLOW_MIN_BUY = float(os.getenv("PYRAMID_ADD_FLOW_MIN_BUY", "0.60"))  # ë§¤ìˆ˜ë¹„
PYRAMID_ADD_FLOW_MIN_KRWPSEC = float(os.getenv("PYRAMID_ADD_FLOW_MIN_KRWPSEC", "35000"))  # KRW/s
PYRAMID_ADD_COOLDOWN_SEC = int(os.getenv("PYRAMID_ADD_COOLDOWN_SEC", "12"))  # ì¶”ë§¤ ê°„ ìµœì†Œ ê°„ê²©(ì´ˆ)


# í˜„ì¬ ì—´ë¦° í¬ì§€ì…˜ ê¸°ë¡ìš©
# ì˜ˆ: { "KRW-BTC": {"entry_price":..., "volume":..., "stop":..., "sl_pct":..., "state":"open"} }
OPEN_POSITIONS = {}
_POSITION_LOCK = threading.Lock()  # í¬ì§€ì…˜ ì ‘ê·¼ ë½
MAX_POSITIONS = int(os.getenv("MAX_POSITIONS", "5"))  # ğŸ”§ ìµœëŒ€ ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ (ì´ ë…¸ì¶œ í•œë„)

# ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™”
_LAST_ORPHAN_SYNC = 0
ORPHAN_SYNC_INTERVAL = 30  # 30ì´ˆë§ˆë‹¤ ì²´í¬
_ORPHAN_HANDLED = set()    # ì´ë¯¸ ì²˜ë¦¬í•œ ìœ ë ¹ í¬ì§€ì…˜ (ì„¸ì…˜ ë‚´ ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€)
_PREV_SYNC_MARKETS = set() # ì´ì „ ë™ê¸°í™”ì—ì„œ ë°œê²¬ëœ ë§ˆì¼“ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)

# ğŸ”§ ì²­ì‚° ì‹¤íŒ¨ ì¬ì‹œë„ìš©
_PENDING_CLOSE = {}  # {market: {"reason": str, "ts": float, "retry_count": int}}
_PENDING_CLOSE_LOCK = threading.Lock()
PENDING_CLOSE_RETRY_INTERVAL = 30  # 30ì´ˆë§ˆë‹¤ ì¬ì‹œë„
PENDING_CLOSE_MAX_RETRY = 5  # ìµœëŒ€ 5íšŒ ì¬ì‹œë„

# ğŸ”” ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ì¿¨íƒ€ì„ (ë¹„ë§¤ë§¤ ì•Œë¦¼ìš©)
REMONITOR_COOLDOWN_SEC = 300  # 5ë¶„
REMONITOR_LAST_ALERT = {}

# =========================
# ğŸ“ˆ ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹
# =========================
from collections import deque as _deque_for_risk  # ê¸°ì¡´ dequeì™€ ë³„ë„ alias

TRADE_HISTORY = _deque_for_risk(maxlen=30)  # ìµœê·¼ 30ê°œ ê±°ë˜ ê¸°ë¡

# ğŸ”§ í¬ë¦¬í‹°ì»¬ í•«í”½ìŠ¤: streak ì „ì—­ë³€ìˆ˜ ìƒë‹¨ ì„ ì–¸ (NameError ë°©ì§€)
_lose_streak = 0              # ì—°ì† íŒ¨ë°° ìˆ˜
_win_streak = 0               # ì—°ì† ìŠ¹ë¦¬ ìˆ˜


def record_trade(market: str, pnl_pct: float):
    """
    ê±°ë˜ ê²°ê³¼ ê¸°ë¡
    - pnl_pct: % ë‹¨ìœ„ ìˆ˜ìµë¥  (ì˜ˆ: +2.3, -1.5)
    """
    TRADE_HISTORY.append({
        "market": market,
        "pnl": pnl_pct,
        "win": pnl_pct > 0,
        "time": time.time(),
    })


def get_adaptive_risk() -> float:
    """
    ìµœê·¼ ìŠ¹ë¥  + streak ê¸°ë°˜ RISK_PER_TRADE ê°€ë³€ ì¡°ì •
    - íˆìŠ¤í† ë¦¬ 10ê±´ ë¯¸ë§Œ: ê¸°ë³¸ê°’ (streakë§Œ ì ìš©)
    - winrate < 30% : ë¦¬ìŠ¤í¬ 0.5ë°°
    - winrate >= 50%: ë¦¬ìŠ¤í¬ 1.2ë°°
    - ğŸ”§ ì—°íŒ¨ 3íšŒ ì´ìƒ: ë¦¬ìŠ¤í¬ 0.85ë°° (ë°©ì–´ì )
    - ğŸ”§ ì—°ìŠ¹ 3íšŒ ì´ìƒ: ë¦¬ìŠ¤í¬ 1.15ë°° (ê³µê²©ì )
    """
    global _lose_streak, _win_streak  # ğŸ”§ ì „ì—­ ì°¸ì¡° ëª…ì‹œ
    base_risk = RISK_PER_TRADE

    # ìŠ¹ë¥  ê¸°ë°˜ ì¡°ì •
    if len(TRADE_HISTORY) >= 10:
        wins = sum(1 for t in TRADE_HISTORY if t.get("win"))
        win_rate = wins / len(TRADE_HISTORY)

        if win_rate < 0.30:
            base_risk = RISK_PER_TRADE * 0.5
        elif win_rate >= 0.50:
            base_risk = RISK_PER_TRADE * 1.2

    # ğŸ”§ FIX: streak ê¸°ë°˜ ì¶”ê°€ ì¡°ì • (ì—°íŒ¨ ì‹œ ì¤„ì´ê³ , ì—°ìŠ¹ ì‹œ ëŠ˜ë¦¼)
    if _lose_streak >= 3:
        base_risk *= 0.85  # ì—°íŒ¨ 3íšŒ â†’ ë¦¬ìŠ¤í¬ 15% ê°ì†Œ
    elif _win_streak >= 3:
        base_risk *= 1.15  # ì—°ìŠ¹ 3íšŒ â†’ ë¦¬ìŠ¤í¬ 15% ì¦ê°€

    return base_risk

def _clean_params(d: dict):
    """None/ë¹ˆê°’ë§Œ ì œê±° (ì›ë³¸ í‚¤ ìˆœì„œ ìœ ì§€)"""
    return {k: v for k, v in (d or {}).items() if v is not None and v != ""}

def _make_auth_headers(query: dict = None):
    payload = {
        'access_key': UPBIT_ACCESS_KEY,
        'nonce': str(uuid.uuid4()),
    }
    if query:
        q = urlencode(query).encode()
        m = hashlib.sha512()
        m.update(q)
        payload['query_hash'] = m.hexdigest()
        payload['query_hash_alg'] = 'SHA512'
    # ğŸ”§ FIX: ì•Œê³ ë¦¬ì¦˜ ì§€ì • + PyJWT v1/v2 í˜¸í™˜ ë””ì½”ë”©
    jwt_token = jwt.encode(payload, UPBIT_SECRET_KEY, algorithm="HS256")
    if isinstance(jwt_token, bytes):  # PyJWT v1 ëŒ€ë¹„
        jwt_token = jwt_token.decode("utf-8")
    return {"Authorization": f"Bearer {jwt_token}"}


def upbit_private_get(path, params=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    headers = _make_auth_headers(params or {})
    _throttle()
    r = SESSION.get(url, headers=headers, params=params, timeout=timeout)
    r.raise_for_status()
    return r.json()


def upbit_private_post(path, body=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    body = body or {}
    headers = _make_auth_headers(body)
    _throttle()
    r = SESSION.post(url, headers=headers, json=body, timeout=timeout)
    r.raise_for_status()
    return r.json()


def get_order_result(uuid_str, timeout_sec=10.0):
    """
    ì£¼ë¬¸ uuid ë¡œ ìµœì¢… ì²´ê²° ê²°ê³¼ ì¡°íšŒ
    - done / cancel ìƒíƒœê°€ ë˜ê±°ë‚˜ timeout ë  ë•Œê¹Œì§€ polling
    ğŸ”§ FIX: waitì—ì„œ ì¢…ë£Œí•˜ë©´ ì²´ê²° ì „ì— ëŠê¹€ â†’ done/cancelë§Œ ì¢…ë£Œ
    """
    deadline = time.time() + timeout_sec
    last = None
    while time.time() < deadline:
        try:
            od = upbit_private_get("/v1/order", {"uuid": uuid_str})
            last = od
            state = od.get("state")
            # ğŸ”§ FIX: done/cancelì—ì„œë§Œ ì¢…ë£Œ, waitëŠ” ê³„ì† ëŒ€ê¸°
            if state in ("done", "cancel"):
                break
        except Exception as e:
            last = None
        time.sleep(0.25)
    return last


def get_account_info():
    """ì—…ë¹„íŠ¸ ê³„ì¢Œ(ì”ê³ ) ì¡°íšŒ"""
    try:
        return upbit_private_get("/v1/accounts")
    except Exception as e:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨:", e)
        return []


def calc_position_size(entry_price, stop_price, total_equity, risk_pct):
    """
    ì†ì ˆê°€ ê¸°ì¤€ìœ¼ë¡œ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    - total_equity * risk_pct ë§Œí¼ë§Œ ìµœëŒ€ ì†ì‹¤ í—ˆìš©
    """
    # ğŸ”§ CRITICAL: ë¹„ì •ìƒ entry_price ê°€ë“œ (ë¶„ëª¨ 0 ë°©ì§€)
    if entry_price is None or entry_price <= 0:
        return 0.0

    risk_krw = total_equity * risk_pct
    # ğŸ”§ FIX: DYN_SL_MINê³¼ ë™ê¸°í™” (ê³¼ìœ„í—˜ ë°©ì§€)
    min_sl_pct = DYN_SL_MIN  # ì „ì—­ ì†ì ˆí­ê³¼ ì¼ì¹˜

    # ğŸ”§ FIX: stop_priceê°€ Noneì´ê±°ë‚˜ entry_price ì´ìƒì´ë©´ ë³´ì •
    if stop_price is None or stop_price <= 0 or stop_price >= entry_price:
        stop_price = entry_price * (1 - min_sl_pct)

    per_unit_loss = max(entry_price - stop_price,
                        entry_price * min_sl_pct)

    # ğŸ”§ CRITICAL: ë¶„ëª¨ ì•ˆì „ ê°€ë“œ
    if per_unit_loss <= 0:
        return 0.0

    qty = risk_krw / per_unit_loss
    return max(qty, 0.0)


def place_market_buy(market, krw_amount):
    """KRW ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ìˆ˜ (ord_type=price)"""
    krw_amount = int(krw_amount)
    # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ê°€ë“œ (400 ì—ëŸ¬ ë°©ì§€)
    if krw_amount < 5000:
        print(f"[BUY_ERR] {market} ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë‹¬: {krw_amount}ì› < 5000ì›")
        return None
    body = {
        "market": market,
        "side": "bid",
        "ord_type": "price",
        "price": str(krw_amount)
    }
    return upbit_private_post("/v1/orders", body)


def place_market_sell(market, volume, price_hint=None):
    """
    ìˆ˜ëŸ‰ ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ë„
    ğŸ”§ FIX: ìˆ˜ëŸ‰ ì •ë°€ë„ ë³´ì • + ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ í•­ìƒ ì²´í¬
    """
    # ìˆ˜ëŸ‰ ì •ë°€ë„ ë³´ì • (8ìë¦¬ê¹Œì§€, ì—…ë¹„íŠ¸ í‘œì¤€)
    volume = round(float(volume), 8)

    # ğŸ”§ FIX: price_hint ì—†ìœ¼ë©´ í˜„ì¬ê°€ ì¡°íšŒ (ìµœì†Œê¸ˆì•¡ ì²´í¬ ìš°íšŒ ë°©ì§€)
    if price_hint is None:
        try:
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
            price_hint = cur_js[0].get("trade_price", 0) if cur_js else 0
        except Exception:
            price_hint = 0

    # ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ (5,000ì›)
    if price_hint and price_hint > 0:
        est_value = volume * price_hint
        if est_value < 5000:
            raise ValueError(f"ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë‹¬: {est_value:.0f}ì› < 5000ì›")

    body = {
        "market": market,
        "side": "ask",
        "ord_type": "market",
        "volume": f"{volume:.8f}"  # ì†Œìˆ˜ì  8ìë¦¬ ê³ ì •
    }
    return upbit_private_post("/v1/orders", body)

def get_actual_balance(market):
    """ì‹¤ì œ ë³´ìœ ëŸ‰ ì¡°íšŒ (ì°Œêº¼ê¸° ë°©ì§€ìš©)"""
    try:
        currency = market.replace("KRW-", "")
        accounts = get_account_info()
        for a in accounts:
            if a.get("currency") == currency:
                return float(a.get("balance", "0"))
        return 0.0
    except:
        return 0.0

def sell_all(market):
    """ì‹¤ì œ ë³´ìœ ëŸ‰ ì „ëŸ‰ ë§¤ë„ (1ì› ì°Œêº¼ê¸° ë°©ì§€)"""
    actual = get_actual_balance(market)
    if actual <= 0:
        print(f"[SELL_ALL] {market} ë³´ìœ ëŸ‰ ì—†ìŒ")
        return None
    # ğŸ”§ í˜„ì¬ê°€ ì¡°íšŒ
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
        cur_price = cur_js[0].get("trade_price", 0) if cur_js else 0
    except Exception:
        cur_price = None
    print(f"[SELL_ALL] {market} ì‹¤ì œ ë³´ìœ ëŸ‰ {actual:.8f} ì „ëŸ‰ ë§¤ë„")
    # ğŸ”§ FIX: ë§¤ë„ ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ ë“±)
    try:
        return place_market_sell(market, actual, price_hint=cur_price)
    except Exception as e:
        print(f"[SELL_ALL_ERR] {market}: {e}")
        # ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œì´ë©´ ì†Œì•¡ ì”ì—¬ë¡œ ê°„ì£¼
        if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
            print(f"[SELL_ALL] {market} ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ì†Œì•¡ ì”ì—¬ ë³´ìœ ")
        return None


def sync_orphan_positions():
    """
    ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™”
    - ì—…ë¹„íŠ¸ì— ì”ê³ ê°€ ìˆì§€ë§Œ OPEN_POSITIONSì— ì—†ëŠ” í¬ì§€ì…˜ ê°ì§€
    - ê°ì§€ëœ í¬ì§€ì…˜ì„ OPEN_POSITIONSì— ì¶”ê°€í•˜ê³  ëª¨ë‹ˆí„°ë§ ì‹œì‘
    - ì„¸ì…˜ ë‚´ 1íšŒë§Œ ì²˜ë¦¬ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€)
    """
    global _LAST_ORPHAN_SYNC, _PREV_SYNC_MARKETS

    now = time.time()
    if now - _LAST_ORPHAN_SYNC < ORPHAN_SYNC_INTERVAL:
        return  # ì•„ì§ ë™ê¸°í™” ì‹œê°„ ì•ˆë¨
    _LAST_ORPHAN_SYNC = now

    try:
        accounts = get_account_info()
        if not accounts:
            print("[ORPHAN_SYNC] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨ ë˜ëŠ” ë¹„ì–´ìˆìŒ")
            return

        # ğŸ”§ í˜„ì¬ ì”ê³  ìˆëŠ” ë§ˆì¼“ ìˆ˜ì§‘ (ì²­ì‚°ëœ ê±´ _ORPHAN_HANDLEDì—ì„œ ì œê±°)
        current_markets = set()

        for acc in accounts:
            currency = acc.get("currency", "")
            if currency == "KRW":
                continue

            balance = float(acc.get("balance", "0"))
            avg_buy_price = float(acc.get("avg_buy_price", "0"))

            # ìµœì†Œ ê¸ˆì•¡ ì´ìƒë§Œ (ì°Œêº¼ê¸° ì œì™¸)
            if balance * avg_buy_price < 5000:
                continue

            market = f"KRW-{currency}"
            current_markets.add(market)

            # ì´ë¯¸ ì²˜ë¦¬í•œ ìœ ë ¹ í¬ì§€ì…˜ì´ë©´ ìŠ¤í‚µ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€)
            if market in _ORPHAN_HANDLED:
                continue

            with _POSITION_LOCK:
                if market in OPEN_POSITIONS:
                    continue  # ì´ë¯¸ ì¶”ì  ì¤‘

            # ğŸ”§ FIX: ì´ì „ ë™ê¸°í™”ì— ì—†ë˜ ë§ˆì¼“ì€ ìŠ¤í‚µ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)
            # ì²˜ìŒ ë°œê²¬ëœ ì”ê³ ëŠ” ì •ìƒ ë§¤ìˆ˜ì¼ ê°€ëŠ¥ì„± â†’ ë‹¤ìŒ ì‚¬ì´í´ê¹Œì§€ ëŒ€ê¸°
            if market not in _PREV_SYNC_MARKETS:
                print(f"[ORPHAN] {market} ì‹ ê·œ ë°œê²¬ â†’ ë‹¤ìŒ ì‚¬ì´í´ê¹Œì§€ ëŒ€ê¸° (ì˜¤íƒ ë°©ì§€)")
                continue

            # ğŸ”¥ ìœ ë ¹ í¬ì§€ì…˜ ë°œê²¬! (2ì‚¬ì´í´ ì—°ì† ì¡´ì¬ + OPEN_POSITIONSì— ì—†ìŒ)
            print(f"[ORPHAN] {market} ìœ ë ¹ í¬ì§€ì…˜ ë°œê²¬! ì”ê³ ={balance:.4f} í‰ë‹¨={avg_buy_price:.2f}")

            # í˜„ì¬ê°€ ì¡°íšŒ
            try:
                cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": market})
                cur_price = cur_js[0].get("trade_price", avg_buy_price) if cur_js else avg_buy_price
            except:
                cur_price = avg_buy_price

            # ìˆ˜ìµë¥  ê³„ì‚°
            pnl_pct = ((cur_price / avg_buy_price) - 1.0) * 100 if avg_buy_price > 0 else 0

            # ğŸ”§ FIX: OPEN_POSITIONSì— ì¶”ê°€ ì „ í•œë²ˆ ë” í™•ì¸ (race condition ë°©ì§€)
            with _POSITION_LOCK:
                if market in OPEN_POSITIONS:
                    # ì´ë¯¸ ë‹¤ë¥¸ ê³³(ë©”ì¸ ë£¨í”„)ì—ì„œ ì¶”ê°€ë¨ â†’ ìŠ¤í‚µ
                    print(f"[ORPHAN] {market} ì´ë¯¸ OPEN_POSITIONSì— ìˆìŒ (race ë°©ì§€) â†’ ìŠ¤í‚µ")
                    continue
                OPEN_POSITIONS[market] = {
                    "state": "open",
                    "entry_price": avg_buy_price,
                    "volume": balance,
                    "entry_mode": "orphan",  # ìœ ë ¹ í¬ì§€ì…˜ í‘œì‹œ
                    "ts": now,
                    "orphan_detected": True,
                }

            # í…”ë ˆê·¸ë¨ ì•Œë¦¼
            tg_send(
                f"ğŸ‘» ìœ ë ¹ í¬ì§€ì…˜ ê°ì§€!\n"
                f"â€¢ {market}\n"
                f"â€¢ í‰ë‹¨: {fmt6(avg_buy_price)}ì›\n"
                f"â€¢ í˜„ì¬ê°€: {fmt6(cur_price)}ì› ({pnl_pct:+.2f}%)\n"
                f"â€¢ ìˆ˜ëŸ‰: {balance:.6f}\n"
                f"â†’ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (ATR ì†ì ˆ ì ìš©)"
            )

            # ğŸ”§ ì²˜ë¦¬ ì™„ë£Œ í‘œì‹œ (ë°˜ë³µ ì•Œë¦¼ ë°©ì§€) - ë¨¼ì € í‘œì‹œ
            _ORPHAN_HANDLED.add(market)

            # ğŸ”§ ì¦‰ì‹œ ì†ì ˆ ì²´í¬ (ì´ë¯¸ ì†ì ˆì„  ì´í•˜ë©´ ë°”ë¡œ ì²­ì‚°)
            # DYN_SL_MAX = 0.6%, í˜„ì¬ ì†ì‹¤ì´ ê·¸ ì´ìƒì´ë©´ ì¦‰ì‹œ ì²­ì‚°
            if pnl_pct <= -0.6:
                print(f"[ORPHAN] {market} ì´ë¯¸ ì†ì ˆì„  ì´í•˜ ({pnl_pct:.2f}%) â†’ ì¦‰ì‹œ ì²­ì‚°")
                try:
                    close_auto_position(market, f"ìœ ë ¹í¬ì§€ì…˜ ì†ì ˆ | ê°ì§€ ì¦‰ì‹œ {pnl_pct:.2f}%")
                except Exception as e:
                    print(f"[ORPHAN_CLOSE_ERR] {market}: {e}")
                    # ğŸ”§ ì²­ì‚° ì‹¤íŒ¨ ì‹œ OPEN_POSITIONSì—ì„œ ì œê±° (ë‹¤ìŒ ë™ê¸°í™”ì—ì„œ ì¬ì‹œë„)
                    with _POSITION_LOCK:
                        OPEN_POSITIONS.pop(market, None)
                    _ORPHAN_HANDLED.discard(market)
            else:
                # ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
                def _orphan_monitor(m, entry_price):
                    try:
                        # ë”ë¯¸ pre ìƒì„±
                        dummy_pre = {
                            "price": entry_price,
                            "ob": {"depth_krw": 10_000_000},
                            "tape": {"buy_ratio": 0.5, "krw": 0, "n": 0, "krw_per_sec": 0},
                        }
                        remonitor_until_close(m, entry_price, dummy_pre, tight_mode=False)
                    except Exception as e:
                        print(f"[ORPHAN_ERR] {m} ëª¨ë‹ˆí„°ë§ ì—ëŸ¬: {e}")
                        # ğŸ”§ ëª¨ë‹ˆí„°ë§ ì‹¤íŒ¨ ì‹œ ì •ë¦¬ (ë‹¤ìŒ ë™ê¸°í™”ì—ì„œ ì¬ì‹œë„)
                        with _POSITION_LOCK:
                            OPEN_POSITIONS.pop(m, None)
                        _ORPHAN_HANDLED.discard(m)

                t = threading.Thread(target=_orphan_monitor, args=(market, avg_buy_price), daemon=True)
                t.start()
                print(f"[ORPHAN] {market} ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘")

        # ğŸ”§ ì²­ì‚°ëœ í¬ì§€ì…˜ì€ _ORPHAN_HANDLEDì—ì„œ ì œê±° (ì¬ë§¤ìˆ˜ ì‹œ ë‹¤ì‹œ ê°ì§€ ê°€ëŠ¥)
        closed_markets = _ORPHAN_HANDLED - current_markets
        for m in closed_markets:
            _ORPHAN_HANDLED.discard(m)

        # ğŸ”§ ë‹¤ìŒ ì‚¬ì´í´ì„ ìœ„í•´ í˜„ì¬ ë§ˆì¼“ ì €ì¥ (ì‹ ê·œ ë§¤ìˆ˜ ì˜¤íƒ ë°©ì§€)
        _PREV_SYNC_MARKETS = current_markets.copy()

    except Exception as e:
        print(f"[ORPHAN_SYNC_ERR] {e}")


def mark_pending_close(market, reason):
    """
    ğŸ”§ ì²­ì‚° ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ëŒ€ê¸°ì—´ì— ì¶”ê°€
    """
    with _PENDING_CLOSE_LOCK:
        if market not in _PENDING_CLOSE:
            _PENDING_CLOSE[market] = {
                "reason": reason,
                "ts": time.time(),
                "retry_count": 0
            }
            print(f"[PENDING_CLOSE] {market} ì¬ì‹œë„ ëŒ€ê¸°ì—´ì— ì¶”ê°€ (ì‚¬ìœ : {reason})")


def retry_pending_closes():
    """
    ğŸ”§ ì²­ì‚° ì‹¤íŒ¨í•œ í¬ì§€ì…˜ë“¤ ì¬ì‹œë„
    - ì‹¤ì œ ì”ê³ ê°€ 0ì´ë©´ â†’ ëŒ€ê¸°ì—´ì—ì„œ ì œê±° (ì´ë¯¸ ì²­ì‚°ë¨)
    - ì”ê³ ê°€ ìˆìœ¼ë©´ â†’ ì¬ì‹œë„
    - ìµœëŒ€ 5íšŒ ì¬ì‹œë„ í›„ í¬ê¸° (ìˆ˜ë™ ì²˜ë¦¬ í•„ìš” ì•Œë¦¼)
    """
    now = time.time()

    with _PENDING_CLOSE_LOCK:
        markets_to_retry = list(_PENDING_CLOSE.keys())

    if not markets_to_retry:
        return

    for market in markets_to_retry:
        with _PENDING_CLOSE_LOCK:
            info = _PENDING_CLOSE.get(market)
            if not info:
                continue

            # 30ì´ˆ ì¿¨íƒ€ì„
            if now - info["ts"] < PENDING_CLOSE_RETRY_INTERVAL:
                continue

        # ì‹¤ì œ ì”ê³  í™•ì¸
        actual = get_actual_balance(market)

        if actual <= 0:
            # ì´ë¯¸ ì²­ì‚°ë¨ â†’ ëŒ€ê¸°ì—´ì—ì„œ ì œê±°
            with _PENDING_CLOSE_LOCK:
                _PENDING_CLOSE.pop(market, None)
            print(f"[PENDING_CLOSE] {market} ì”ê³  0 í™•ì¸ â†’ ëŒ€ê¸°ì—´ì—ì„œ ì œê±° (ì´ë¯¸ ì²­ì‚°ë¨)")
            continue

        # ì¬ì‹œë„ íšŸìˆ˜ í™•ì¸
        with _PENDING_CLOSE_LOCK:
            info = _PENDING_CLOSE.get(market)
            if not info:
                continue
            retry_count = info["retry_count"]

        if retry_count >= PENDING_CLOSE_MAX_RETRY:
            # ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ â†’ ìˆ˜ë™ ì²˜ë¦¬ í•„ìš”
            with _PENDING_CLOSE_LOCK:
                _PENDING_CLOSE.pop(market, None)
            tg_send(f"ğŸš¨ {market} ì²­ì‚° {PENDING_CLOSE_MAX_RETRY}íšŒ ì‹¤íŒ¨\nâ€¢ ì”ê³ : {actual:.6f}\nâ€¢ ìˆ˜ë™ ì²˜ë¦¬ í•„ìš”!")
            print(f"[PENDING_CLOSE] {market} ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ â†’ ìˆ˜ë™ ì²˜ë¦¬ í•„ìš”")
            continue

        # ì¬ì‹œë„
        print(f"[PENDING_CLOSE] {market} ì²­ì‚° ì¬ì‹œë„ ({retry_count + 1}/{PENDING_CLOSE_MAX_RETRY})")

        with _PENDING_CLOSE_LOCK:
            if market in _PENDING_CLOSE:
                _PENDING_CLOSE[market]["retry_count"] = retry_count + 1
                _PENDING_CLOSE[market]["ts"] = now

        try:
            # ì§ì ‘ ì‹œì¥ê°€ ë§¤ë„ ì‹œë„
            res = place_market_sell(market, actual)
            order_uuid = res.get("uuid") if isinstance(res, dict) else None

            if order_uuid:
                time.sleep(2.0)  # ì²´ê²° ëŒ€ê¸°
                actual_after = get_actual_balance(market)

                if actual_after <= 0:
                    # ì„±ê³µ
                    with _PENDING_CLOSE_LOCK:
                        _PENDING_CLOSE.pop(market, None)
                    tg_send(f"âœ… {market} ì²­ì‚° ì¬ì‹œë„ ì„±ê³µ\nâ€¢ ì²´ê²° í™•ì¸ë¨")
                    print(f"[PENDING_CLOSE] {market} ì¬ì‹œë„ ì„±ê³µ")
                else:
                    print(f"[PENDING_CLOSE] {market} ì¬ì‹œë„ í›„ ì”ê³  {actual_after:.6f} ë‚¨ìŒ")
            else:
                print(f"[PENDING_CLOSE] {market} ì¬ì‹œë„ ì£¼ë¬¸ ì‹¤íŒ¨ (uuid ì—†ìŒ)")

        except Exception as e:
            print(f"[PENDING_CLOSE_ERR] {market} ì¬ì‹œë„ ì‹¤íŒ¨: {e}")
            # ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œì´ë©´ í¬ê¸°
            if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
                with _PENDING_CLOSE_LOCK:
                    _PENDING_CLOSE.pop(market, None)
                print(f"[PENDING_CLOSE] {market} ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ëŒ€ê¸°ì—´ì—ì„œ ì œê±°")


# =========================
# ì»· ë¡œê¹… (ìœ„ì¹˜ ì´ë™: final_price_guardì—ì„œ ì‚¬ìš©)
# =========================
DEBUG_CUT = True           # ì „ì²´ ì»· ë¡œê·¸ (Trueë©´ ëª¨ë“  ì»· ì¶œë ¥)
DEBUG_NEAR_MISS = True     # ì´ˆì… ì‹ í˜¸ ì™”ëŠ”ë° gateì—ì„œ ì»·ëœ ê²½ìš°ë§Œ ì¶œë ¥
CUT_COUNTER = {
    k: 0
    for k in [
        "SURGE_LOW", "VOL_LOW", "SPREAD_HIGH", "PRICE_LOW", "ZSC_LOW",
        "VWAP_GAP_LOW", "UPTICK_FAIL", "FAKE_PUMP", "TICKS_LOW", "TURN_LOW",
        "BUY_WEAK", "BUY_WEAK_MANYT", "FRESH_FAIL", "BIDASK_WEAK",
        "IGNITION_OK", "BOT_PINGPONG", "BOT_WASH", "BOTACC_OK", "WICK_SPIKE",
        "ATR_OVERSHOOT", "EMA15M_DOWN", "BUY_DECAY", "EARLY_OK",
        "EARLY_LIGHT_FAIL", "PEAK_CHASE", "POSTCHECK_DROP", "MEGA_PASS",
        "SCORE_LOW", "SPREAD_EXTREME", "PROBE_TICK", "NO_SIGNAL",
        "STAGE1_GATE", "IGNITION_FAIL", "ENTRY_LOCK_FAIL", "PRICE_GUARD_FAIL"
    ]
}


def cut(reason, detail, near_miss=False):
    CUT_COUNTER[reason] = CUT_COUNTER.get(reason, 0) + 1
    # DEBUG_CUT: ì „ì²´ ë¡œê·¸, DEBUG_NEAR_MISS: ì´ˆì… ì‹ í˜¸ í›„ ì»·ë§Œ
    if DEBUG_CUT or (DEBUG_NEAR_MISS and near_miss):
        now_str = now_kst().strftime("%H:%M:%S")
        print(f"[FILTER][{now_str}] {reason:<16} | {detail}")


def cut_summary():
    parts = [
        f"{k}:{v}" for k, v in sorted(
            CUT_COUNTER.items(), key=lambda x: x[1], reverse=True) if v > 0
    ]
    if parts:
        print(f"[CUT_SUMMARY] {' , '.join(parts)}")


def final_price_guard(m, initial_price, max_drift=None, ticks=None):
    """
    ì£¼ë¬¸ ì§ì „ ê°€ê²© ì¬í™•ì¸ (ë™ì  ì„ê³„ì¹˜)
    - initial_price: ì‹ í˜¸ ë°œìƒ ì‹œ ê¸°ì¤€ ê°€ê²© (pre['price'])
    - max_drift: ì‹ í˜¸ê°€ ëŒ€ë¹„ í—ˆìš© ìƒìŠ¹ë¥  (Noneì´ë©´ ë™ì  ê³„ì‚°)
    - ticks: ë³€ë™ì„± ê³„ì‚°ìš© í‹± ë°ì´í„°
    - AGGRESSIVE_MODE=True ì¸ ê²½ìš°, max_drift~max_drift+1.2% êµ¬ê°„ì€
      'ì¶”ê²© ì§„ì…'ìœ¼ë¡œ ì†Œì•¡/í”¼ë¼ë¯¸ë”© ê¸°ë°˜ ì§„ì… í—ˆìš©
    """
    try:
        js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        if not js:
            print(f"[GUARD] {m} í‹°ì»¤ ì¡°íšŒ ì‹¤íŒ¨ â†’ ê°€ë“œ ìŠ¤í‚µ")
            return True, initial_price

        current_price = js[0].get("trade_price", initial_price)
        drift = (current_price / initial_price - 1.0)

        # ğŸ”§ ë™ì  ì„ê³„ì¹˜: ë³€ë™ì„± + ì¥ì„¸ ë°˜ì˜ (ì‹ í˜¸â†’ì£¼ë¬¸ ì§§ì€ êµ¬ê°„)
        if max_drift is None:
            pstd = price_band_std(ticks or [], sec=10) if ticks else 0.0
            r = relax_knob()  # 0~1.5
            # ğŸ”§ 0.5% ê¸°ì¤€ (ì§§ì€ ìˆœê°„ 0.5% ì›€ì§ì„ì´ë©´ ì¶©ë¶„)
            base = 0.005 if not AGGRESSIVE_MODE else 0.006
            # ğŸ”§ ì•¼ê°„(0~6ì‹œ) ì¶”ê²© í—ˆìš©í­ +0.1% ì™„í™”
            hour = now_kst().hour
            if 0 <= hour < 6:
                base += 0.001
            dyn = base + min(0.004, pstd * 0.5) + r * 0.002
            thr = dyn
        else:
            thr = max_drift

        if drift > thr:
            # í‰ì†Œë¼ë©´ ê³ ì  ì¶”ê²©ìœ¼ë¡œ ì»·
            # í•˜ì§€ë§Œ ê³µê²© ëª¨ë“œë©´ ì¼ì • êµ¬ê°„ê¹Œì§€ëŠ” í—ˆìš©
            # ğŸ”§ 0.5% ê¸°ì¤€ì´ë‹ˆ +0.5% ì¶”ê°€ = ì´ 1% ê¹Œì§€ í—ˆìš©
            if AGGRESSIVE_MODE and drift <= (thr + 0.005):
                print(
                    f"[GUARD][AGGR] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% <= dyn+1.2% "
                    f"â†’ ê³µê²© ëª¨ë“œ: ì¶”ê²© ì§„ì… í—ˆìš©"
                )
                return True, current_price

            # ì´ ì´ìƒì€ ì§„ì§œ ë„ˆë¬´ íŠ„ ê±°ë¼ ì»· (signal_skipì—ì„œ ë¡œê·¸ ì²˜ë¦¬)
            return False, current_price

        # ğŸ”§ FIX: í•˜ë°© ê¸‰ë½ ì»· (í˜ì´í¬ ë¸Œë ˆì´í¬ ë°©ì§€)
        down_thr = max(0.005, thr * 0.8)  # ğŸ”§ 0.5% ë˜ëŠ” ìƒë‹¨ì˜ 80%
        if drift < -down_thr:
            # ê¸‰ë½ ì»· (signal_skipì—ì„œ ë¡œê·¸ ì²˜ë¦¬)
            return False, current_price

        return True, current_price

    except Exception as e:
        print(f"[GUARD_ERR] {m}: {e}")
        # ğŸ”§ FIX: API ì‹¤íŒ¨ ì‹œ í•­ìƒ ì§„ì… ì°¨ë‹¨ (ë¸”ë¼ì¸ë“œ ì§„ì… ë°©ì§€)
        return False, initial_price

# =========================
# ğŸ”¥ ìë™ ë§¤ìˆ˜ ì§„ì…
# =========================
def open_auto_position(m, pre, dyn_stop, eff_sl_pct):
    """
    ì´ˆì…Â·ê³µê²©ëª¨ë“œ ëŒ€ì‘ ìë™ ë§¤ìˆ˜ ì§„ì…
    """
    # ğŸ” DEBUG: ìë™ë§¤ìˆ˜ ì§„ì… ì‹œì‘ ë¡œê·¸
    print(f"[AUTO_ENTRY] {m} ì‹œì‘ (AUTO_TRADE={AUTO_TRADE})")

    def signal_skip(reason):
        """ì´ˆì…ì‹ í˜¸ í›„ ë§¤ìˆ˜ ìŠ¤í‚µ ë¡œê·¸ (near_miss ì¶œë ¥ìš©)"""
        if DEBUG_NEAR_MISS:
            now_str = now_kst().strftime("%H:%M:%S")
            print(f"[SIGNAL_SKIP][{now_str}] {m} | {reason}")

    if not AUTO_TRADE:
        signal_skip("AUTO_TRADE=False (í™˜ê²½ë³€ìˆ˜ AUTO_TRADE=1 í•„ìš”)")
        return

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        signal_skip("API í‚¤ ë¯¸ì„¤ì •")
        return

    # ğŸ” í”„ë¡œì„¸ìŠ¤ ê°„ ì¤‘ë³µ ì§„ì… ë°©ì§€ (íŒŒì¼ë½+ë©”ëª¨ë¦¬ë½ ì»¨í…ìŠ¤íŠ¸)
    # ğŸ”§ FIX: reentrant=Trueë¡œ ë³€ê²½ (ë©”ì¸ ìŠ¤ìº” ë£¨í”„ì—ì„œ ì´ë¯¸ ë½ íšë“í–ˆìœ¼ë¯€ë¡œ)
    with entry_lock(m, ttl_sec=90, reentrant=True) as got_lock:
        if not got_lock:
            signal_skip("entry_lock íšë“ ì‹¤íŒ¨")
            return

        # ğŸ”§ pending ìƒíƒœ ì›ìí™” (ë½ ì•ˆì—ì„œë§Œ ì¡°ì‘)
        with _POSITION_LOCK:
            existing = OPEN_POSITIONS.get(m)
            if existing:
                if not existing.get("pre_signal"):
                    signal_skip("ì´ë¯¸ í¬ì§€ì…˜ ë³´ìœ ì¤‘")
                    return
            active_count = sum(1 for p in OPEN_POSITIONS.values() if p.get("state") == "open")
            if active_count >= MAX_POSITIONS:
                signal_skip(f"ìµœëŒ€ í¬ì§€ì…˜ {MAX_POSITIONS}ê°œ ë„ë‹¬")
                tg_send_mid(f"âš ï¸ {m} ì‹ ê·œ ì§„ì… ëŒ€ê¸° (ìµœëŒ€ {MAX_POSITIONS}ê°œ í¬ì§€ì…˜ ë³´ìœ  ì¤‘)")
                OPEN_POSITIONS.pop(m, None)
                return
            if not existing:
                OPEN_POSITIONS[m] = {"state": "pending"}

        signal_price = pre.get("price")
        if not signal_price:
            signal_skip("pre['price'] ì—†ìŒ")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì…ëª¨ë“œ ë°˜ì˜ ===
        entry_mode = pre.get("entry_mode", "confirm")

        if entry_mode == "probe":
            entry_fraction = 0.10   # ğŸ”§ 10%ë¡œ ì¶•ì†Œ (ì†Œì•¡ íƒìƒ‰)
            mode_emoji = "ğŸ§­"
        elif entry_mode == "half":
            entry_fraction = 0.50   # ğŸ”§ 50% ì‚¬ì´ì¦ˆ (ì¤‘ê°„ íšŒì „ìœ¨)
            mode_emoji = "âš¡"
        elif entry_mode == "confirm":
            entry_fraction = 1.0    # ì „ì²´ ê¸ˆì•¡ (í™•ì • ì§„ì…)
            mode_emoji = "ğŸ”¥"
        else:
            entry_fraction = 1.0
            mode_emoji = "ğŸ¤–"

        # ========================================
        # ğŸš€ Pre-break ì „ìš© 2ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬
        # ========================================
        filter_type = pre.get("filter_type", "")
        if filter_type == "prebreak" and PREBREAK_POSTCHECK_SEC > 0:
            print(f"[PREBREAK] {m} â†’ {PREBREAK_POSTCHECK_SEC}ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ ì‹œì‘")
            time.sleep(PREBREAK_POSTCHECK_SEC)

            # í‹± ì¬ì¡°íšŒ
            ticks_recheck = get_recent_ticks(m, 100)
            if not ticks_recheck:
                signal_skip("PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: í‹± ì—†ìŒ")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            t15_recheck = micro_tape_stats_from_ticks(ticks_recheck, 15)

            # ë§¤ìˆ˜ë¹„/ê±°ë˜ì†ë„ ì¬í™•ì¸
            if t15_recheck["buy_ratio"] < PREBREAK_BUY_MIN * 0.9:  # 10% ì—¬ìœ 
                signal_skip(f"PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: ë§¤ìˆ˜ë¹„ í•˜ë½ ({t15_recheck['buy_ratio']:.0%})")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            if t15_recheck["krw_per_sec"] < PREBREAK_KRW_PER_SEC_MIN * 0.7:  # 30% ì—¬ìœ 
                signal_skip(f"PREBREAK í¬ìŠ¤íŠ¸ì²´í¬: ê±°ë˜ì†ë„ í•˜ë½ ({t15_recheck['krw_per_sec']/1000:.0f}K)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            print(f"[PREBREAK] {m} í¬ìŠ¤íŠ¸ì²´í¬ í†µê³¼ â†’ ì§„ì… ì§„í–‰")

        # â˜… ë™ì  ê°€ê²© ê°€ë“œ (ë³€ë™ì„± + ì¥ì„¸ ë°˜ì˜)
        # ticks ì „ë‹¬ë¡œ ë™ì  ì„ê³„ì¹˜ ê³„ì‚°
        ok_guard, current_price = final_price_guard(m, signal_price, ticks=pre.get("ticks"))
        if not ok_guard:
            drift_pct = (current_price / signal_price - 1) * 100
            signal_skip(f"ê°€ê²©ê°€ë“œ ì‹¤íŒ¨ (ì‹ í˜¸ê°€â†’í˜„ì¬ê°€ {drift_pct:+.2f}%)")
            tg_send(
                f"âš ï¸ <b>ì§„ì… ì·¨ì†Œ</b> {m}\n"
                f"â€¢ ì‹ í˜¸ê°€: {fmt6(signal_price)}ì›\n"
                f"â€¢ í˜„ì¬ê°€: {fmt6(current_price)}ì›\n"
                f"â€¢ ìƒìŠ¹ë¥ : {drift_pct:.2f}%\n"
                f"â€¢ ì‚¬ìœ : ê°€ê²© ê¸‰ë“± (ì´ˆì… ì¶”ê²© ìœ„í—˜)"
            )
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === ê³„ì¢Œ & ì£¼ë¬¸ê¸ˆì•¡ ê³„ì‚° ===
        accounts = get_account_info()
        if not accounts:
            signal_skip("ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # ğŸ”§ FIX: locked ë°˜ì˜í•œ ê°€ìš©ì”ê³  ê³„ì‚°
        krw_bal = get_available_krw(accounts)

        if krw_bal < 6000:
            signal_skip(f"KRW ë¶€ì¡± ({krw_bal:,.0f}ì›)")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        entry_price = current_price
        stop_price = dyn_stop

        # âœ… ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë™ì  ë¦¬ìŠ¤í¬
        adaptive_risk = get_adaptive_risk()

        # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… êµ¬ì¡° ===
        risk_to_use = adaptive_risk * SEED_RISK_FRACTION if USE_PYRAMIDING else adaptive_risk
        risk_to_use *= entry_fraction  # probeëŠ” ë¦¬ìŠ¤í¬ ì¶•ì†Œ ë°˜ì˜

        base_qty = calc_position_size(
            entry_price,
            stop_price,
            krw_bal,
            risk_to_use,
        )

        krw_to_use = base_qty * entry_price

        # ğŸ”§ probeëŠ” ìµœì†Œ 7000ì›, confirmì€ 5000ì›
        min_order_krw = 7000 if entry_mode == "probe" else 5000
        if krw_to_use < min_order_krw:
            # probeì¸ë° ê¸ˆì•¡ ë¶€ì¡±í•˜ë©´ 7000ì›ìœ¼ë¡œ ê°•ì œ ì„¤ì •
            if entry_mode == "probe" and krw_bal >= 7000:
                krw_to_use = 7000
                print(f"[AUTO] probe ìµœì†Œê¸ˆì•¡ ì ìš©: {krw_to_use:,.0f}ì›")
            else:
                signal_skip(f"ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± ({krw_to_use:,.0f}ì› < {min_order_krw:,}ì›)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

        # ğŸ”§ ì²´ê²°ì¶©ê²©(impact) ê¸°ë°˜ ì‚¬ì´ì§• ëŒí¼
        # ë² ìŠ¤íŠ¸í˜¸ê°€ 25% ì´ˆê³¼ ì‚¬ìš© ì‹œ ê³¼ë„ â†’ ìº¡
        try:
            u0 = pre.get("ob", {}).get("raw", {}).get("orderbook_units", [])[0]
            best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
        except Exception:
            best_ask_krw = 0.0

        if best_ask_krw > 0:
            cap = best_ask_krw * 0.25
            if krw_to_use > cap:
                print(f"[IMPACT_CAP] {m} ì£¼ë¬¸ {krw_to_use:,.0f} > 25% of best-ask {cap:,.0f} â†’ ìº¡")
                krw_to_use = int(cap)
                # confirmì´ë©´ halfë¡œ ë‹¤ìš´ì‹œí”„íŠ¸ (ê¸ˆì•¡ ì´ì¤‘ì–µì œ ì œê±°)
                if entry_mode == "confirm":
                    entry_fraction = 0.5
                    print(f"[IMPACT_CAP] {m} confirm â†’ half ì „í™˜")

        krw_to_use = int(krw_to_use)

        # ğŸ”§ FIX: ì„íŒ©íŠ¸ìº¡ í›„ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ì¬ê²€ì¦
        min_order_krw = 7000 if entry_mode == "probe" else 5000
        if krw_to_use < min_order_krw:
            if entry_mode == "probe" and krw_bal >= 7000:
                krw_to_use = 7000
                print(f"[AUTO] probe ìµœì†Œê¸ˆì•¡ ì ìš©(ì„íŒ©íŠ¸ìº¡ í›„): {krw_to_use:,.0f}ì›")
            else:
                signal_skip(f"ì„íŒ©íŠ¸ìº¡ í›„ ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± ({krw_to_use:,.0f}ì›)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

        # === ë§¤ìˆ˜ ===
        try:
            res = place_market_buy(m, krw_to_use)
            print("[AUTO_BUY_RES]", json.dumps(res, ensure_ascii=False))
            oid = res.get("uuid") if isinstance(res, dict) else None
            od = get_order_result(oid, timeout_sec=12) if oid else None
            print("[AUTO_BUY_ORDER]", json.dumps(od, ensure_ascii=False))

            if od:
                volume_filled = float(od.get("executed_volume") or "0")
            else:
                volume_filled = 0.0

            # ğŸ”§ FIX: ì²´ê²° 0ì´ë©´ ì‹¤íŒ¨ ì²˜ë¦¬ (ì”ê³  fallback ì œê±° - ì´ì „ ì”ê³  ì˜¤íŒ ë°©ì§€)
            if volume_filled <= 0:
                signal_skip("ì²´ê²° 0 (ì£¼ë¬¸ ì‹¤íŒ¨)")
                tg_send(f"âš ï¸ {m} ìë™ë§¤ìˆ˜ ì²´ê²° 0 â†’ í¬ì§€ì…˜ ìƒì„± ì•ˆ í•¨")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                return

            # í‰ê· ê°€ ê³„ì‚° (ì²´ê²° ì •ë³´ê°€ ìˆìœ¼ë©´)
            if 'avg_price' not in locals():
                trades = od.get("trades") or [] if od else []
                if trades:
                    total_krw = sum(float(tr["price"]) * float(tr["volume"]) for tr in trades)
                    total_vol = sum(float(tr["volume"]) for tr in trades)
                    avg_price = total_krw / total_vol if total_vol > 0 else entry_price
                else:
                    avg_price = float(entry_price)

        except Exception as e:
            print("[AUTO BUY ERR]", e)
            # ğŸ”§ FIX: ì˜ˆì™¸ ì‹œ ì‹¤íŒ¨ ì²˜ë¦¬ (ì”ê³  fallback ì œê±° - ì´ì „ ì”ê³  ì˜¤íŒ ë°©ì§€)
            signal_skip(f"ë§¤ìˆ˜ ì˜ˆì™¸ ({e})")
            tg_send(f"âš ï¸ ë§¤ìˆ˜ ì‹¤íŒ¨ {m}\n{e}")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return

        # === í¬ì§€ì…˜ ì €ì¥ ===
        with _POSITION_LOCK:
            OPEN_POSITIONS[m] = {
                "entry_price": avg_price,
                "volume": volume_filled,
                "stop": stop_price,
                "sl_pct": eff_sl_pct,
                "state": "open",
                "last_add_ts": 0.0,
                "entry_mode": pre.get("entry_mode", "confirm"),
                "entry_ts": time.time(),  # ğŸ§  ì§„ì… ì‹œê° (í•™ìŠµìš©)
            }

        slip_pct = (avg_price / signal_price - 1.0) if signal_price else 0.0

        # ì§„ì… ì‚¬ìœ  í•œ ì¤„ ìƒì„± (ë””í…Œì¼ í¬í•¨)
        kd = pre.get("killer_details", {})
        checks = kd.get("checks", {})
        thr = kd.get("thresholds", {})  # ì„ê³„ì¹˜
        score = pre.get("score", 0)
        vol_b = kd.get('vol_base', 0)
        vol_s = kd.get('vol_surge', 1)
        buy_r = kd.get('buy_ratio', 0)
        turn_r = kd.get('turn', 0)
        imb = kd.get('imbalance', 0)
        consec = kd.get('consecutive_buys', 0)


        # ğŸ”§ ëŒ€ê¸ˆ/ë°°ìˆ˜ í‘œì‹œ í¬ë§·
        if vol_b >= 1e8:
            vol_str = f"{vol_b/1e8:.1f}ì–µ"
        elif vol_b >= 1e6:
            vol_str = f"{vol_b/1e6:.0f}ë°±ë§Œ"
        else:
            vol_str = f"{vol_b/1e4:.0f}ë§Œ"
        surge_str = f"{vol_s:.1f}x" if vol_s >= 1.0 else f"{vol_s:.2f}x"

        # ğŸ”§ ì§„ì… ì‚¬ìœ : ê°’/ê¸°ì¤€ í˜•íƒœ (ì²´í¬X ì œê±°)
        signal_tag = pre.get("signal_tag", "ê¸°ë³¸")
        thr_buy = thr.get('buy', 0.7)
        thr_turn = thr.get('turn', 0.08)
        thr_imb = thr.get('imb', 0.3)

        detail_str = (f"ëŒ€ê¸ˆ{vol_str} ë°°ìˆ˜{surge_str} "
                      f"ë§¤ìˆ˜{buy_r:.0%}/{thr_buy:.0%} íšŒì „{turn_r:.0%}/{thr_turn:.0%} "
                      f"ì„ë°¸{imb:.2f}/{thr_imb}")

        if entry_mode == "confirm":
            mode_label = "í™•ì •ì§„ì…"
        else:
            mode_label = "íƒìƒ‰ì§„ì…"
        entry_reason = f"{signal_tag} ({detail_str})"

        # ğŸ”§ ì‹¤ì œ ë¹„ìœ¨ ê³„ì‚° (ìµœì†Œê¸ˆì•¡ ì ìš© ì‹œ entry_fractionê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
        actual_pct = (krw_to_use / krw_bal * 100) if krw_bal > 0 else 0

        # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
        filter_type = pre.get("filter_type", "stage1_gate")
        if filter_type == "prebreak":
            path_str = "ğŸš€ì„ í–‰ì§„ì…"
        else:
            path_str = pre.get("signal_tag", "ê¸°ë³¸")

        # âœ… ì†ì ˆê°€ None ë°©ì§€
        safe_stop_str = fmt6(stop_price) if isinstance(stop_price, (int, float)) and stop_price > 0 else "ê³„ì‚°ì¤‘"

        tg_send(
            f"{mode_emoji} <b>[{mode_label}] ìë™ë§¤ìˆ˜</b> {m}\n"
            f"â€¢ ì‚¬ìœ : {entry_reason}\n"
            f"â€¢ ì‹ í˜¸ê°€: {fmt6(signal_price)}ì›\n"
            f"â€¢ ì²´ê²°ê°€: {fmt6(avg_price)}ì›\n"
            f"â€¢ ìŠ¬ë¦¬í”¼ì§€: {slip_pct*100:+.3f}%\n"
            f"â€¢ ì£¼ë¬¸ê¸ˆì•¡: {krw_to_use:,.0f}ì› ({actual_pct:.1f}%)\n"
            f"â€¢ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
            f"â€¢ ì†ì ˆê°€: {safe_stop_str}ì›\n"
            f"{link_for(m)}"
        )

        # === ğŸ§  í”¼ì²˜ ë¡œê¹… (ìë™ í•™ìŠµìš©) ===
        if AUTO_LEARN_ENABLED:
            try:
                ob = pre.get("ob", {})
                t = pre.get("tape", {})
                ticks = pre.get("ticks", [])
                imbalance = calc_orderbook_imbalance(ob) if ob else 0
                turn = t.get("krw", 0) / max(ob.get("depth_krw", 1), 1) if ob else 0

                # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°
                cons_buys = calc_consecutive_buys(ticks, 15)
                t15_stats = micro_tape_stats_from_ticks(ticks, 15)
                avg_krw = calc_avg_krw_per_tick(t15_stats)
                flow_accel = calc_flow_acceleration(ticks)

                # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ê³„ì‚°
                ia_stats = inter_arrival_stats(ticks, 30) if ticks else {"cv": 0.0}
                cv = ia_stats.get("cv", 0.0)
                pstd = price_band_std(ticks, sec=10) if ticks else 0.0
                overheat = flow_accel * float(pre.get("volume_surge", 1.0))
                # í‹± ì‹ ì„ ë„
                fresh_age = 0.0
                if ticks:
                    now_ms = int(time.time() * 1000)
                    last_tick_ts = ticks[0].get("timestamp", now_ms)
                    fresh_age = (now_ms - last_tick_ts) / 1000.0
                # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
                try:
                    u0 = ob.get("raw", {}).get("orderbook_units", [])[0]
                    best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
                except Exception:
                    best_ask_krw = 0.0

                # ğŸ” ê²½ë¡œ ì •ë³´: signal_tag í•˜ë‚˜ë¡œ í†µì¼
                log_trade_features({
                    "ts": now_kst_str(),
                    "market": m,
                    "entry_price": avg_price,
                    "buy_ratio": t.get("buy_ratio", 0),
                    "spread": ob.get("spread", 0),
                    "turn": turn,
                    "imbalance": imbalance,
                    "volume_surge": pre.get("volume_surge", 1.0),
                    "fresh": 1 if last_two_ticks_fresh(ticks) else 0,
                    "score": pre.get("score", 0),
                    "entry_mode": entry_mode,
                    "signal_tag": pre.get("signal_tag", "ê¸°ë³¸"),
                    "filter_type": pre.get("filter_type", "stage1_gate"),
                    # ğŸ”¥ ìƒˆ ì§€í‘œ
                    "consecutive_buys": cons_buys,
                    "avg_krw_per_tick": round(avg_krw, 0),
                    "flow_acceleration": round(flow_accel, 2),
                    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
                    "overheat": round(overheat, 2),
                    "fresh_age": round(fresh_age, 2),
                    "cv": round(cv, 2),
                    "pstd": round(pstd * 100, 4),  # % ë‹¨ìœ„
                    "best_ask_krw": int(best_ask_krw),
                })
            except Exception as e:
                print(f"[FEATURE_LOG_ERR] {e}")

        # ğŸ” ì»¨í…ìŠ¤íŠ¸ ì¢…ë£Œ ì‹œ entry_lock ìë™ í•´ì œ

def add_auto_position(m, cur_price, reason=""):
    """
    ì´ë¯¸ seed í¬ì§€ì…˜ì´ ìˆì„ ë•Œ, ê°•í•œ ì¶”ì„¸ì—ì„œ 1íšŒ ì¶”ë§¤(add) ìˆ˜í–‰
    - ADD_RISK_FRACTION ë¹„ìœ¨ë§Œí¼ RISK_PER_TRADEë¥¼ ë‹¤ì‹œ ì‚¬ìš©
    - í‰ê· ë‹¨ê°€ ì¬ê³„ì‚°
    """
    if not AUTO_TRADE:
        return False, None

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        return False, None

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            return False, None
        if pos.get("added"):
            # ì´ë¯¸ í•œ ë²ˆ ì¶”ë§¤í•œ í¬ì§€ì…˜
            return False, None
        last_add_ts = pos.get("last_add_ts", 0.0)

    now = time.time()
    if (now - last_add_ts) < PYRAMID_ADD_COOLDOWN_SEC:
        return False, None

    accounts = get_account_info()
    if not accounts:
        print("[AUTO_ADD] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
        return False, None

    # ğŸ”§ FIX: locked ë°˜ì˜í•œ ê°€ìš©ì”ê³  ê³„ì‚°
    krw_bal = get_available_krw(accounts)

    if krw_bal < 6000:
        print(f"[AUTO_ADD] KRW ë¶€ì¡±({krw_bal:,.0f}) â†’ ì¶”ë§¤ ìŠ¤í‚µ")
        return False, None

    entry_price_old = pos["entry_price"]
    stop_price = pos["stop"]

    # ì¶”ë§¤ë„ ì ì‘í˜• ë¦¬ìŠ¤í¬ ì ìš© (ì—°íŒ¨/ì—°ìŠ¹ ë°˜ì˜)
    adaptive = max(0.0001, get_adaptive_risk())
    add_risk_pct = max(0.0001, adaptive * ADD_RISK_FRACTION)
    qty_theoretical = calc_position_size(cur_price, stop_price, krw_bal, add_risk_pct)
    krw_to_use = qty_theoretical * cur_price

    if krw_to_use < 5000:
        print(f"[AUTO_ADD] ì£¼ë¬¸ ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ")
        return False, None

    krw_to_use = int(krw_to_use)

    print(
        f"[AUTO_ADD] {m} ì¶”ë§¤ ì‹œë„: {krw_to_use:,.0f} KRW "
        f"(ì´ë¡ ìˆ˜ëŸ‰â‰ˆ{qty_theoretical:.6f}, í˜„ì¬ê°€ {cur_price:,.0f})"
    )

    volume_filled = 0.0
    avg_price_add = cur_price

    try:
        res = place_market_buy(m, krw_to_use)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid, timeout_sec=12.0) if order_uuid else None

        if od:
            try:
                volume_filled = float(od.get("executed_volume") or "0")
            except Exception:
                volume_filled = 0.0

            trades = od.get("trades") or []
            if trades and volume_filled > 0:
                total_krw = 0.0
                total_vol = 0.0
                for tr in trades:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                    total_krw += p * v
                    total_vol += v
                if total_vol > 0:
                    avg_price_add = total_krw / total_vol
            else:
                if volume_filled > 0:
                    avg_price_add = krw_to_use / volume_filled

        if volume_filled <= 0:
            msg = f"[AUTO_ADD] {m} ì¶”ë§¤ ì²´ê²° 0 â†’ ë¬´ì‹œ"
            print(msg)
            tg_send(f"âš ï¸ {msg}")
            return False, None

    except Exception as e:
        print("[AUTO_ADD ERR]", e)
        tg_send(f"âš ï¸ <b>ì¶”ë§¤ ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")
        return False, None

    # í‰ê· ë‹¨ê°€ ê°±ì‹ 
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos:
            return False, None
        old_vol = pos.get("volume", 0.0)
        new_vol = old_vol + volume_filled
        if new_vol <= 0:
            return False, None
        new_entry_price = (entry_price_old * old_vol + avg_price_add * volume_filled) / new_vol

        pos["entry_price"] = new_entry_price
        pos["volume"] = new_vol
        pos["added"] = True
        pos["last_add_ts"] = time.time()
        pos["entry_mode"] = "confirm"  # âœ… probe â†’ confirm ìŠ¹ê²© ìë™ë°˜ì˜

        # ğŸ”§ FIX: ì¶”ë§¤ í›„ ì†ì ˆê°€ ì¬ê³„ì‚° (í‰ë‹¨ì´ ë°”ë€Œì—ˆìœ¼ë¯€ë¡œ)
        try:
            c1_for_sl = get_minutes_candles(1, m, 20)
            new_stop, new_sl_pct, _ = dynamic_stop_loss(new_entry_price, c1_for_sl)
            pos["stop"] = new_stop
            pos["sl_pct"] = new_sl_pct
        except Exception as e:
            print(f"[PYRA_STOP_ERR] ì¶”ë§¤ í›„ ì†ì ˆê°€ ê°±ì‹  ì‹¤íŒ¨: {e}")

    gain_from_old = (avg_price_add / entry_price_old - 1) * 100 if entry_price_old > 0 else 0
    tg_send(
        f"ğŸ“ˆ <b>ì¶”ë§¤ ì²´ê²°</b> {m}\n"
        f"â€¢ ì‚¬ìœ : {reason or 'ì¶”ì„¸ê°•í™”'}\n"
        f"â€¢ ê¸°ì¡´í‰ë‹¨: {fmt6(entry_price_old)}ì› â†’ ì‹ ê·œí‰ë‹¨: {fmt6(new_entry_price)}ì›\n"
        f"â€¢ ì¶”ê°€ ì²´ê²°ê°€: {fmt6(avg_price_add)}ì› (í‰ë‹¨ëŒ€ë¹„ {gain_from_old:+.2f}%)\n"
        f"â€¢ ì¶”ê°€ ìˆ˜ëŸ‰: {volume_filled:.6f} / ì´ ìˆ˜ëŸ‰: {new_vol:.6f}\n"
        f"{link_for(m)}"
    )

    return True, new_entry_price

# =========================
# ğŸ”¥ ìë™ ì²­ì‚°
# =========================
def close_auto_position(m, reason=""):
    """
    ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ ë§¤ë„ (ì°Œêº¼ê¸° ë°©ì§€ í¬í•¨)
    """
    # ğŸ”§ DEBUG: ì²­ì‚° í•¨ìˆ˜ ì§„ì… í™•ì¸
    tg_send(f"ğŸ”§ [{m}] ì²­ì‚°ì‹œì‘ | {reason[:30]}")

    if not AUTO_TRADE:
        print(f"[AUTO] AUTO_TRADE=0 â†’ ì²­ì‚° ìŠ¤í‚µ ({m}, reason={reason})")
        return

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)

    if not pos:
        print(f"[AUTO] OPEN_POSITIONSì— {m} í¬ì§€ì…˜ ì—†ìŒ â†’ ì²­ì‚° ìŠ¤í‚µ (reason={reason})")
        tg_send(f"âš ï¸ {m} ì²­ì‚° ì‹œë„ â†’ í¬ì§€ì…˜ ì—†ìŒ (ì´ë¯¸ ì •ë¦¬ë¨)\nâ€¢ ì‚¬ìœ : {reason}")
        return

    # ì‹¤ì œ ë³´ìœ ëŸ‰ ì¡°íšŒ (ì°Œêº¼ê¸° ë°©ì§€)
    actual_vol = get_actual_balance(m)
    vol = actual_vol if actual_vol > 0 else pos.get("volume", 0)

    tg_send_mid(f"ğŸ’£ {m} ìë™ì²­ì‚° ì‹œë„ (reason={reason}, vol={vol:.6f})")

    if vol <= 0:
        print(f"[AUTO] {m} volume<=0 ({vol}) â†’ í¬ì§€ì…˜ ì œê±°ë§Œ ìˆ˜í–‰")
        with _POSITION_LOCK:
            OPEN_POSITIONS.pop(m, None)
        # ğŸ”§ FIX: volume 0ì´ì–´ë„ ì•ŒëŒ + ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
        tg_send(f"âš ï¸ {m} ì²­ì‚° ì™„ë£Œ (ìˆ˜ëŸ‰ 0 í™•ì¸)\nâ€¢ ì‚¬ìœ : {reason}\nâ€¢ ì™¸ë¶€ ì²­ì‚° ë˜ëŠ” ì´ë¯¸ ì •ë¦¬ë¨")
        if AUTO_LEARN_ENABLED:
            try:
                update_trade_result(m, 0, 0, 0)  # ë”ë¯¸ ê°’ìœ¼ë¡œ ì¹´ìš´íŠ¸ë§Œ
            except:
                pass
        return

    entry_price = pos.get("entry_price", 0)

    # í˜„ì¬ê°€(ì²­ì‚° ì „ ê¸°ì¤€) ì¡°íšŒ - âœ… í¼ë¸”ë¦­ API ì‚¬ìš©
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        cur_price = cur_js[0].get("trade_price",
                                  entry_price) if cur_js else entry_price
    except Exception:
        cur_price = entry_price

    # ì„  ê³„ì‚°(ëŒ€ëµ)
    ret_pct = (cur_price / entry_price -
               1.0) * 100.0 if entry_price > 0 else 0.0
    est_entry_value = entry_price * vol
    est_exit_value = cur_price * vol
    pl_value = est_exit_value - est_entry_value

    print(
        f"[AUTO] {m} ì²­ì‚° ì‹œë„: volume={vol}, reason={reason}, PnL(ì„ ê³„ì‚°)={ret_pct:+.2f}%"
    )

    exit_price_used = cur_price  # ì‹¤ì œ ì²´ê²°ê°€ ì„±ê³µ ì‹œ êµì²´

    try:
        res = place_market_sell(m, vol, price_hint=cur_price)  # ğŸ”§ ê°€ê²© íŒíŠ¸ ì „ë‹¬
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        if order_uuid:
            od = get_order_result(order_uuid, timeout_sec=20.0)  # ğŸ”§ 12â†’20ì´ˆë¡œ ì¦ê°€
        else:
            od = None

        # ì‹¤ì œ ì²´ê²°ëŸ‰/ì²´ê²°ê°€ ê³„ì‚°
        executed = 0.0
        if od:
            trades = od.get("trades") or []
            total_krw = 0.0
            total_vol = 0.0
            for tr in trades:
                try:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                except Exception:
                    continue
                total_krw += p * v
                total_vol += v
            executed = total_vol
            if total_vol > 0:
                exit_price_used = total_krw / total_vol

        # ğŸ”§ FIX #1: ë¯¸ì²´ê²° ì‹œ ì”ê³  ì¬í™•ì¸ í›„ ì²˜ë¦¬
        if executed <= 0:
            # ğŸ”§ FIX: íƒ€ì„ì•„ì›ƒ ì‹œ ì”ê³  ì¬í™•ì¸ (ëŠ¦ì€ ì²´ê²° ëŒ€ì‘)
            time.sleep(2.0)
            actual_after = get_actual_balance(m)
            if actual_after <= 1e-12:
                # ì‹¤ì”ê³  0 = ì²´ê²°ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                tg_send(f"ğŸ§¹ <b>ìë™ì²­ì‚° ì™„ë£Œ(ì”ê³ í™•ì¸)</b> {m}\nâ€¢ ì£¼ë¬¸ì‘ë‹µ ì§€ì—°ìœ¼ë¡œ ì”ê³ =0 í™•ì¸ í›„ ì™„ë£Œ ì²˜ë¦¬\nâ€¢ ì‚¬ìœ : {reason}")
                return
            print(f"[AUTO] {m} ì²­ì‚° ë¯¸ì²´ê²° â†’ ì¬ì‹œë„ ëŒ€ê¸°ì—´ì— ì¶”ê°€")
            tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ë¯¸ì²´ê²°</b> {m}\nì‚¬ìœ : ì²´ê²°ëŸ‰ 0 / ì¬ì‹œë„ ì˜ˆì •")
            mark_pending_close(m, reason)
            return

        # ğŸ”§ FIX #1: ë¶€ë¶„ì²´ê²° ì‹œ ì”ì—¬ëŸ‰ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        if executed < vol - 1e-10:
            remaining = max(vol - executed, 0.0)
            # âœ… ì”ì—¬ê°€ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡(5000ì›) ë¯¸ë§Œì´ë©´ ë©”ëª¨ë¦¬ì—ì„œ ì œê±° (ì¢€ë¹„ ë°©ì§€)
            if exit_price_used * remaining < 5000:
                remaining = 0.0
            with _POSITION_LOCK:
                pos2 = OPEN_POSITIONS.get(m)
                if pos2:
                    if remaining <= 0:
                        OPEN_POSITIONS.pop(m, None)
                    else:
                        pos2["volume"] = remaining
                        pos2["last_exit_ts"] = time.time()
                        OPEN_POSITIONS[m] = pos2
            print(f"[AUTO] {m} ë¶€ë¶„ì²´ê²°: {executed:.6f}/{vol:.6f} â†’ ì”ì—¬ {remaining:.6f}")
            if remaining > 0:
                tg_send(f"âš ï¸ <b>ë¶€ë¶„ì²´ê²°</b> {m}\nì²´ê²°: {executed:.6f} / ì”ì—¬: {remaining:.6f}")
            else:
                tg_send(f"âš ï¸ <b>ë¶€ë¶„ì²´ê²°</b> {m}\nì²´ê²°: {executed:.6f} / ì”ì—¬ ë¯¸ë‹¬ â†’ ì •ë¦¬ì™„ë£Œ")
            # ë¶€ë¶„ì²´ê²°ë„ ì†ìµ ê³„ì‚°ì€ í•¨ (executed ê¸°ì¤€)
            vol = executed  # ì•„ë˜ ì†ìµ ê³„ì‚°ìš©

        # ğŸ”§ FIX #1: ì „ëŸ‰ì²´ê²° ì‹œì—ë§Œ í¬ì§€ì…˜ ì œê±°
        else:
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)

        # ğŸ”§ FIX: ì‹¤ì œ ì²´ê²°ëŸ‰(vol=executed) ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
        est_entry_value = entry_price * vol  # âœ… executed ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
        est_exit_value = exit_price_used * vol
        pl_value = est_exit_value - est_entry_value
        ret_pct = (exit_price_used / entry_price -
                   1.0) * 100.0 if entry_price > 0 else 0.0

        # âœ… ê±°ë˜ ê²°ê³¼ ê¸°ë¡ (ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹ì— ì‚¬ìš©)
        try:
            record_trade(m, ret_pct)
        except Exception as _e:
            print("[TRADE_RECORD_ERR]", _e)

        # ğŸ§  ìë™ í•™ìŠµìš© ê²°ê³¼ ì—…ë°ì´íŠ¸
        if AUTO_LEARN_ENABLED:
            try:
                hold_sec = time.time() - pos.get("entry_ts", time.time())
                was_added = pos.get("added", False)  # ğŸ” ì¶”ë§¤ ì—¬ë¶€
                update_trade_result(m, exit_price_used, ret_pct / 100.0, hold_sec,
                                    added=was_added, exit_reason=reason)
            except Exception as _e:
                print(f"[FEATURE_UPDATE_ERR] {_e}")

        result_emoji = "ğŸŸ¢" if ret_pct > 0 else "ğŸ”´"
        fee_total = (est_entry_value + est_exit_value) * 0.0005  # ìˆ˜ìˆ˜ë£Œ ì¶”ì • (0.05%)

        # ğŸ”§ DEBUG: ì²­ì‚° ì•ŒëŒ ë°œì†¡ ì§ì „ ë¡œê·¸
        print(f"[CLOSE_DEBUG] {m} ì²­ì‚°ì•ŒëŒ ë°œì†¡ ì§ì „ | ret={ret_pct:.2f}% vol={vol:.6f} exit_price={exit_price_used}")

        tg_result = tg_send(
            f"====================================\n"
            f"{result_emoji} <b>ìë™ì²­ì‚° ì™„ë£Œ</b> {m}\n"
            f"====================================\n"
            f"ğŸ’° ìˆœì†ìµ: {pl_value:+,.0f}ì› ({ret_pct:+.2f}%)\n\n"
            f"â€¢ ì‚¬ìœ : {reason}\n"
            f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {fmt6(entry_price)}ì›\n"
            f"â€¢ ì‹¤ë§¤ë„ê°€: {fmt6(exit_price_used)}ì›\n"
            f"â€¢ ì²´ê²°ìˆ˜ëŸ‰: {vol:.6f}\n"
            f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡: {est_entry_value:,.0f}ì›\n"
            f"â€¢ ì²­ì‚°ê¸ˆì•¡: {est_exit_value:,.0f}ì›\n"
            f"â€¢ ìˆ˜ìˆ˜ë£Œ: {fee_total:,.0f}ì›\n"
            f"====================================\n"
            f"{link_for(m)}"
        )
        # ğŸ”§ DEBUG: ì²­ì‚° ì•ŒëŒ ë°œì†¡ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
        if not tg_result:
            print(f"[CLOSE_DEBUG] {m} ì²­ì‚°ì•ŒëŒ ì‹¤íŒ¨! ì¬ì‹œë„...")
            time.sleep(1)
            tg_send(f"âš ï¸ ì²­ì‚°ì•ŒëŒ ì¬ì „ì†¡ {m}\n{result_emoji} {ret_pct:+.2f}% | {reason}")

    except Exception as e:
        print("[AUTO SELL ERR]", e)
        import traceback
        traceback.print_exc()  # ğŸ”§ DEBUG: ìƒì„¸ ì—ëŸ¬ ì¶œë ¥
        tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}\nâ€¢ ì¬ì‹œë„ ì˜ˆì •")

        # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ë§¤ë„ ë¶ˆê°€ ì°Œêº¼ê¸°, ë©”ëª¨ë¦¬ í¬ì§€ì…˜ë§Œ ì •ë¦¬
        if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            tg_send(f"ğŸ§¹ {m} ì²­ì‚° ì™„ë£Œ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ)\nâ€¢ ì†ŒëŸ‰ ì”ì—¬ëŠ” ê±°ë˜ì†Œì— ë³´ìœ ")
            # ğŸ”§ FIX: ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
            if AUTO_LEARN_ENABLED:
                try:
                    update_trade_result(m, 0, 0, 0)
                except:
                    pass
            return

        # ğŸ”§ FIX: 400 ì—ëŸ¬ ì‹œ ì‹¤ì œ ì”ê³  í™•ì¸ â†’ 0ì´ë©´ ì¢€ë¹„ í¬ì§€ì…˜ ì œê±°
        if "400" in str(e) or "Bad Request" in str(e):
            actual_check = get_actual_balance(m)
            if actual_check <= 0:
                print(f"[AUTO] {m} ì”ê³  0 í™•ì¸ â†’ ì¢€ë¹„ í¬ì§€ì…˜ ì œê±°")
                tg_send(f"ğŸ—‘ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ ì™„ë£Œ (ì‹¤ì œ ì”ê³  0 í™•ì¸)")
                with _POSITION_LOCK:
                    OPEN_POSITIONS.pop(m, None)
                # ğŸ”§ FIX: ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
                if AUTO_LEARN_ENABLED:
                    try:
                        update_trade_result(m, 0, 0, 0)
                    except:
                        pass
                return

        # ğŸ”§ ê·¸ ì™¸ ì—ëŸ¬ëŠ” ì¬ì‹œë„ ëŒ€ê¸°ì—´ì— ì¶”ê°€
        mark_pending_close(m, reason)
        return


def safe_partial_sell(m, sell_ratio=0.5, reason=""):
    """
    ë¶€ë¶„ ì²­ì‚° ê³µìš© í•¨ìˆ˜
    - sell_ratio: 0.5 â†’ 50%, 0.3 â†’ 30% ë“±
    - partial_done í”Œë˜ê·¸ë¡œ 1íšŒë§Œ ë¶€ë¶„ì²­ì‚°/ë¶€ë¶„ìµì ˆ í—ˆìš©
    ë°˜í™˜: (ì„±ê³µì—¬ë¶€:bool, ë©”ì‹œì§€:str, ì²´ê²°ëŸ‰:float)
    """
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: í¬ì§€ì…˜ ì—†ìŒ/ìˆ˜ëŸ‰ 0"
            print(msg)
            return False, msg, 0.0
        if pos.get("partial_done"):
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì´ë¯¸ ìˆ˜í–‰ë¨ â†’ ìŠ¤í‚µ"
            print(msg)
            return False, msg, 0.0
        current_volume = pos["volume"]
        entry_price = pos.get("entry_price", 0)

    sell_volume = current_volume * sell_ratio
    if sell_volume <= 0:
        msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: sell_volume<=0"
        print(msg)
        return False, msg, 0.0

    # ğŸ”§ í˜„ì¬ê°€ ì¡°íšŒ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ìš©)
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        cur_price = cur_js[0].get("trade_price", entry_price) if cur_js else entry_price
    except Exception:
        cur_price = entry_price

    # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡(5000ì›) ì‚¬ì „ê²€ì¦
    MIN_ORDER_KRW = 5000
    sell_krw = sell_volume * cur_price
    remaining_volume = current_volume - sell_volume
    remaining_krw = remaining_volume * cur_price

    # ë§¤ë„ê¸ˆì•¡ ë˜ëŠ” ì”ì—¬ê¸ˆì•¡ì´ 5000ì› ë¯¸ë§Œì´ë©´ â†’ ì „ëŸ‰ì²­ì‚°ìœ¼ë¡œ ì „í™˜
    if sell_krw < MIN_ORDER_KRW or remaining_krw < MIN_ORDER_KRW:
        print(f"[PARTIALâ†’FULL] {m} ìµœì†Œê¸ˆì•¡ ë¯¸ë‹¬ (ë§¤ë„:{sell_krw:.0f}ì›, ì”ì—¬:{remaining_krw:.0f}ì›) â†’ ì „ëŸ‰ì²­ì‚°")
        sell_volume = current_volume  # ì „ëŸ‰ìœ¼ë¡œ ë³€ê²½
        # partial_doneì€ ì„¤ì •í•˜ì§€ ì•ŠìŒ (ì „ëŸ‰ì²­ì‚°ì´ë¯€ë¡œ í¬ì§€ì…˜ ì¢…ë£Œë¨)

    try:
        res = place_market_sell(m, sell_volume, price_hint=cur_price)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid,
                              timeout_sec=12.0) if order_uuid else None

        executed = 0.0
        if od:
            try:
                executed = float(od.get("executed_volume") or "0")
            except Exception:
                executed = 0.0

        if executed <= 0:
            msg = f"[PARTIAL_SELL_ERR] {m}: executed_volume=0 (ìš”ì²­ {sell_volume:.6f})"
            print(msg)
            tg_send_mid(f"âš ï¸ <b>ë¶€ë¶„ì²­ì‚° ì£¼ë¬¸ ì‹¤íŒ¨</b> {m}\n"
                        f"â€¢ ìš”ì²­ ë¹„ìœ¨: {sell_ratio*100:.0f}%\n"
                        f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {sell_volume:.6f}\n"
                        f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: 0 (ì‹¤íŒ¨)")
            return False, msg, 0.0

        remaining_volume = max(current_volume - executed, 0.0)

        # ì‹¤ì œ ì²´ê²°ê°€ ê³„ì‚°
        exit_price_used = 0.0
        if od:
            trades = od.get("trades") or []
            total_krw = 0.0
            total_vol = 0.0
            for tr in trades:
                try:
                    p = float(tr.get("price", "0"))
                    v = float(tr.get("volume", "0"))
                except Exception:
                    continue
                total_krw += p * v
                total_vol += v
            if total_vol > 0:
                exit_price_used = total_krw / total_vol

        # ì†ìµ ê³„ì‚°
        est_entry_value = entry_price * executed
        est_exit_value = exit_price_used * executed if exit_price_used > 0 else 0
        pl_value = est_exit_value - est_entry_value
        ret_pct = (exit_price_used / entry_price - 1.0) * 100.0 if entry_price > 0 and exit_price_used > 0 else 0.0
        fee_total = (est_entry_value + est_exit_value) * 0.0005

        # ğŸ’¥ í¬ë¦¬í‹°ì»¬ í•«í”½ìŠ¤: ì”ì—¬ 0ì´ë©´ í¬ì§€ì…˜ ì œê±° (ì¢€ë¹„ ë°©ì§€)
        if remaining_volume <= 1e-10:
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            print(f"[PARTIALâ†’FULL_DONE] {m} ì „ëŸ‰ì²­ì‚° ì™„ë£Œ â†’ í¬ì§€ì…˜ ì œê±°")
        else:
            with _POSITION_LOCK:
                pos2 = OPEN_POSITIONS.get(m)
                if pos2:
                    pos2["volume"] = remaining_volume
                    pos2["partial_done"] = True
                    pos2["partial_price"] = exit_price_used if exit_price_used > 0 else cur_price
                    pos2["partial_type"] = "profit" if ret_pct > 0 else "loss"

        msg = (f"[REMONITOR] {m} ë¶€ë¶„ ì²­ì‚° ì‹¤í–‰ {sell_ratio*100:.0f}% "
               f"(ì²´ê²° {executed:.6f}) ì”ì—¬ {remaining_volume:.6f}")
        print(msg)

        result_emoji = "ğŸŸ¢" if ret_pct > 0 else "ğŸ”´"
        tg_send(
            f"====================================\n"
            f"{result_emoji} <b>ë¶€ë¶„ ì²­ì‚°</b> {m}\n"
            f"====================================\n"
            f"ğŸ’° ìˆœì†ìµ: {pl_value:+,.0f}ì› ({ret_pct:+.2f}%)\n\n"
            f"â€¢ ì‚¬ìœ : {reason or 'ë¶€ë¶„ì²­ì‚°'}\n"
            f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {fmt6(entry_price)}ì›\n"
            f"â€¢ ì‹¤ë§¤ë„ê°€: {fmt6(exit_price_used)}ì›\n"
            f"â€¢ ì²´ê²°ìˆ˜ëŸ‰: {executed:.6f}\n"
            f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡: {est_entry_value:,.0f}ì›\n"
            f"â€¢ ì²­ì‚°ê¸ˆì•¡: {est_exit_value:,.0f}ì›\n"
            f"â€¢ ìˆ˜ìˆ˜ë£Œ: {fee_total:,.0f}ì›\n"
            f"â€¢ ì”ì—¬ìˆ˜ëŸ‰: {remaining_volume:.6f}\n"
            f"===================================="
        )

        # ğŸ”§ ë¶€ë¶„ì²­ì‚°ë„ ê±°ë˜ ê¸°ë¡ì— ì¶”ê°€ (ê²½ë¡œ ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ìš©)
        if AUTO_LEARN_ENABLED and remaining_volume <= 1e-10:
            # ì „ëŸ‰ì²­ì‚°ëœ ê²½ìš°ë§Œ ê¸°ë¡ (ë¶€ë¶„ì²­ì‚° í›„ ì „ëŸ‰ì²­ì‚° ì‹œ)
            try:
                with _POSITION_LOCK:
                    pos_for_ts = OPEN_POSITIONS.get(m, {})
                hold_sec = time.time() - pos_for_ts.get("entry_ts", time.time())
                was_added = pos_for_ts.get("added", False)  # ğŸ” ì¶”ë§¤ ì—¬ë¶€
                update_trade_result(m, exit_price_used, ret_pct / 100.0, hold_sec,
                                    added=was_added, exit_reason=reason or "ë¶€ë¶„ì²­ì‚°")
            except Exception as _e:
                print(f"[PARTIAL_TRADE_LOG_ERR] {_e}")

        return True, msg, executed

    except Exception as e:
        msg = f"[PARTIAL_SELL_ERR] {m}: {e}"
        print(msg)
        # ğŸ”§ FIX: ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ â†’ ë§¤ë„ ë¶ˆê°€ ì°Œêº¼ê¸°, ë©”ëª¨ë¦¬ í¬ì§€ì…˜ë§Œ ì •ë¦¬
        if "ìµœì†Œì£¼ë¬¸ê¸ˆì•¡" in str(e) or "5000" in str(e):
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            tg_send(f"ğŸ§¹ {m} ë¶€ë¶„ì²­ì‚° ì™„ë£Œ (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ)\nâ€¢ í¬ì§€ì…˜ ì •ë¦¬ë¨")
            # ğŸ”§ FIX: ë¦¬í¬íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
            if AUTO_LEARN_ENABLED:
                try:
                    update_trade_result(m, 0, 0, 0)
                except:
                    pass
        return False, msg, 0.0


def remonitor_until_close(m, entry_price, pre, tight_mode=False):
    """
    ëì•ŒëŒ ì´í›„ ìë™ì²­ì‚° ì‹ í˜¸ê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ ëª¨ë‹ˆí„°ë§
    ğŸ”§ FIX: ì¥ê¸° ë³´ìœ  íƒ€ì„ì•„ì›ƒ ì¶”ê°€ (ë¶€ë¶„ì²­ì‚° í›„ ì •ì²´ ë°©ì§€)
    """
    CYCLE_SEC = 300
    cycle = 0

    # ğŸ”§ ì‹œê°„ ê¸°ë°˜ íƒ€ì„ì•„ì›ƒ ì œê±° - ê°€ê²© ì¡°ê±´ìœ¼ë¡œë§Œ ë§¤ë„

    while True:
        cycle += 1
        print(f"[REMONITOR] {m} {cycle}íšŒì°¨ ì¬ëª¨ë‹ˆí„°ë§ ì‹œì‘")

        # ğŸ”§ ìœ ë ¹ í¬ì§€ì…˜ íƒˆì¶œ: ì‹¤ì”ê³  í™•ì¸
        with _POSITION_LOCK:
            pos = OPEN_POSITIONS.get(m)
        if not pos:
            print(f"[REMONITOR] {m} OPEN_POSITIONSì— ì—†ìŒ â†’ ë£¨í”„ ì¢…ë£Œ")
            # ğŸ”§ FIX: í¬ì§€ì…˜ ì—†ìŒ ì•ŒëŒ ì¶”ê°€
            tg_send(f"âš ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ë¨ (OPEN_POSITIONSì—ì„œ ì œê±°ë¨)")
            return False

        # ì‹¤ì œ ê±°ë˜ì†Œ ì”ê³  í™•ì¸
        actual = get_actual_balance(m)
        if actual <= 0:
            print(f"[REMONITOR] {m} ì‹¤ì”ê³  0 â†’ ìœ ë ¹ í¬ì§€ì…˜ ì •ë¦¬ í›„ ë£¨í”„ ì¢…ë£Œ")
            # ğŸ”§ FIX: ì²­ì‚° ì•ŒëŒ ì¶”ê°€ (ì™¸ë¶€ ì •ë¦¬ ë˜ëŠ” ì²´ê²° ëˆ„ë½ ê°ì§€)
            entry_price_for_msg = pos.get("entry_price", 0)
            tg_send(f"âš ï¸ {m} í¬ì§€ì…˜ ì •ë¦¬ (ì‹¤ì”ê³  0 í™•ì¸)\nâ€¢ ë§¤ìˆ˜ê°€: {fmt6(entry_price_for_msg)}ì›\nâ€¢ ì™¸ë¶€ ì²­ì‚° ë˜ëŠ” ì´ë¯¸ ì •ë¦¬ë¨")
            with _POSITION_LOCK:
                OPEN_POSITIONS.pop(m, None)
            return False

        # ğŸ”§ ë¶€ë¶„ì²­ì‚° í›„ ì¶”ê°€ í•˜ë½ ì²´í¬
        if pos and pos.get("partial_done"):
            partial_price = pos.get("partial_price", 0)
            partial_type = pos.get("partial_type", "loss")

            # í˜„ì¬ê°€ ì¡°íšŒ
            try:
                cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
                cur_price = cur_js[0].get("trade_price", 0) if cur_js else 0
            except:
                cur_price = 0

            if cur_price > 0 and partial_price > 0:
                if partial_type == "profit":
                    # ìµì ˆ ë¶€ë¶„ì²­ì‚° í›„: -0.2% ì¶”ê°€ í•˜ë½ OR ì§„ì…ê°€ ì´í•˜ â†’ ì²­ì‚°
                    drop_from_partial = (partial_price - cur_price) / partial_price
                    if cur_price <= entry_price or drop_from_partial >= PARTIAL_EXIT_PROFIT_DROP:
                        reason = f"ë¶€ë¶„ìµì ˆ í›„ ì¶”ê°€í•˜ë½ -{drop_from_partial*100:.2f}% ì”ëŸ‰ì²­ì‚°"
                        print(f"[REMONITOR] {m} {reason} â†’ ë‚˜ë¨¸ì§€ ì²­ì‚°")
                        close_auto_position(m, reason)
                        return True
                else:
                    # ì†ì ˆ ë¶€ë¶„ì²­ì‚° í›„: -0.1% ì¶”ê°€ í•˜ë½ â†’ ì²­ì‚°
                    drop_from_partial = (partial_price - cur_price) / partial_price
                    if drop_from_partial >= PARTIAL_EXIT_LOSS_DROP:
                        reason = f"ë¶€ë¶„ì†ì ˆ í›„ ì¶”ê°€í•˜ë½ -{drop_from_partial*100:.2f}% ì”ëŸ‰ì²­ì‚°"
                        print(f"[REMONITOR] {m} {reason} â†’ ë‚˜ë¨¸ì§€ ì²­ì‚°")
                        close_auto_position(m, reason)
                        return True

        verdict, action, rationale, ret_pct, last_price, maxrun, maxdd = \
            monitor_position(
                m, entry_price, pre,
                tight_mode=tight_mode,
                horizon=CYCLE_SEC,
                reentry=True
            )

        should_close = False
        reason = verdict or action or "ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ"

        # 1) ê¸‰ë½ / ì†ì ˆ ê¶Œê³ 
        if verdict and ("ê¸‰ë½" in verdict or "ì†ì ˆ" in verdict):
            should_close = True

        # 2) ì „ëŸ‰ ì²­ì‚° ê¶Œê³ 
        elif action and "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ " in action:
            should_close = True

        # 3) ìˆ˜ìµ ì‹¤í˜„:
        #    - 2.5% ì´ìƒ: ì „ëŸ‰ ì²­ì‚°
        #    - 1.5% ~ 2.5%: 30% ë¶€ë¶„ìµì ˆ(í¬ì§€ì…˜ë‹¹ 1íšŒ)
        elif ret_pct is not None and ret_pct >= 2.5:
            should_close = True
            reason = f"ìˆ˜ìµì‹¤í˜„ ì§„ì… í›„ +{ret_pct:.2f}% ë‹¬ì„± ì „ëŸ‰ì²­ì‚°"

        elif ret_pct is not None and ret_pct >= 1.5:
            # ì¤‘ê°„ êµ¬ê°„: 30% ë¶€ë¶„ ìˆ˜ìµì‹¤í˜„ í›„ ê³„ì† ë³´ìœ 
            ok, msg, executed = safe_partial_sell(
                m, sell_ratio=0.3, reason=f"ì§„ì… í›„ +{ret_pct:.2f}% ìˆ˜ìµ ë‹¬ì„± 30% ë¶€ë¶„ìµì ˆ")
            if ok and executed > 0:
                print(msg)
            # ë¶€ë¶„ìµì ˆ í›„ì—ëŠ” ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
            continue

        # 4) ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ê¶Œê³ ëŠ” â†’ ì²­ì‚° ì•ˆ í•˜ê³  ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif verdict and verdict.startswith("ì²­ì‚° ê¶Œê³ ("):
            continue

        # 5) ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³  â†’ ì‹¤ì œ 50% ë§¤ë„ í›„ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ ":
            ok, msg, executed = safe_partial_sell(m,
                                                  sell_ratio=0.5,
                                                  reason="ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ ì‹œì  50% ë¶€ë¶„ì²­ì‚°")
            if ok and executed > 0:
                print(msg)
            continue

        # 6) ìœ ì§€ ê¶Œê³  â†’ ê³„ì† ì¬ëª¨ë‹ˆí„°ë§
        elif action == "ìœ ì§€ ê¶Œê³ ":
            continue

        # 7) ê·¸ëƒ¥ ì‹œê°„ ë§Œë£Œë©´ â†’ ë‹¤ì‹œ í•œ ë²ˆ ì‚¬ì´í´
        elif verdict == "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)":
            continue

        if should_close:
            print(f"[REMONITOR] {m} ìë™ì²­ì‚° ì¡°ê±´ ì¶©ì¡± â†’ ì²­ì‚° ({reason})")
            close_auto_position(m, reason)
            return True


# =========================
# ì–¼ëŸ¿ ì •ì±…
# =========================
SILENT_MIDDLE_ALERTS = True


def tg_send_mid(t):
    if not SILENT_MIDDLE_ALERTS:
        return tg_send(t)
    else:
        print("[SILENT]", t)
        return True

def send_remonitor_alert(m, text):
    """
    ì¬ëª¨ë‹ˆí„°ë§ / ì»¨í…ìŠ¤íŠ¸ìš© ìš”ì•½ ì•ŒëŒ
    - í…”ë ˆê·¸ë¨ ê³¼ë‹¤ ë°©ì§€: TG ì „ì†¡ì€ ë¹„í™œì„±í™”, ì½˜ì†”ë§Œ ë‚¨ê¹€
    """
    now = time.time()
    last = REMONITOR_LAST_ALERT.get(m, 0)
    elapsed = now - last

    # 5ë¶„ ì´ë‚´ë©´ ì™„ì „íˆ ìŠ¤í‚µ (ì½˜ì†”ì—ë„ ì¶œë ¥í•˜ì§€ ì•ŠìŒ)
    if elapsed < REMONITOR_COOLDOWN_SEC:
        return

    REMONITOR_LAST_ALERT[m] = now
    print(f"[REMONITOR_INFO] {m} {text}")  # ì½˜ì†”ë§Œ ë‚¨ê¹€
    return  # TG ì „ì†¡ ë¹„í™œì„±í™”

# =========================
# í•„í„° íŒŒë¼ë¯¸í„° (Conservative-Balanced)ã„¹
# =========================
# ê±°ë˜/ê°€ê²© ê¸°ë°˜
MIN_VOLUME_KRW = 450_000  # 400k -> 700k (í—ˆìˆ˜ ì €ê°)
MIN_RELATIVE_KRW_X = 1.08  # 1.18 -> 1.25 (ê³¼ê±°ëŒ€ë¹„ ì¦ê°€ìœ¨)

# í‹±/ì²´ê²° ê¸°ë°˜
TAPE_WINDOW_SEC = 15
MIN_TICKS_COUNT = 3
MIN_TURNOVER = 0.018
TICKS_BUY_RATIO = 0.56

# ìœ„í—˜ ê´€ë¦¬ (ìŠ¤í”„ë ˆë“œ)
MAX_SPREAD_BASE = 0.70  # 0.60 -> 0.45
MAX_SPREAD_FAST = 1.00  # 1.10 -> 0.80
MIN_DEPTH_KRW = 6_000_000

# ========================================
# â˜…â˜…â˜… 1ë‹¨ê³„ ê²Œì´íŠ¸ ì„ê³„ì¹˜ (ìë™í•™ìŠµ ëŒ€ìƒ) â˜…â˜…â˜…
# ========================================
GATE_TURN_MIN = 2.0       # íšŒì „ìœ¨ í•˜í•œ (%)
GATE_TURN_MAX = 80.0      # íšŒì „ìœ¨ ìƒí•œ (%) - 40â†’80 ì™„í™”
GATE_SPREAD_MAX = 0.40    # ìŠ¤í”„ë ˆë“œ ìƒí•œ (%) - 0.20â†’0.40 ì™„í™”
GATE_ACCEL_MIN = 0.3      # ê°€ì†ë„ í•˜í•œ (x) - ì´ˆê¸° ì™„í™” (í•™ìŠµ ë°ì´í„° ìˆ˜ì§‘ìš©)
GATE_ACCEL_MAX = 100.0    # ğŸ”§ ì‚¬ì‹¤ìƒ ì œê±°: ê¸‰ë“± ì´ˆì… ì¡ê¸° (3.0â†’100.0)
GATE_BUY_RATIO_MIN = 0.55 # ë§¤ìˆ˜ë¹„ í•˜í•œ - ì´ˆê¸° ì™„í™” (0.65â†’0.55)
GATE_SURGE_MAX = 100.0    # ğŸ”§ ì‚¬ì‹¤ìƒ ì œê±°: ê¸‰ë“± ì´ˆì… ì¡ê¸°
GATE_OVERHEAT_MAX = 100.0 # ğŸ”§ ì‚¬ì‹¤ìƒ ì œê±°: ê¸‰ë“± ì´ˆì… ì¡ê¸°
GATE_IMBALANCE_MIN = 0.50 # ğŸ”§ ë°ì´í„° ê¸°ë°˜: ìŠ¹0.65 vs íŒ¨0.45 â†’ 0.50
GATE_CONSEC_MAX = 10      # ğŸ”§ ì‹ ê·œ: ì—°ì†ë§¤ìˆ˜ ìƒí•œ (ìŠ¹5 vs íŒ¨12~20)
GATE_CV_MAX = 2.0         # ğŸ”§ ì‹ ê·œ: CV ìƒí•œ (ìŠ¹1.47 vs íŒ¨2.05)
GATE_FRESH_AGE_MAX = 2.0  # í‹± ì‹ ì„ ë„ ìƒí•œ (ì´ˆ) - ë°ì´í„° ê¸°ë°˜ ì¡°ì • (MED 2.7s, WAVES 5.2s íŒ¨ë°°)
GATE_VOL_MIN = 100_000    # ğŸ”§ ì™„í™”: 200Kâ†’100K (1ì–µ) - ë°¤ì‹œê°„ëŒ€ ì €ìœ ë™ì„± ëŒ€ì‘
GATE_SURGE_MIN = 1.5      # ğŸ”§ ê°•í™”: 0.4â†’1.5 (ì‹¤ì „ë¶„ì„: ì„±ê³µ ì¤‘ì•™ê°’ 2.53x vs ì‹¤íŒ¨ 1.28x)
GATE_PRICE_MIN = 0.003    # ğŸ”§ ê°•í™”: 0.05%â†’0.3% (ì‹¤ì „ë¶„ì„: AUC=0.722 ìµœê³  íŒë³„ë ¥)
GATE_VOL_VS_MA20_MIN = 0.0  # ğŸ”§ ë¹„í™œì„±í™” (íš¨ê³¼ ì—†ìŒ, ë‚˜ì¤‘ì— ì¬ê²€í† )

# ========================================
# ğŸš€ Pre-break Probe ì„¤ì • (ì„ í–‰ ì§„ì…)
# ========================================
PREBREAK_ENABLED = False              # Pre-break ë¹„í™œì„±í™” (stage1_gateë¡œ í†µí•©)
PREBREAK_HIGH_PCT = 0.002             # ê³ ì  ëŒ€ë¹„ 0.2% ì´ë‚´
PREBREAK_POSTCHECK_SEC = 2            # probe ì „ìš© 2ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬
PREBREAK_BUY_MIN = 0.60               # ìµœì†Œ ë§¤ìˆ˜ë¹„ 60%
PREBREAK_KRW_PER_SEC_MIN = 20_000     # ìµœì†Œ ê±°ë˜ì†ë„ (ì›/ì´ˆ)
PREBREAK_IMBALANCE_MIN = 0.55         # ìµœì†Œ í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ (ë§¤ìˆ˜ìš°ìœ„)

# í—ˆìˆ˜ ë°©ì–´
MIN_SUSTAINED_SECONDS = 120
MIN_REAL_TRADES = 10
MAX_FADE_RATIO = 0.70

# ì†ì ˆ/ëª¨ë‹ˆí„°ë§
STOP_LOSS_PCT = 0.008
RECHECK_SEC = 5
MONITOR_MAX = 180

# Ignition
IGN_BREAK_LOOKBACK = 12
IGN_MIN_BODY = 0.006
IGN_MIN_BUY = 0.60
# USE_5M_CONTEXT ìƒë‹¨ì—ì„œ ì¼ì›í™” (ì¤‘ë³µ ì œê±°)

# Bot-aware
BOT_PINGPONG_MAX_BAND = 0.0015
BOT_PINGPONG_MIN_ALT = 0.90
BOT_WASH_REPEAT_VOL_N = 5
BOT_TWAP_MAX_CV = 0.48
BOT_TWAP_MAX_PSTD = 0.0018
BOT_ACCUM_MIN_BUY = 0.54
BOT_ACCUM_MAX_BUY = 0.68
BOT_ACCUM_MIN_TURN = 0.030

# íŠ¸ë Œë“œ ê°€ë“œ
USE_TREND_GUARD = False

# Early Entry
USE_EARLY_ENTRY = True
EARLY_MIN_VWAP_GAP = 0.0005
EARLY_MIN_BUY = 0.50
EARLY_MIN_TURN = 0.012
EARLY_MIN_TICKS = 2
# EARLY_FLOW_MIN_KRWPSEC ìƒë‹¨ì—ì„œ ì¼ì›í™” (ì¤‘ë³µ ì œê±°)
EARLY_MAX_VWAP_GAP = 0.018  # 1ë¶„ë´‰ê°€-VWAP ìµœëŒ€ ê´´ë¦¬ (1.8%) í—ˆìš©
EARLY_MAX_EMA5_GAP = 0.022

# í‹± ê¸°ë°˜ ì¡°ê¸° ë¸Œë ˆì´í¬
USE_TICK_BREAK = True
TICK_BREAK_GAP = 0.0020

# ì ì‘ì‹ ë³¼ë¥¨ ì„œì§€
ABS_SURGE_KRW = 2_200_000   # ì ˆëŒ€ ê±°ë˜ëŒ€ê¸ˆ ì„œì§€ ê¸°ì¤€ (2.2M KRW)
RELAXED_X = 1.08            # ê³¼ê±°ëŒ€ë¹„ ê±°ë˜ëŒ€ê¸ˆ ì™„í™” ë°°ìœ¨

# ì¿¨ë‹¤ìš´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
REARM_MIN_SEC = 45
REARM_PRICE_GAP = 0.009
REARM_PULLBACK_MAX = 0.004
REARM_REBREAK_MIN = 0.0028

# í¬ìŠ¤íŠ¸ì²´í¬(í—ˆìˆ˜ 2ì°¨) - ìƒë‹¨ì—ì„œ ì •ì˜ë¨, ì´ì¤‘ì„ ì–¸ ì œê±°
# POSTCHECK_ENABLED = False  # âŒ ì œê±°: ìƒë‹¨(56ì¤„)ì—ì„œ ì •ì˜ë¨
POSTCHECK_WINDOW_SEC = 3
POSTCHECK_MIN_BUY = 0.46  # 0.52 -> 0.54
POSTCHECK_MIN_RATE = 0.16  # 0.18 -> 0.26
POSTCHECK_MAX_PSTD = 0.0028  # 0.0028 -> 0.0022
POSTCHECK_MAX_CV = 0.72  # 0.70 -> 0.60
POSTCHECK_MAX_DD = 0.018

# ë™ì  ì†ì ˆ(ATR) - ë‹¨ì¼ ìŠ¤íƒ‘ (í‹±ìŠ¤íƒ‘ ì œê±°)
ATR_PERIOD = 14
ATR_EMA_PERIOD = 20
ATR_MULT = 0.35           # ğŸ”§ 0.30 â†’ 0.35 (ì•½ê°„ ì™„í™”)
DYN_SL_MIN = 0.004        # ğŸ”§ 0.3% â†’ 0.4% (ì†ì ˆ ì™„í™”)
DYN_SL_MAX = 0.006        # ğŸ”§ 0.5% â†’ 0.6% (ì†ì ˆ ì™„í™”)

# =========================
# ğŸ¯ í‹± ê¸°ë°˜ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ë¹„í™œì„±í™” - ATR ë‹¨ì¼ ìŠ¤íƒ‘ ì‚¬ìš©)
# =========================
STOP_MODE = "percent"            # ğŸ”§ "ticks" â†’ "percent" (ATR ê¸°ë°˜ ë‹¨ì¼í™”)
MIN_TICK_DIST = 3                # (ë¯¸ì‚¬ìš©)
ATR_TICKS_MULT = 0.6             # (ë¯¸ì‚¬ìš©)
SPREAD_TICKS_PAD = 1             # (ë¯¸ì‚¬ìš©)
TICK_STOP_DEBOUNCE_SEC = 3       # (ë¯¸ì‚¬ìš©)
TICK_STOP_DEBOUNCE_N = 2         # ë””ë°”ìš´ìŠ¤ íšŸìˆ˜
USE_BID_FOR_STOP = True          # ìŠ¤íƒ‘ íŒì •ì€ best bidë¡œ
# ğŸ”§ HARD_STOP_DDëŠ” ìƒë‹¨ í”„ë¡œíŒŒì¼ì—ì„œë§Œ ì„¤ì • (ì´ì¤‘ì •ì˜ ì œê±°)

# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ (ìš°íšŒ ì—„ê²©í™”)
ULTRA_RELAX_ON_MEGA = True
MEGA_BREAK_MIN_GAP = 0.022  # 1.2% -> 2.0%
MEGA_MIN_1M_CHG = 0.025  # 1.8% -> 2.8%
MEGA_VOL_Z = 2.8  # 2.2 -> 2.8
MEGA_ABS_KRW = 4_000_000  # 2.0M -> 4.0M

# =========================
# ğŸ¯ ë¦¬ìŠ¤í¬ ìŠ¤ì½”ì–´ ì„¤ì • (AND â†’ ê°€ì¤‘í•©)
# =========================
USE_RISK_SCORE = True
RISK_SCORE_THRESHOLD = 50  # ì§„ì… ê¸°ì¤€ ì ìˆ˜

# ê°€ì¤‘ì¹˜ (í•©ê³„ 100) - ğŸ”§ ì´ˆê¸°ê°’ ê³ ì • (ìë™í•™ìŠµ ë¦¬ì…‹)
SCORE_WEIGHTS = {
    "buy_ratio": 28,      # ë§¤ìˆ˜ë¹„ (í•µì‹¬)
    "spread": 15,         # ìŠ¤í”„ë ˆë“œ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
    "turn": 22,           # íšŒì „ìœ¨
    "imbalance": 18,      # ì˜¤ë”ë¶ ì„ë°¸ëŸ°ìŠ¤
    "fresh": 7,           # í‹± ì‹ ì„ ë„
    "volume_surge": 10,   # ê±°ë˜ëŸ‰ ê¸‰ì¦
}

def calc_orderbook_imbalance(ob):
    """
    1~3í˜¸ê°€ ê°€ì¤‘ í‰ê·  ì„ë°¸ëŸ°ìŠ¤ ê³„ì‚°
    - 1í˜¸ê°€ ê°€ì¤‘ì¹˜ 3, 2í˜¸ê°€ 2, 3í˜¸ê°€ 1
    - ë°˜í™˜ê°’: -1.0 ~ +1.0 (ì–‘ìˆ˜=ë§¤ìˆ˜ìš°ì„¸)
    """
    try:
        units = ob["raw"]["orderbook_units"][:3]
        bid_weighted = sum(u["bid_size"] * u["bid_price"] * (3-i) for i, u in enumerate(units))
        ask_weighted = sum(u["ask_size"] * u["ask_price"] * (3-i) for i, u in enumerate(units))
        total = bid_weighted + ask_weighted
        if total <= 0:
            return 0.0
        imbalance = (bid_weighted - ask_weighted) / total
        return max(-1.0, min(1.0, imbalance))
    except:
        return 0.0

def _safe_float(x, default=0.0):
    """NaN/inf ë°©ì§€ìš© ì•ˆì „ ë³€í™˜"""
    try:
        if x is None:
            return default
        f = float(x)
        if math.isnan(f) or math.isinf(f):
            return default
        return f
    except:
        return default

def calc_risk_score(buy_ratio, spread, turn, imbalance, fresh_ok, volume_surge):
    """
    ë¦¬ìŠ¤í¬ ìŠ¤ì½”ì–´ ê³„ì‚° (0~100)
    - ê° í”¼ì²˜ë¥¼ ì •ê·œí™”í•´ì„œ ê°€ì¤‘í•©
    """
    # ğŸ”§ ì•ˆì „ íŒ¨ì¹˜: NaN/inf ë°©ì§€
    buy_ratio = _safe_float(buy_ratio, 0.5)
    spread = _safe_float(spread, 0.5)
    turn = _safe_float(turn, 0.01)
    imbalance = _safe_float(imbalance, 0.0)
    volume_surge = _safe_float(volume_surge, 1.0)

    # ğŸ”§ ì•ˆì „ íŒ¨ì¹˜: ë§¤ìˆ˜ë¹„ 100% ë¹„ì •ìƒê°’ í´ë¦¬í•‘ (í—ˆìˆ˜/ìŠ¤í‘¸í•‘ ë°©ì§€)
    if buy_ratio >= 0.999:
        buy_ratio = 0.98

    score = 0.0

    # ë§¤ìˆ˜ë¹„: 0.50~0.70 â†’ 0~100
    buy_norm = max(0, min(1, (buy_ratio - 0.50) / 0.20))
    score += SCORE_WEIGHTS["buy_ratio"] * buy_norm

    # ìŠ¤í”„ë ˆë“œ: 0.0~1.0% â†’ 100~0 (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
    spread_norm = max(0, min(1, 1.0 - spread / 1.0))
    score += SCORE_WEIGHTS["spread"] * spread_norm

    # íšŒì „ìœ¨: 0~0.05 â†’ 0~100
    turn_norm = max(0, min(1, turn / 0.05))
    score += SCORE_WEIGHTS["turn"] * turn_norm

    # ì„ë°¸ëŸ°ìŠ¤: -0.3~+0.3 â†’ 0~100
    imb_norm = max(0, min(1, (imbalance + 0.3) / 0.6))
    score += SCORE_WEIGHTS["imbalance"] * imb_norm

    # í‹± ì‹ ì„ ë„: bool â†’ 0 or 100
    score += SCORE_WEIGHTS["fresh"] * (1.0 if fresh_ok else 0.0)

    # ê±°ë˜ëŸ‰ ê¸‰ì¦: 1.0~2.5 â†’ 0~100
    surge_norm = max(0, min(1, (volume_surge - 1.0) / 1.5))
    score += SCORE_WEIGHTS["volume_surge"] * surge_norm

    return round(score, 1)

# =========================
# ğŸ§  ìë™ ê°€ì¤‘ì¹˜ í•™ìŠµ ì‹œìŠ¤í…œ
# =========================
TRADE_LOG_PATH = os.path.join(os.getcwd(), "trade_features.csv")
WEIGHTS_PATH = os.path.join(os.getcwd(), "learned_weights.json")
# ğŸ”§ ìë™í•™ìŠµ OFF
AUTO_LEARN_ENABLED = False  # í•™ìŠµ ë¹„í™œì„±í™”
AUTO_LEARN_APPLY = False    # í•™ìŠµ ê²°ê³¼ ì ìš© ì•ˆí•¨
AUTO_LEARN_MIN_TRADES = 100 # ë¶„ì„ ì‹œ ìµœì†Œ ìƒ˜í”Œ
AUTO_LEARN_INTERVAL = 10    # ğŸ”§ 10ê±´ë§ˆë‹¤ í•™ìŠµ
AUTO_LEARN_STREAK_TRIGGER = 3  # ğŸ”§ ì—°ì† 3íŒ¨ ì‹œ ì¦‰ì‹œ í•™ìŠµ
_trade_log_lock = threading.Lock()
_trade_count_since_learn = 0  # ë§ˆì§€ë§‰ í•™ìŠµ ì´í›„ ê±°ë˜ ìˆ˜
_path_report_count = 0  # ğŸ” ê²½ë¡œ ë¦¬í¬íŠ¸ìš© ì¹´ìš´í„°
_reported_trades = set()  # ğŸ”§ ì¤‘ë³µ ì¹´ìš´íŠ¸ ë°©ì§€ìš© (market, entry_ts) ì„¸íŠ¸
PATH_REPORT_INTERVAL = 10  # ğŸ”§ 10ê±´ë§ˆë‹¤ ë°œì†¡ (ìµœê·¼ 10ê±´ ìƒì„¸ í‘œì‹œì™€ ë§ì¶¤)
# ğŸ”§ _lose_streak, _win_streakëŠ” ìƒë‹¨(ë¼ì¸ 203-204)ì—ì„œ ì„ ì–¸ë¨

FEATURE_FIELDS = [
    "ts", "market", "entry_price", "exit_price",
    "buy_ratio", "spread", "turn", "imbalance", "volume_surge",
    "fresh", "score", "entry_mode",
    "signal_tag", "filter_type",  # ğŸ” ê²½ë¡œ ë¶„ì„ìš© (signal_tag í•˜ë‚˜ë¡œ í†µì¼)
    "consecutive_buys", "avg_krw_per_tick", "flow_acceleration",  # ğŸ”¥ ìƒˆ ì§€í‘œ
    # ğŸ”¥ GATE í•µì‹¬ + ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
    "overheat", "fresh_age", "cv", "pstd", "best_ask_krw",
    # ğŸ” ì„€ë„ìš° ëª¨ë“œìš© (ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, ë‚˜ì¤‘ì— ë¶„ì„ìš©)
    "shadow_flags", "would_cut",
    # ğŸ” ë¦¬í¬íŠ¸ ìƒì„¸: ì¶”ë§¤ì—¬ë¶€ + ì²­ì‚°ì‚¬ìœ 
    "added", "exit_reason",
    "pnl_pct", "result", "hold_sec"
]

def log_trade_features(entry_data: dict, exit_data: dict = None):
    """
    ê±°ë˜ í”¼ì²˜ ë¡œê¹… (ì§„ì… ì‹œ í˜¸ì¶œ, ì²­ì‚° ì‹œ ì—…ë°ì´íŠ¸)
    """
    with _trade_log_lock:
        new_file = not os.path.exists(TRADE_LOG_PATH)
        with open(TRADE_LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=FEATURE_FIELDS)
            if new_file:
                w.writeheader()
            row = {k: entry_data.get(k, "") for k in FEATURE_FIELDS}
            if exit_data:
                row.update(exit_data)
            w.writerow(row)

_last_report_ts = {}  # ğŸ”§ ì¤‘ë³µ ì¹´ìš´íŠ¸ ë°©ì§€: ë§ˆì§€ë§‰ ë¦¬í¬íŠ¸ ì‹œê° (market -> ts)

def update_trade_result(market: str, exit_price: float, pnl_pct: float, hold_sec: float,
                        added: bool = False, exit_reason: str = ""):
    """
    ì²­ì‚° ì‹œ ê²°ê³¼ ì—…ë°ì´íŠ¸ + ê±´ìˆ˜ ê¸°ë°˜ í•™ìŠµ íŠ¸ë¦¬ê±° + ê²½ë¡œ ë¦¬í¬íŠ¸
    - added: ì¶”ë§¤ ì—¬ë¶€ (probe â†’ confirm ìŠ¹ê²© ì‹œ True)
    - exit_reason: ì²­ì‚° ì‚¬ìœ  (ì˜ˆ: ATRì†ì ˆ, íŠ¸ë ˆì¼ë§, ì–‡ì€ìˆ˜ìµ, ì‹œê°„ì¢…ë£Œ ë“±)
    """
    global _trade_count_since_learn, _lose_streak, _win_streak, _path_report_count

    # ğŸ”§ ë°©ì–´: last_trade_was_lossê°€ ì•„ì§ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
    globals().setdefault("last_trade_was_loss", {})

    # ğŸ”§ ì¤‘ë³µ ì¹´ìš´íŠ¸ ë°©ì§€: ê°™ì€ ë§ˆì¼“ì´ 30ì´ˆ ë‚´ ì¤‘ë³µ í˜¸ì¶œë˜ë©´ ìŠ¤í‚µ
    now_ts = time.time()
    last_ts = _last_report_ts.get(market, 0)
    if now_ts - last_ts < 30:
        print(f"[UPDATE_TRADE] {market} ì¤‘ë³µ í˜¸ì¶œ ìŠ¤í‚µ ({now_ts - last_ts:.1f}ì´ˆ ë‚´)")
        return
    _last_report_ts[market] = now_ts

    print(f"[UPDATE_TRADE] {market} ì²­ì‚° ê¸°ë¡ ì‹œì‘ (pnl: {pnl_pct:.2%})")

    is_win = pnl_pct > 0
    csv_exists = os.path.exists(TRADE_LOG_PATH)

    # ğŸ”§ ì†ì‹¤ í›„ ë™ì¼ ì¢…ëª© ì¿¨ë‹¤ìš´ 2ë°° ì ìš©ìš© í”Œë˜ê·¸ ì„¤ì •
    last_trade_was_loss[market] = not is_win

    if not csv_exists:
        print(f"[UPDATE_TRADE] {TRADE_LOG_PATH} íŒŒì¼ ì—†ìŒ (CSV ì—…ë°ì´íŠ¸ ìŠ¤í‚µ, ë¦¬í¬íŠ¸ëŠ” ê³„ì†)")
    else:
        with _trade_log_lock:
            try:
                rows = []
                with open(TRADE_LOG_PATH, "r", encoding="utf-8") as f:
                    reader = csv.DictReader(f)
                    rows = list(reader)

                # ë§ˆì§€ë§‰ í•´ë‹¹ ë§ˆì¼“ ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸
                for i in range(len(rows) - 1, -1, -1):
                    if rows[i]["market"] == market and not rows[i].get("exit_price"):
                        rows[i]["exit_price"] = str(exit_price)
                        rows[i]["pnl_pct"] = f"{pnl_pct:.4f}"
                        rows[i]["result"] = "win" if is_win else "lose"
                        rows[i]["hold_sec"] = str(int(hold_sec))
                        # ğŸ” ë¦¬í¬íŠ¸ ìƒì„¸: ì¶”ë§¤ì—¬ë¶€ + ì²­ì‚°ì‚¬ìœ 
                        rows[i]["added"] = "1" if added else "0"
                        rows[i]["exit_reason"] = exit_reason
                        break

                # ë‹¤ì‹œ ì“°ê¸°
                with open(TRADE_LOG_PATH, "w", newline="", encoding="utf-8") as f:
                    w = csv.DictWriter(f, fieldnames=FEATURE_FIELDS)
                    w.writeheader()
                    w.writerows(rows)
            except Exception as e:
                print(f"[TRADE_LOG_UPDATE_ERR] {e}")

    # ğŸ”§ ê±´ìˆ˜ ê¸°ë°˜ í•™ìŠµ íŠ¸ë¦¬ê±° (ë§¤ìˆ˜ë§Œ í•™ìŠµ)
    if AUTO_LEARN_ENABLED:
        _trade_count_since_learn += 1

        if is_win:
            _lose_streak = 0   # ìŠ¹ë¦¬ ì‹œ ì—°íŒ¨ ë¦¬ì…‹
            _win_streak += 1   # ğŸ”§ ì—°ìŠ¹ ì¦ê°€
        else:
            _lose_streak += 1  # íŒ¨ë°° ì‹œ ì—°íŒ¨ ì¦ê°€
            _win_streak = 0    # ğŸ”§ ì—°ìŠ¹ ë¦¬ì…‹

        # ğŸ”§ ì—°íŒ¨ 3íšŒ ì‹œ Pre-break 10ë¶„ê°„ ì¤‘ì§€
        global _PREBREAK_SUSPEND_UNTIL
        if _lose_streak >= 3:
            _PREBREAK_SUSPEND_UNTIL = time.time() + 600  # 10ë¶„
            print(f"[LOSE_STREAK] ì—°ì† {_lose_streak}íŒ¨ â†’ Pre-break 10ë¶„ ì¤‘ì§€")

        # í•™ìŠµ ì¡°ê±´: 10ê±´ë§ˆë‹¤ OR ì—°ì† 3íŒ¨
        should_learn = (
            _trade_count_since_learn >= AUTO_LEARN_INTERVAL or
            _lose_streak >= AUTO_LEARN_STREAK_TRIGGER
        )

        if should_learn:
            trigger_reason = f"ì—°ì† {_lose_streak}íŒ¨" if _lose_streak >= AUTO_LEARN_STREAK_TRIGGER else f"{_trade_count_since_learn}ê±´ ë„ë‹¬"
            print(f"[AUTO_LEARN] í•™ìŠµ íŠ¸ë¦¬ê±°: {trigger_reason}")
            _trade_count_since_learn = 0  # ë¦¬ì…‹

            try:
                learn_result = analyze_and_update_weights()
                if learn_result:
                    thr = learn_result.get("thresholds", {})
                    chg = learn_result.get("changes", {})

                    # analyze_and_update_weights() ì•ˆì—ì„œ ì´ë¯¸ GATE_* ì „ì—­ì„ ê°±ì‹ í•¨
                    change_detail = " | ".join(
                        f"{k}:{v:+g}" for k, v in chg.items() if v != 0
                    ) or "ë³€í™”ì—†ìŒ"

                    tg_send(
                        f"ğŸ§  <b>ìë™í•™ìŠµ ì™„ë£Œ</b> ({trigger_reason})\n"
                        f"ğŸ“Š ìŠ¹ë¥ : {learn_result['win_rate']}% ({learn_result['wins']}ìŠ¹/{learn_result['loses']}íŒ¨)\n"
                        f"ğŸ“ˆ ìƒ˜í”Œ: {learn_result.get('sample_size', 0)}ê±´\n"
                        f"ğŸ§± ê²Œì´íŠ¸ ë³€í™”: {change_detail}\n"
                        f"ğŸ¯ í˜„ì¬ ì„ê³„ì¹˜: "
                        f"ë§¤ìˆ˜ë¹„â‰¥{thr.get('GATE_BUY_RATIO_MIN', GATE_BUY_RATIO_MIN):.0%} "
                        f"ìŠ¤í”„ë ˆë“œâ‰¤{thr.get('GATE_SPREAD_MAX', GATE_SPREAD_MAX):.2f}% "
                        f"íšŒì „â‰¥{thr.get('GATE_TURN_MIN', GATE_TURN_MIN):.1f}% "
                        f"ì„ë°¸â‰¥{thr.get('GATE_IMBALANCE_MIN', GATE_IMBALANCE_MIN):.2f} "
                        f"ê¸‰ë“±â‰¤{thr.get('GATE_SURGE_MAX', GATE_SURGE_MAX):.1f}x "
                        f"ê°€ì†â‰¥{thr.get('GATE_ACCEL_MIN', GATE_ACCEL_MIN):.2f}x"
                    )
                else:
                    tg_send_mid(f"ğŸ§  ìë™í•™ìŠµ ì‹œë„ ({trigger_reason}) - ë°ì´í„° ë¶€ì¡±ìœ¼ë¡œ ìŠ¤í‚µ")
            except Exception as e:
                print(f"[AUTO_LEARN_ERR] {e}")

    # ğŸ” ê²½ë¡œ ë¦¬í¬íŠ¸ (20ê±´ë§ˆë‹¤ ìë™ ë°œì†¡)
    _path_report_count += 1
    print(f"[PATH_REPORT] ì¹´ìš´íŠ¸: {_path_report_count}/{PATH_REPORT_INTERVAL}")
    if _path_report_count >= PATH_REPORT_INTERVAL:
        _path_report_count = 0
        try:
            # ê²½ë¡œ í†µê³„ + ìƒì„¸ ê±°ë˜ ëª©ë¡ í•©ì³ì„œ ë°œì†¡
            path_report = get_path_statistics(50)  # ìµœê·¼ 50ê±´ ê²½ë¡œ ë¶„ì„
            detail_report = get_recent_trades_detail(10)  # ìµœê·¼ 10ê±´ ìƒì„¸
            combined = path_report + detail_report
            print(f"[PATH_REPORT] ë¦¬í¬íŠ¸ ë°œì†¡ ì‹œë„")
            tg_send(combined)
        except Exception as e:
            print(f"[PATH_REPORT_ERR] {e}")

def get_path_statistics(last_n: int = 100) -> str:
    """
    ğŸ” ê²½ë¡œë³„ ìŠ¹ë¥  í†µê³„ ìƒì„± (í…”ë ˆê·¸ë¨ ë¦¬í¬íŠ¸ìš©)
    """
    if not os.path.exists(TRADE_LOG_PATH):
        return "ğŸ“Š ê±°ë˜ ê¸°ë¡ ì—†ìŒ"

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        # result ì»¬ëŸ¼ì´ ìˆê³  ê°’ì´ ìˆëŠ” í–‰ë§Œ (ì²­ì‚° ì™„ë£Œëœ ê±°ë˜)
        if "result" not in df.columns:
            return "ğŸ“Š ì²­ì‚° ê¸°ë¡ ì—†ìŒ"

        df = df[df["result"].isin(["win", "lose"])].tail(last_n)

        if len(df) < 5:
            return f"ğŸ“Š ë°ì´í„° ë¶€ì¡± ({len(df)}ê±´, ìµœì†Œ 5ê±´ í•„ìš”)"

        total = len(df)
        wins = len(df[df["result"] == "win"])
        overall_wr = wins / total * 100 if total > 0 else 0

        lines = [
            f"ğŸ“Š <b>ê²½ë¡œë³„ ìŠ¹ë¥  ë¦¬í¬íŠ¸</b> (ìµœê·¼ {total}ê±´)",
            f"ğŸ“ˆ ì „ì²´ ìŠ¹ë¥ : {overall_wr:.1f}% ({wins}ìŠ¹/{total-wins}íŒ¨)",
            "â”€" * 20,
        ]

        # ğŸ”¥ ì§„ì… ê²½ë¡œë³„ ìŠ¹ë¥  (signal_tag ê¸°ì¤€)
        if "signal_tag" in df.columns:
            lines.append("<b>ğŸ“ ì§„ì… ê²½ë¡œ:</b>")
            tag_stats = {}
            for _, row in df.iterrows():
                tag = str(row.get("signal_tag", "ê¸°ë³¸"))
                if tag not in tag_stats:
                    tag_stats[tag] = {"win": 0, "total": 0}
                tag_stats[tag]["total"] += 1
                if row["result"] == "win":
                    tag_stats[tag]["win"] += 1

            # ìŠ¹ë¥  ìˆœ ì •ë ¬
            sorted_tags = sorted(tag_stats.items(),
                                 key=lambda x: (x[1]["win"]/max(x[1]["total"],1), x[1]["total"]),
                                 reverse=True)
            for tag, stats in sorted_tags:
                cnt = stats["total"]
                w = stats["win"]
                wr = w / cnt * 100 if cnt > 0 else 0
                star = " âœ…" if wr >= overall_wr + 10 else (" âš ï¸" if wr <= overall_wr - 10 else "")
                lines.append(f"  {tag}: {cnt}ê±´ ({wr:.0f}%){star}")

            # ì¶”ì²œ: ê°€ì¥ ë‚˜ìœ ê²½ë¡œ ì°¾ê¸°
            lines.append("â”€" * 20)
            worst = None
            worst_wr = 100
            for tag, stats in sorted_tags:
                cnt = stats["total"]
                if cnt >= 3:
                    wr = stats["win"] / cnt * 100
                    if wr < worst_wr:
                        worst_wr = wr
                        worst = tag

            if worst and worst_wr < overall_wr - 5:
                lines.append(f"ğŸ’¡ ê²€í†  í•„ìš”: {worst} ({worst_wr:.0f}%)")
            else:
                lines.append("ğŸ’¡ íŠ¹ë³„íˆ ë‚˜ìœ ê²½ë¡œ ì—†ìŒ")

        return "\n".join(lines)

    except Exception as e:
        return f"ğŸ“Š í†µê³„ ì˜¤ë¥˜: {e}"

def get_recent_trades_detail(last_n: int = 10) -> str:
    """
    ğŸ” ìµœê·¼ ê±°ë˜ ìƒì„¸ ëª©ë¡ (ì„ê³„ì¹˜ ë¶„ì„ìš©)
    """
    if not os.path.exists(TRADE_LOG_PATH):
        return ""

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        if "result" not in df.columns:
            return ""

        # ì²­ì‚° ì™„ë£Œëœ ê±°ë˜ë§Œ
        df = df[df["result"].isin(["win", "lose"])].tail(last_n)

        if len(df) == 0:
            return ""

        lines = [
            "",
            f"ğŸ“‹ <b>ìµœê·¼ {len(df)}ê±´ ìƒì„¸</b>",
            "â”€" * 20,
        ]

        for idx, row in df.iterrows():
            # ê¸°ë³¸ ì •ë³´
            market = str(row.get("market", "?"))[-6:]  # KRW-XXXì—ì„œ XXXë§Œ
            result = row.get("result", "?")
            pnl_raw = row.get("pnl_pct", 0) or 0
            pnl = float(pnl_raw) * 100  # ğŸ”§ FIX: ì†Œìˆ˜ â†’ í¼ì„¼íŠ¸ í™˜ì‚°
            icon = "âœ…" if result == "win" else "âŒ"
            pnl_str = f"+{pnl:.2f}%" if pnl > 0 else f"{pnl:.2f}%"

            # ê²½ë¡œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
            signal_tag = str(row.get("signal_tag", "ê¸°ë³¸"))

            # ì§€í‘œë“¤ (ì†Œìˆ˜ì  ì •ë¦¬)
            buy_r = row.get("buy_ratio", 0) or 0
            turn = row.get("turn", 0) or 0
            imbal = row.get("imbalance", 0) or 0
            spread = row.get("spread", 0) or 0
            vol_surge = row.get("volume_surge", 0) or 0
            score = row.get("score", 0) or 0
            hold = row.get("hold_sec", 0) or 0

            # ğŸ”¥ ìƒˆ ì§€í‘œ
            cons_buys = row.get("consecutive_buys", 0) or 0
            avg_krw = row.get("avg_krw_per_tick", 0) or 0
            flow_accel = row.get("flow_acceleration", 1.0) or 1.0

            # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
            overheat = row.get("overheat", 0) or 0
            fresh_age = row.get("fresh_age", 0) or 0

            # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
            cv = row.get("cv", 0) or 0
            pstd = row.get("pstd", 0) or 0
            best_ask_krw = row.get("best_ask_krw", 0) or 0
            is_prebreak = row.get("is_prebreak", 0) or 0

            # ì‹œê°„ (tsì—ì„œ ì‹œ:ë¶„ë§Œ ì¶”ì¶œ)
            ts = str(row.get("ts", ""))
            time_str = ts[11:16] if len(ts) >= 16 else "?"

            # ê°€ì†ë„ ì´ëª¨ì§€
            accel_emoji = "ğŸš€" if flow_accel >= 1.5 else ("ğŸ“‰" if flow_accel <= 0.7 else "")

            # CV ì´ëª¨ì§€
            cv_emoji = "ğŸ¤–" if cv <= 0.45 else ("ğŸ”¥" if cv >= 1.2 else "")
            # Pre-break ë§ˆí¬
            pb_mark = "âš¡PB" if is_prebreak else ""

            # ğŸ” ì§„ì…ëª¨ë“œ + ì¶”ë§¤ + ì²­ì‚°ì‚¬ìœ 
            entry_mode = str(row.get("entry_mode", "confirm"))
            added_val = str(row.get("added", "0"))
            was_added = added_val == "1"
            exit_reason = str(row.get("exit_reason", "")).strip() or "ë¯¸ê¸°ë¡"

            # ì§„ì…ëª¨ë“œ ì´ëª¨ì§€ (probe+ì¶”ë§¤ = ìŠ¹ê²©)
            if entry_mode == "probe" and was_added:
                mode_str = "ğŸ”¬â†’âœ…ìŠ¹ê²©"  # probeì—ì„œ ì¶”ë§¤ë¡œ confirm ìŠ¹ê²©
            elif entry_mode == "probe":
                mode_str = "ğŸ”¬íƒìƒ‰"  # probe ì§„ì…, ì¶”ë§¤ ì—†ì´ ì²­ì‚°
            else:
                mode_str = "âœ…í™•ì •"  # ì²˜ìŒë¶€í„° confirm ì§„ì…

            lines.append(
                f"{icon} {market} {time_str} {pnl_str} {pb_mark}\n"
                f"   {mode_str} ê²½ë¡œ:{signal_tag}\n"
                f"   â¹ì²­ì‚°:{exit_reason}\n"
                f"   ë§¤ìˆ˜{buy_r:.0%} íšŒì „{turn:.1%} ì„ë°¸{imbal:.2f} ìŠ¤í”„{spread:.2f}%\n"
                f"   ë°°ìˆ˜{vol_surge:.1f}x ì—°ì†{cons_buys:.0f} ê°€ì†{flow_accel:.1f}x{accel_emoji}\n"
                f"   ğŸ“ˆCV{cv:.2f}{cv_emoji} pstd{pstd:.2f}%"
            )

        # ì„ê³„ì¹˜ íŒíŠ¸ (ìŠ¹ë¦¬/íŒ¨ë°° í‰ê·  ë¹„êµ)
        wins = df[df["result"] == "win"]
        loses = df[df["result"] == "lose"]

        if len(wins) >= 2 and len(loses) >= 2:
            lines.append("â”€" * 20)
            lines.append("<b>ğŸ’¡ ìŠ¹/íŒ¨ í‰ê·  ë¹„êµ:</b>")

            for col, name in [("buy_ratio", "ë§¤ìˆ˜ë¹„"), ("turn", "íšŒì „"), ("imbalance", "ì„ë°¸"),
                              ("spread", "ìŠ¤í”„ë ˆë“œ"), ("volume_surge", "ë°°ìˆ˜"),
                              ("consecutive_buys", "ì—°ì†ë§¤ìˆ˜"), ("flow_acceleration", "ê°€ì†ë„"),
                              ("overheat", "ê³¼ì—´"), ("fresh_age", "í‹±ë‚˜ì´"),
                              ("cv", "CV"), ("pstd", "pstd")]:
                if col in df.columns:
                    w_avg = wins[col].mean() if col in wins.columns else 0
                    l_avg = loses[col].mean() if col in loses.columns else 0
                    if pd.notna(w_avg) and pd.notna(l_avg):
                        diff = w_avg - l_avg
                        if col == "buy_ratio":
                            lines.append(f"  {name}: ìŠ¹{w_avg:.0%} / íŒ¨{l_avg:.0%} (ì°¨ì´ {diff:+.0%})")
                        elif col in ["turn", "spread"]:
                            lines.append(f"  {name}: ìŠ¹{w_avg:.1%} / íŒ¨{l_avg:.1%} (ì°¨ì´ {diff:+.1%})")
                        else:
                            lines.append(f"  {name}: ìŠ¹{w_avg:.2f} / íŒ¨{l_avg:.2f} (ì°¨ì´ {diff:+.2f})")

        return "\n".join(lines)

    except Exception as e:
        return f"ğŸ“‹ ìƒì„¸ ì˜¤ë¥˜: {e}"

def analyze_and_update_weights():
    """
    ğŸ”¥ 1ë‹¨ê³„ ê²Œì´íŠ¸ ì„ê³„ì¹˜ ìë™ ì¡°ì ˆ
    - ìŠ¹ë¦¬/íŒ¨ë°° ê·¸ë£¹ ê°„ í”¼ì²˜ ë¶„í¬ ë¶„ì„
    - GATE_* ì „ì—­ ë³€ìˆ˜ ì¡°ì ˆ
    """
    global GATE_TURN_MIN, GATE_TURN_MAX, GATE_SPREAD_MAX
    global GATE_ACCEL_MIN, GATE_ACCEL_MAX, GATE_BUY_RATIO_MIN
    global GATE_SURGE_MAX, GATE_IMBALANCE_MIN, GATE_OVERHEAT_MAX, GATE_FRESH_AGE_MAX
    global GATE_VOL_MIN, GATE_SURGE_MIN, GATE_PRICE_MIN

    if not os.path.exists(TRADE_LOG_PATH):
        print("[AUTO_LEARN] ê±°ë˜ ë¡œê·¸ ì—†ìŒ")
        return None

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)

        # ê²°ê³¼ê°€ ìˆëŠ” ê²ƒë§Œ
        df = df[df["result"].isin(["win", "lose"])]

        if len(df) < AUTO_LEARN_MIN_TRADES:
            print(f"[AUTO_LEARN] ë°ì´í„° ë¶€ì¡± ({len(df)}/{AUTO_LEARN_MIN_TRADES})")
            return None

        wins = df[df["result"] == "win"]
        loses = df[df["result"] == "lose"]

        if len(wins) < 5 or len(loses) < 5:
            print(f"[AUTO_LEARN] ìŠ¹/íŒ¨ ìƒ˜í”Œ ë¶€ì¡± (ìŠ¹:{len(wins)}, íŒ¨:{len(loses)})")
            return None

        win_rate = round(len(wins) / len(df) * 100, 1)

        # ìŠ¹/íŒ¨ í‰ê·  ê³„ì‚°
        stats = {}
        for col in ["buy_ratio", "spread", "turn", "imbalance", "volume_surge", "flow_acceleration", "overheat", "fresh_age"]:
            try:
                w_avg = pd.to_numeric(wins[col], errors='coerce').mean()
                l_avg = pd.to_numeric(loses[col], errors='coerce').mean()
                stats[col] = {"win": w_avg, "lose": l_avg}
            except:
                pass

        # ì¡°ì ˆ ë¡œì§ (10% ë¸”ë Œë”©, í•˜ë“œë°”ìš´ë“œ ì ìš©)
        BLEND = 0.10
        old_values = {
            "GATE_BUY_RATIO_MIN": GATE_BUY_RATIO_MIN,
            "GATE_SPREAD_MAX": GATE_SPREAD_MAX,
            "GATE_TURN_MIN": GATE_TURN_MIN,
            "GATE_IMBALANCE_MIN": GATE_IMBALANCE_MIN,
            "GATE_SURGE_MAX": GATE_SURGE_MAX,
            "GATE_ACCEL_MIN": GATE_ACCEL_MIN,
            "GATE_OVERHEAT_MAX": GATE_OVERHEAT_MAX,
            "GATE_FRESH_AGE_MAX": GATE_FRESH_AGE_MAX,
        }
        changes = {}

        # ë§¤ìˆ˜ë¹„: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥ (ë” ì—„ê²©)
        if "buy_ratio" in stats:
            w, l = stats["buy_ratio"]["win"], stats["buy_ratio"]["lose"]
            if w > l:  # ìŠ¹ìê°€ ë” ë†’ì€ ë§¤ìˆ˜ë¹„
                target = min(0.80, w * 0.95)  # ìŠ¹ì í‰ê· ì˜ 95%
                new_val = round(GATE_BUY_RATIO_MIN * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.55, min(0.80, new_val))  # ë°”ìš´ë“œ
                changes["GATE_BUY_RATIO_MIN"] = round(new_val - GATE_BUY_RATIO_MIN, 3)
                GATE_BUY_RATIO_MIN = new_val

        # ìŠ¤í”„ë ˆë“œ: ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "spread" in stats:
            w, l = stats["spread"]["win"], stats["spread"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë” ë‚®ì€ ìŠ¤í”„ë ˆë“œ
                target = max(0.08, w * 1.2)  # ìŠ¹ì í‰ê· ì˜ 120%
                new_val = round(GATE_SPREAD_MAX * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.08, min(0.35, new_val))  # ë°”ìš´ë“œ
                changes["GATE_SPREAD_MAX"] = round(new_val - GATE_SPREAD_MAX, 3)
                GATE_SPREAD_MAX = new_val

        # íšŒì „ìœ¨: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "turn" in stats:
            w, l = stats["turn"]["win"], stats["turn"]["lose"]
            if w > l:
                target = max(1.0, w * 0.8)
                new_val = round(GATE_TURN_MIN * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.0, min(10.0, new_val))
                changes["GATE_TURN_MIN"] = round(new_val - GATE_TURN_MIN, 2)
                GATE_TURN_MIN = new_val

        # ì„ë°¸ëŸ°ìŠ¤: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "imbalance" in stats:
            w, l = stats["imbalance"]["win"], stats["imbalance"]["lose"]
            if w > l:
                target = max(0.20, w * 0.9)
                new_val = round(GATE_IMBALANCE_MIN * (1 - BLEND) + target * BLEND, 3)
                new_val = max(0.15, min(0.50, new_val))
                changes["GATE_IMBALANCE_MIN"] = round(new_val - GATE_IMBALANCE_MIN, 3)
                GATE_IMBALANCE_MIN = new_val

        # ê¸‰ë“±: ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "volume_surge" in stats:
            w, l = stats["volume_surge"]["win"], stats["volume_surge"]["lose"]
            if w < l:
                target = max(1.5, w * 1.3)
                new_val = round(GATE_SURGE_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.5, min(6.0, new_val))
                changes["GATE_SURGE_MAX"] = round(new_val - GATE_SURGE_MAX, 2)
                GATE_SURGE_MAX = new_val

        # ê°€ì†ë„: ìŠ¹ì > íŒ¨ìë©´ ìƒí–¥
        if "flow_acceleration" in stats:
            w, l = stats["flow_acceleration"]["win"], stats["flow_acceleration"]["lose"]
            if w > l:
                target = max(0.3, w * 0.7)
                new_val = round(GATE_ACCEL_MIN * (1 - BLEND) + target * BLEND, 2)
                new_val = max(0.3, min(1.5, new_val))
                changes["GATE_ACCEL_MIN"] = round(new_val - GATE_ACCEL_MIN, 2)
                GATE_ACCEL_MIN = new_val

        # ê³¼ì—´(overheat): ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "overheat" in stats:
            w, l = stats["overheat"]["win"], stats["overheat"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë‚®ì€ ê³¼ì—´
                target = max(2.0, w * 1.3)  # ìŠ¹ì í‰ê· ì˜ 130%
                new_val = round(GATE_OVERHEAT_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(2.0, min(8.0, new_val))  # ë°”ìš´ë“œ
                changes["GATE_OVERHEAT_MAX"] = round(new_val - GATE_OVERHEAT_MAX, 2)
                GATE_OVERHEAT_MAX = new_val

        # í‹±ë‚˜ì´(fresh_age): ìŠ¹ì < íŒ¨ìë©´ í•˜í–¥ (ë” ì—„ê²©)
        if "fresh_age" in stats:
            w, l = stats["fresh_age"]["win"], stats["fresh_age"]["lose"]
            if w < l:  # ìŠ¹ìê°€ ë‚®ì€ í‹±ë‚˜ì´ (ë” ì‹ ì„ )
                target = max(1.0, w * 1.5)  # ìŠ¹ì í‰ê· ì˜ 150%
                new_val = round(GATE_FRESH_AGE_MAX * (1 - BLEND) + target * BLEND, 2)
                new_val = max(1.0, min(6.0, new_val))  # ë°”ìš´ë“œ
                changes["GATE_FRESH_AGE_MAX"] = round(new_val - GATE_FRESH_AGE_MAX, 2)
                GATE_FRESH_AGE_MAX = new_val

        new_values = {
            "GATE_BUY_RATIO_MIN": GATE_BUY_RATIO_MIN,
            "GATE_SPREAD_MAX": GATE_SPREAD_MAX,
            "GATE_TURN_MIN": GATE_TURN_MIN,
            "GATE_IMBALANCE_MIN": GATE_IMBALANCE_MIN,
            "GATE_SURGE_MAX": GATE_SURGE_MAX,
            "GATE_ACCEL_MIN": GATE_ACCEL_MIN,
            "GATE_OVERHEAT_MAX": GATE_OVERHEAT_MAX,
            "GATE_FRESH_AGE_MAX": GATE_FRESH_AGE_MAX,
            "GATE_VOL_MIN": GATE_VOL_MIN,
            "GATE_SURGE_MIN": GATE_SURGE_MIN,
            "GATE_PRICE_MIN": GATE_PRICE_MIN,
        }

        # ì €ì¥
        with open(WEIGHTS_PATH, "w", encoding="utf-8") as f:
            json.dump({
                "gate_thresholds": new_values,
                "updated_at": now_kst_str(),
                "sample_size": len(df),
                "win_rate": win_rate,
                "feature_stats": {k: {"win": round(v["win"], 3), "lose": round(v["lose"], 3)} for k, v in stats.items()}
            }, f, ensure_ascii=False, indent=2)

        print(f"[AUTO_LEARN] ê²Œì´íŠ¸ ì„ê³„ì¹˜ ì—…ë°ì´íŠ¸: {new_values}")
        print(f"[AUTO_LEARN] ìŠ¹ë¥ : {len(wins)}/{len(df)} = {win_rate}%")

        return {
            "thresholds": new_values,
            "old_values": old_values,
            "changes": changes,
            "win_rate": win_rate,
            "wins": len(wins),
            "loses": len(loses),
            "sample_size": len(df)
        }

    except ImportError:
        print("[AUTO_LEARN] pandas ë¯¸ì„¤ì¹˜ - ìˆ˜ë™ ë¶„ì„ í•„ìš”")
        return None
    except Exception as e:
        print(f"[AUTO_LEARN_ERR] {e}")
        import traceback
        traceback.print_exc()
        return None

# =========================
# ğŸ§  ë§¤ë„ íŒŒë¼ë¯¸í„° ìë™ íŠœë‹
# =========================
EXIT_PARAMS_PATH = os.path.join(os.getcwd(), "learned_exit_params.json")

# ğŸ”§ hard_stop ì œê±° â†’ ë™ì ì†ì ˆ(ATR)ë¡œ ëŒ€ì²´ (DYN_SL_MIN~DYN_SL_MAX)
DYNAMIC_EXIT_PARAMS = {}

# ë¶€ë¶„ì²­ì‚° í›„ ì¶”ê°€ ì†ì ˆ ì„¤ì •
PARTIAL_EXIT_PROFIT_DROP = 0.002   # ìµì ˆ ë¶€ë¶„ì²­ì‚° í›„ -0.2% ì¶”ê°€ í•˜ë½ ì‹œ ì²­ì‚°
PARTIAL_EXIT_LOSS_DROP = 0.001     # ì†ì ˆ ë¶€ë¶„ì²­ì‚° í›„ -0.1% ì¶”ê°€ í•˜ë½ ì‹œ ì²­ì‚°

# ğŸ”§ [í†µí•©ë¨] ì–‡ì€ìˆ˜ìµ/íŠ¸ë ˆì¼ë§/Plateau â†’ PROFIT_CHECKPOINT (ìƒë‹¨ ì •ì˜)
# THIN_PROFIT_CHECKPOINT, STRONG_TRAIL_DROP ì œê±°ë¨

# ğŸ”§ ì†Œí”„íŠ¸ ë³¸ì ˆ ê°€ë“œ (íœ©ì˜ ë°©ì§€)
BREAKEVEN_BOX = 0.0015           # Â±0.15% ë°•ìŠ¤ ë‚´ì—ì„œëŠ” ë³¸ì ˆ ì²­ì‚° ì–µì œ
SOFT_GUARD_SEC = 30              # ì´ˆê¸° 30ì´ˆê°„ ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ì¡°ê±´ ê°•í™”
CTX_THRESHOLD_BOOST = 1          # ì´ˆê¸° êµ¬ê°„ CTX ì„ê³„ê°’ ì¶”ê°€ë¶„

def is_strong_momentum(ticks, ob):
    """
    ì²´í¬í¬ì¸íŠ¸ ë„ë‹¬ ì‹œì ì— ê°•ì„¸ ì—¬ë¶€ íŒë‹¨ (ì ìˆ˜ ê¸°ë°˜)
    - ì•½ì„¸ ì ìˆ˜ 2ì  ì´ìƒì´ë©´ ì•½ì„¸ â†’ ì¦‰ì‹œ ë§¤ë„
    - ì•½ì„¸ ì ìˆ˜ 1ì  ì´í•˜ë©´ ê°•ì„¸ â†’ í™€ë”© (íŠ¸ë ˆì¼ë§ ëª¨ë“œ)
    """
    try:
        t15 = micro_tape_stats_from_ticks(ticks or [], 15)
        imb = calc_orderbook_imbalance(ob) if ob else 0.0
        fresh = uptick_streak_from_ticks(ticks, need=2) if ticks else False

        # ì•½ì„¸ ì ìˆ˜ ê³„ì‚° (0~4ì )
        weak_score = 0

        # 1) ë§¤ìˆ˜ë¹„ ë‚®ìŒ
        if t15["buy_ratio"] < 0.55:
            weak_score += 1

        # 2) ê±°ë˜ì†ë„ ë‘”í™”
        if t15["krw_per_sec"] < 15000:
            weak_score += 1

        # 3) í˜¸ê°€ ë§¤ë„ìš°ì„¸ (imbalance < -0.1)
        if imb < -0.1:
            weak_score += 1

        # 4) ìƒìŠ¹í‹± ëŠê¹€
        if not fresh:
            weak_score += 1

        # ì•½ì„¸ ì ìˆ˜ 2ì  ì´ìƒì´ë©´ ì•½ì„¸ íŒì • â†’ False ë°˜í™˜
        return weak_score < 2
    except:
        return False

def analyze_and_tune_exits():
    """
    ìµœê·¼ ê±°ë˜ ë¶„ì„ â†’ ë§¤ë„ íŒŒë¼ë¯¸í„° ìë™ íŠœë‹
    - ì†ì ˆì´ ë„ˆë¬´ ë§ìœ¼ë©´ â†’ ì†ì ˆ ê¸°ì¤€ ì™„í™”
    - ìµì ˆ í›„ ë” ì˜¬ëìœ¼ë©´ â†’ ìµì ˆ ê¸°ì¤€ ì™„í™”
    - ìµì ˆ í›„ ë” ë–¨ì–´ì¡Œìœ¼ë©´ â†’ ìµì ˆ ê¸°ì¤€ ìœ ì§€/ê°•í™”
    """
    global DYNAMIC_EXIT_PARAMS, DYN_SL_MAX  # ğŸ”§ DYN_SL_MAX ì „ì—­ ì„ ì–¸ ì¶”ê°€

    if not os.path.exists(TRADE_LOG_PATH):
        return None

    try:
        import pandas as pd
        df = pd.read_csv(TRADE_LOG_PATH)
        df = df[df["result"].isin(["win", "lose"])]

        if len(df) < 15:
            return None

        # ìµœê·¼ 20ê±´ë§Œ ë¶„ì„
        recent = df.tail(20)

        wins = len(recent[recent["result"] == "win"])
        loses = len(recent[recent["result"] == "lose"])
        win_rate = wins / len(recent)

        # í‰ê·  ì†ìµ
        avg_pnl = pd.to_numeric(recent["pnl_pct"], errors='coerce').mean()

        old_sl_max = DYN_SL_MAX

        # === íŠœë‹ ë¡œì§ (ìŠ¹ë¥  ê¸°ë°˜ ë™ì ì†ì ˆ ë¯¸ì„¸ ì¡°ì •) ===
        # ğŸ”§ FIX: í•˜í•œì„ DYN_SL_MINê³¼ ë™ê¸°í™” (ì—­ì „ ë°©ì§€)
        DYN_SL_BOUNDS = (DYN_SL_MIN, 0.006)  # DYN_SL_MIN ~ 0.6% ë²”ìœ„

        # ìŠ¹ë¥ ì— ë”°ë¼ ê·¹ë¯¸ì„¸ ì¡°ì • (0.0001 = 0.01% ë‹¨ìœ„)
        if win_rate < 0.40:
            # ìŠ¹ë¥  ë‚®ìŒ â†’ ì†ì ˆ ì‚´ì§ ì™„í™” (DYN_SL_MAX ì˜¬ë¦¬ê¸°)
            DYN_SL_MAX = min(DYN_SL_BOUNDS[1], DYN_SL_MAX + 0.0001)
        elif win_rate > 0.50:
            # ìŠ¹ë¥  ë†’ìŒ â†’ ì†ì ˆ ì‚´ì§ íƒ€ì´íŠ¸ (DYN_SL_MAX ë‚®ì¶”ê¸°)
            DYN_SL_MAX = max(DYN_SL_BOUNDS[0], DYN_SL_MAX - 0.0001)

        # ğŸ”§ ë¶ˆë³€ì‹ ë³´ì¥: MAXëŠ” í•­ìƒ MIN ì´ìƒ
        DYN_SL_MAX = max(DYN_SL_MAX, DYN_SL_MIN)

        DYNAMIC_EXIT_PARAMS["dyn_sl_max"] = DYN_SL_MAX

        # ì €ì¥
        with open(EXIT_PARAMS_PATH, "w", encoding="utf-8") as f:
            json.dump({
                "params": DYNAMIC_EXIT_PARAMS,
                "updated_at": now_kst_str(),
                "win_rate": round(win_rate * 100, 1),
                "avg_pnl": round(avg_pnl * 100, 3),
                "sample": len(recent)
            }, f, ensure_ascii=False, indent=2)

        return {
            "old_params": {"dyn_sl_max": old_sl_max},
            "new_params": DYNAMIC_EXIT_PARAMS,
            "win_rate": round(win_rate * 100, 1),
            "avg_pnl": round(avg_pnl * 100, 3)
        }

    except Exception as e:
        print(f"[EXIT_TUNE_ERR] {e}")
        return None

def load_exit_params():
    """ì €ì¥ëœ ë§¤ë„ íŒŒë¼ë¯¸í„° ë¡œë“œ"""
    global DYNAMIC_EXIT_PARAMS
    if os.path.exists(EXIT_PARAMS_PATH):
        try:
            with open(EXIT_PARAMS_PATH, "r", encoding="utf-8") as f:
                data = json.load(f)
            if "params" in data:
                DYNAMIC_EXIT_PARAMS.update(data["params"])
                print(f"[EXIT_PARAMS] ë¡œë“œ ì™„ë£Œ: ìŠ¹ë¥  {data.get('win_rate')}%, í‰ê· ì†ìµ {data.get('avg_pnl')}%")
        except Exception as e:
            print(f"[EXIT_PARAMS_LOAD_ERR] {e}")

def load_learned_weights():
    """
    ì €ì¥ëœ í•™ìŠµ íŒŒì¼ ë¡œë“œ
    - ê³¼ê±° ë²„ì „ í˜¸í™˜: "weights"ê°€ ìˆìœ¼ë©´ SCORE_WEIGHTS ì—…ë°ì´íŠ¸
    - í˜„í–‰: "gate_thresholds"ê°€ ìˆìœ¼ë©´ GATE_* ì„ê³„ì¹˜ ë³µì›
    """
    global SCORE_WEIGHTS
    global GATE_TURN_MIN, GATE_TURN_MAX, GATE_SPREAD_MAX
    global GATE_ACCEL_MIN, GATE_ACCEL_MAX, GATE_BUY_RATIO_MIN
    global GATE_SURGE_MAX, GATE_OVERHEAT_MAX, GATE_IMBALANCE_MIN, GATE_FRESH_AGE_MAX
    global GATE_VOL_MIN, GATE_SURGE_MIN, GATE_PRICE_MIN

    if not os.path.exists(WEIGHTS_PATH):
        print("[WEIGHTS] í•™ìŠµëœ íŒŒì¼ ì—†ìŒ - ê¸°ë³¸ê°’ ì‚¬ìš©")
        return

    try:
        with open(WEIGHTS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)

        # (êµ¬ë²„ì „ í˜¸í™˜) ìŠ¤ì½”ì–´ ê°€ì¤‘ì¹˜ê°€ ì €ì¥ë¼ ìˆìœ¼ë©´ ê°±ì‹ 
        if isinstance(data.get("weights"), dict):
            SCORE_WEIGHTS.update(data["weights"])
            print(f"[WEIGHTS] í•™ìŠµëœ ê°€ì¤‘ì¹˜ ë¡œë“œ: {SCORE_WEIGHTS}")

        # (í˜„í–‰) ê²Œì´íŠ¸ ì„ê³„ì¹˜ ë³µì›
        thr = data.get("gate_thresholds")
        if isinstance(thr, dict):
            GATE_TURN_MIN      = thr.get("GATE_TURN_MIN",      GATE_TURN_MIN)
            GATE_TURN_MAX      = thr.get("GATE_TURN_MAX",      GATE_TURN_MAX)
            GATE_SPREAD_MAX    = thr.get("GATE_SPREAD_MAX",    GATE_SPREAD_MAX)
            GATE_ACCEL_MIN     = thr.get("GATE_ACCEL_MIN",     GATE_ACCEL_MIN)
            GATE_ACCEL_MAX     = thr.get("GATE_ACCEL_MAX",     GATE_ACCEL_MAX)
            GATE_BUY_RATIO_MIN = thr.get("GATE_BUY_RATIO_MIN", GATE_BUY_RATIO_MIN)
            GATE_SURGE_MAX     = thr.get("GATE_SURGE_MAX",     GATE_SURGE_MAX)
            GATE_OVERHEAT_MAX  = thr.get("GATE_OVERHEAT_MAX",  GATE_OVERHEAT_MAX)
            GATE_IMBALANCE_MIN = thr.get("GATE_IMBALANCE_MIN", GATE_IMBALANCE_MIN)
            GATE_FRESH_AGE_MAX = thr.get("GATE_FRESH_AGE_MAX", GATE_FRESH_AGE_MAX)
            # ğŸ”§ ì•„ë˜ 3ê°œëŠ” ì½”ë“œ ê°’ ìš°ì„  ì‚¬ìš© (ì €ì¥ëœ íŒŒì¼ì—ì„œ ë¡œë“œ ì•ˆ í•¨)
            # GATE_VOL_MIN       = thr.get("GATE_VOL_MIN",       GATE_VOL_MIN)
            # GATE_SURGE_MIN     = thr.get("GATE_SURGE_MIN",     GATE_SURGE_MIN)
            # GATE_PRICE_MIN     = thr.get("GATE_PRICE_MIN",     GATE_PRICE_MIN)
            print(f"[WEIGHTS] ê²Œì´íŠ¸ ì„ê³„ì¹˜ ë¡œë“œ (VOL/PRICEëŠ” ì½”ë“œê°’ ìš°ì„ ): {thr}")

        print(f"[WEIGHTS] ì—…ë°ì´íŠ¸: {data.get('updated_at', '?')}, ìƒ˜í”Œ: {data.get('sample_size', '?')}, ìŠ¹ë¥ : {data.get('win_rate', '?')}%")
    except Exception as e:
        print(f"[WEIGHTS_LOAD_ERR] {e}")

# =========================
# ì„¸ì…˜/ìš”ì²­(ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”)
# =========================
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter


def _new_session():
    s = requests.Session()
    # ğŸ”§ urllib3 ë²„ì „ í˜¸í™˜ì„± (1.26+ = allowed_methods, êµ¬ë²„ì „ = method_whitelist)
    # ğŸ”§ FIX: POSTëŠ” ìë™ì¬ì‹œë„ ì œì™¸ (ì¤‘ë³µ ì£¼ë¬¸ ë°©ì§€)
    retry_kwargs = dict(
        total=3,
        backoff_factor=0.3,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    try:
        retry = Retry(allowed_methods=frozenset(["GET"]), **retry_kwargs)  # POST ì œê±°
    except TypeError:
        # urllib3 < 1.26 fallback
        retry = Retry(method_whitelist=frozenset(["GET"]), **retry_kwargs)  # POST ì œê±°
    adapter = HTTPAdapter(pool_connections=256,
                          pool_maxsize=256,
                          max_retries=retry)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({
        "Connection": "keep-alive",
        "User-Agent": "UpbitSniper/3.2.7-hh+...+netRetry"
    })
    return s


SESSION = _new_session()
KST = timezone(timedelta(hours=9))

def now_kst():
    return datetime.now(KST)

def now_kst_str():
    return now_kst().strftime("%Y-%m-%d %H:%M:%S KST")

# =========================
# ğŸ”¥ ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ê°„ê²©
# =========================
def get_scan_interval():
    """
    ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ì£¼ê¸°(ì´ˆ)
    - 09ì‹œëŒ€: 3ì´ˆ (ì´ˆë™ ë³€ë™ì„± ëŒ€ì‘)
    - 10~14ì‹œ: 5ì´ˆ
    - ê·¸ ì™¸: ê¸°ë³¸ 6ì´ˆ
    """
    h = now_kst().hour
    if h == 9:
        return 3
    elif 10 <= h <= 14:
        return 5
    else:
        return SCAN_INTERVAL  # ê¸°ë³¸ê°’(6ì´ˆ)

def link_for(m):
    return f"https://upbit.com/exchange?code=CRIX.UPBIT.{m}"


# í† í°ë²„í‚·
_BUCKET = {"tokens": 6.0, "last": time.time(), "cap": 6.0, "rate": 4.5}
_req_lock = threading.Lock()
REQ_STATS = {"ok": 0, "http429": 0, "http5xx": 0, "errors": 0, "conn_err": 0}
_CONSEC_CONN_ERR = 0


def _throttle():
    while True:
        with _req_lock:
            now = time.time()
            delta = now - _BUCKET["last"]
            _BUCKET["last"] = now
            rate = max(float(_BUCKET.get("rate", 0.0)), 0.1)
            cap = max(float(_BUCKET.get("cap", 1.0)), 1.0)
            tokens = min(cap, max(0.0, _BUCKET["tokens"] + delta * rate))
            if tokens >= 1.0:
                _BUCKET["tokens"] = tokens - 1.0
                return
            _BUCKET["tokens"] = tokens
            need = 1.0 - tokens
        base_wait = need / rate
        time.sleep(min(1.2, max(0.05, base_wait)) * (1.0 + 0.2 * rnd()))


def _refresh_session():
    global SESSION, _CONSEC_CONN_ERR
    try:
        SESSION.close()
    except Exception:
        pass
    SESSION = _new_session()
    _CONSEC_CONN_ERR = 0
    print("[NET] session refreshed")


def upbit_get(url, params=None, timeout=7):
    global _CONSEC_CONN_ERR
    for attempt in range(3):  # 4 -> 3 ìœ ì§€
        try:
            _throttle()
            r = SESSION.get(url, params=params, timeout=timeout)
            if r.status_code == 429:
                REQ_STATS["http429"] += 1
                # ì§€ìˆ˜ì  ë°±ì˜¤í”„ + ë²„í‚· ì†ë„ í•˜í–¥(ë³´ë‹¤ ê³µê²©ì ìœ¼ë¡œ)
                backoff = min(1.2 * (2**attempt), 6.0)
                time.sleep(backoff)
                # â†“ rateë¥¼ ë” ê°•í•˜ê²Œ ì¤„ì´ê³ , capë„ ì ê¹ ì¤„ì—¬ í­ì£¼ ì–µì œ
                _BUCKET["rate"] = max(3.0, _BUCKET["rate"] - 0.4)
                _BUCKET["cap"] = max(4.0, _BUCKET["cap"] - 0.5)
                continue
            if 500 <= r.status_code < 600:
                REQ_STATS["http5xx"] += 1
                time.sleep(0.35 * (2**attempt))
                continue
            r.raise_for_status()
            REQ_STATS["ok"] += 1
            _CONSEC_CONN_ERR = 0
            # âœ… 429 í›„ ì ì§„ íšŒë³µ (ì¥ê¸° ì„±ëŠ¥ ì €í•˜ ë°©ì§€)
            _BUCKET["rate"] = min(4.5, float(_BUCKET.get("rate", 3.0)) + 0.10)
            _BUCKET["cap"]  = min(6.0, float(_BUCKET.get("cap", 4.0)) + 0.10)
            return r.json()
        except requests.exceptions.Timeout:
            if attempt == 2: return None
            time.sleep(0.35 * (2**attempt))
        except requests.exceptions.ConnectionError:
            REQ_STATS["errors"] += 1
            REQ_STATS["conn_err"] += 1
            _CONSEC_CONN_ERR += 1
            if _CONSEC_CONN_ERR >= 3:
                _refresh_session()
                time.sleep(0.6)
            else:
                time.sleep(0.4 * (2**attempt))
            if attempt == 2: return None
        except Exception:
            REQ_STATS["errors"] += 1
            if attempt == 2: return None
            time.sleep(0.2 * (2**attempt))
    return None

# =========================================================
# ğŸ§© ì•ˆì „ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ë˜í¼ (ìë™ ì¬ì‹œë„ + ë°±ì˜¤í”„)
# =========================================================
def safe_upbit_get(url, params=None, timeout=6, retries=3, backoff=1.5):
    """
    ì—…ë¹„íŠ¸ API ìš”ì²­ìš© ì•ˆì „ ë˜í¼
    - ì¼ì‹œì  ì—°ê²° ì‹¤íŒ¨ë‚˜ 429 ì‘ë‹µì—ë„ ìë™ ì¬ì‹œë„
    - 3íšŒê¹Œì§€ ì¬ì‹œë„ (1.5ì´ˆì”© ì¦ê°€í•˜ëŠ” ëŒ€ê¸°)
    """
    for i in range(retries):
        try:
            js = upbit_get(url, params, timeout=timeout)
            if js:
                return js
        except Exception as e:
            print(f"[SAFE_GET] {url.split('/')[-1]} ì‹¤íŒ¨ ({e}) â†’ ì¬ì‹œë„ {i+1}/{retries}")
        time.sleep(backoff * (i + 1))
    print(f"[SAFE_GET_FAIL] {url.split('/')[-1]} ìµœì¢… ì‹¤íŒ¨")
    return None

def req_summary():
    print(
        f"[REQ] ok:{REQ_STATS['ok']}  429:{REQ_STATS['http429']}  5xx:{REQ_STATS['http5xx']}  err:{REQ_STATS['errors']}"
    )


def aligned_sleep(interval):
    t = time.time()
    nxt = math.ceil(t / interval) * interval
    time.sleep(max(0, nxt - t))


# =========================
# ì§€í‘œ ìœ í‹¸
# =========================
def vwap_from_candles_1m(c1, n=20):
    seg = c1[-n:] if len(c1) >= n else c1[:]
    pv = sum(x["trade_price"] * x["candle_acc_trade_volume"] for x in seg)
    vol = sum(x["candle_acc_trade_volume"] for x in seg)
    return pv / max(vol, 1e-12)


def zscore_krw_1m(c1, win=30):
    seg = c1[-win:] if len(c1) >= win else c1[:]
    arr = [x["candle_acc_trade_price"] for x in seg]
    if len(arr) < 3: return 0.0
    m = sum(arr) / len(arr)
    sd = (sum((a - m)**2 for a in arr) / max(len(arr) - 1, 1))**0.5
    return (arr[-1] - m) / max(sd, 1e-9)


def uptick_streak_from_ticks(ticks, need=2):
    t = sorted(ticks[:need + 4], key=lambda x: x.get("timestamp", 0))
    return sum(1 for a, b in zip(t, t[1:])
               if b.get("trade_price", 0) > a.get("trade_price", 0)) >= need


def last_two_ticks_fresh(ticks, max_age=None, return_age=False):
    """
    í‹± ì‹ ì„ ë„ ì²´í¬ - GATE_FRESH_AGE_MAX ì „ì—­ ë³€ìˆ˜ ì‚¬ìš©

    return_age=True: (bool, max_tick_age, effective_max_age) ë°˜í™˜
    return_age=False: boolë§Œ ë°˜í™˜ (ê¸°ì¡´ í˜¸í™˜)
    """
    if max_age is None:
        max_age = GATE_FRESH_AGE_MAX
    if len(ticks) < 2:
        if return_age:
            return False, 999.0, max_age
        return False
    h = now_kst().hour
    if 0 <= h < 6:
        max_age = max_age + 0.8
    now = int(time.time() * 1000)
    # ìµœê·¼ 2í‹± ì¤‘ ê°€ì¥ ì˜¤ë˜ëœ í‹±ì˜ ë‚˜ì´ ê³„ì‚°
    tick_ages = [(now - x.get("timestamp", 0)) / 1000.0 for x in ticks[:2]]
    max_tick_age = max(tick_ages) if tick_ages else 999.0
    is_fresh = all(age <= max_age for age in tick_ages)

    if return_age:
        return is_fresh, max_tick_age, max_age
    return is_fresh


def body_ratio(c):
    try:
        return max((c["trade_price"] - c["opening_price"]) /
                   max(c["opening_price"], 1), 0)
    except:
        return 0


# ---- 5ë¶„ ì»¨í…ìŠ¤íŠ¸: LRU ìºì‹œ ----
class LRUCache:

    def __init__(self, maxsize=100):
        self.cache = OrderedDict()
        self.maxsize = maxsize
        self.lock = threading.Lock()

    def get(self, key):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
                return self.cache[key]
            return None

    def set(self, key, value):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.maxsize:
                self.cache.popitem(last=False)

    def clear(self):
        with self.lock:
            self.cache.clear()

    def purge_older_than(self, max_age_sec=3.0):
        cutoff = int(time.time() * 1000) - int(max_age_sec * 1000)
        with self.lock:
            drop = [
                k for k, v in self.cache.items()
                if isinstance(v, dict) and v.get("ts", 0) < cutoff
            ]
            for k in drop:
                self.cache.pop(k, None)


_TICKS_CACHE = LRUCache(maxsize=100)
_TICKS_TTL = 4.5
_C5_CACHE = LRUCache(maxsize=300)


def five_min_context_ok(m):
    if not USE_5M_CONTEXT:
        return True
    hit = _C5_CACHE.get(m)
    if hit and (time.time() - hit.get("ts", 0) <= 3.0):
        c5 = hit["c"]
    else:
        c5 = get_minutes_candles(5, m, 6)
        _C5_CACHE.set(m, {"ts": time.time(), "c": c5})
    if len(c5) < 4:
        return True
    try:
        close = [c["trade_price"] for c in c5]
        slope3 = close[-1] - close[-3]
        recent_break = c5[-1]["high_price"] > max(x["high_price"]
                                                  for x in c5[-4:-1])
        return (slope3 > 0) or recent_break
    except:
        return True

def get_dynamic_thresholds():
    h = now_kst().hour
    if 0 <= h < 6:
        return {
            "zscore": 0.90,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0008,
            "uptick": 2,
            "min_change": 0.0004,  # ê¸°ì¡´ 0.0005
            "bidask_min": 1.06
        }
    elif 6 <= h < 12:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0006,  # ê¸°ì¡´ 0.0007
            "bidask_min": 1.07
        }
    elif 12 <= h < 18:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,    # ê¸°ì¡´ 0.0010
            "uptick": 2,
            "min_change": 0.0008,  # ê¸°ì¡´ 0.0010
            "bidask_min": 1.075    # ì‚´ì§ ì™„í™”
        }
    else:
        return {
            "zscore": 0.92,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0007,
            "bidask_min": 1.07
        }

# =========================
# â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
# =========================
def relax_knob():
    """
    0.0 ~ 1.5 ìŠ¤ì¼€ì¼.
    + BTC 5ë¶„ ìˆ˜ìµ > 0.6%ë©´ +1.0, > 0.3%ë©´ +0.5
    + ì•¼ê°„(00~06h)ë©´ +0.5
    """
    try:
        b5 = btc_5m_change()
    except:
        b5 = 0.0
    h = now_kst().hour
    f = 0.0
    if b5 >= 0.006: f += 1.0
    elif b5 >= 0.003: f += 0.5
    if 0 <= h < 6: f += 0.5
    return min(1.5, f)


# =========================
# ë°ì´í„° ìˆ˜ì§‘/ìºì‹œ
# =========================
MKTS_CACHE_TTL = 90
_MKTS_CACHE = {"ts": 0.0, "mkts": []}


def get_top_krw_by_24h(n=TOP_N):
    now = time.time()
    if _MKTS_CACHE["mkts"] and (now - _MKTS_CACHE["ts"] <= MKTS_CACHE_TTL):
        mkts = _MKTS_CACHE["mkts"]
    else:
        allm = [
            d["market"]
            for d in upbit_get("https://api.upbit.com/v1/market/all") or []
            if d["market"].startswith("KRW-")
        ]
        acc = []
        for i in range(0, len(allm), 50):
            info = upbit_get("https://api.upbit.com/v1/ticker",
                             {"markets": ",".join(allm[i:i + 50])})
            if not info: continue
            for t in info:
                v = t.get("acc_trade_price_24h", 0)
                if v > 0: acc.append((t["market"], v))
        acc.sort(key=lambda x: x[1], reverse=True)
        mkts = [m for m, _ in acc]
        _MKTS_CACHE["mkts"] = mkts
        _MKTS_CACHE["ts"] = now
    return mkts[:n]


def get_minutes_candles(u, m, c):
    js = upbit_get(f"https://api.upbit.com/v1/candles/minutes/{u}", {
        "market": m,
        "count": c
    },
                   timeout=6)
    return list(reversed(js)) if js else []

def get_recent_ticks(m, c=100, allow_network=True):
    now_ms = int(time.time() * 1000)
    hit = _TICKS_CACHE.get(m)
    if hit and (now_ms - hit["ts"] <= _TICKS_TTL * 1000):
        return hit["ticks"]
    if not allow_network:
        return hit["ticks"] if hit else []

    # âœ… ì•ˆì „ ë˜í¼ë¡œ ë³€ê²½
    js = safe_upbit_get("https://api.upbit.com/v1/trades/ticks", {
        "market": m,
        "count": c
    },
                        timeout=6)

    if not js or not isinstance(js, list):
        return hit["ticks"] if hit else []
    js_sorted = sorted(js, key=lambda t: t.get("timestamp", 0), reverse=True)
    _TICKS_CACHE.set(m, {"ts": now_ms, "ticks": js_sorted})
    return js_sorted

def micro_tape_stats_from_ticks(ticks, sec):
    if not ticks:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    n = 0
    krw = 0.0
    buys = 0
    oldest_ts = newest_ts
    for x in ticks:
        ts = x.get("timestamp", 0)
        if ts < cutoff:
            break
        p = x.get("trade_price", 0.0)
        v = x.get("trade_volume", 0.0)
        krw += p * v
        n += 1
        if x.get("ask_bid") == "BID": buys += 1
        if ts < oldest_ts: oldest_ts = ts

    if n == 0:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    now_ms = int(time.time() * 1000)
    age = (now_ms - newest_ts) / 1000.0 if newest_ts else 999
    duration = max((newest_ts - (oldest_ts or newest_ts)) / 1000.0, 1.0)
    rate = n / duration
    krw_per_sec = krw / duration
    return {
        "krw": krw,
        "n": n,
        "buy_ratio": buys / n,
        "age": age,
        "rate": rate,
        "krw_per_sec": krw_per_sec
    }


def calc_consecutive_buys(ticks, sec=15):
    """
    ì²´ê²°ê°•ë„: ìµœê·¼ Nì´ˆ ë‚´ ì—°ì† ë§¤ìˆ˜ ì²´ê²° ìµœëŒ€ íšŸìˆ˜
    â†’ 5ê°œ ì´ìƒ ì—°ì† ë§¤ìˆ˜ = ê°•í•œ ì‹ í˜¸
    """
    if not ticks:
        return 0
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return 0

    max_streak = 0
    current_streak = 0
    for x in ticks:
        if x.get("timestamp", 0) < cutoff:
            break
        if x.get("ask_bid") == "BID":
            current_streak += 1
            max_streak = max(max_streak, current_streak)
        else:
            current_streak = 0
    return max_streak


def calc_avg_krw_per_tick(t_stats):
    """
    í‹±ë‹¹ í‰ê· ê¸ˆì•¡: ì´ ê±°ë˜ëŒ€ê¸ˆ / í‹±ìˆ˜
    â†’ ë†’ì„ìˆ˜ë¡ ëŒ€í˜• ì²´ê²° (ê³ ë˜ ê°€ëŠ¥ì„±)
    """
    if not t_stats or t_stats.get("n", 0) == 0:
        return 0
    return t_stats["krw"] / t_stats["n"]


def calc_flow_acceleration(ticks):
    """
    ì²´ê²° ê°€ì†ë„: t5s / t15s ë¹„ìœ¨
    â†’ 1.5 ì´ìƒ = ê°€ì† ì¤‘, 0.7 ì´í•˜ = ê°ì† ì¤‘
    """
    if not ticks:
        return 1.0
    t5s = micro_tape_stats_from_ticks(ticks, 5)
    t15s = micro_tape_stats_from_ticks(ticks, 15)

    if t15s["krw_per_sec"] <= 0:
        return 1.0
    return t5s["krw_per_sec"] / t15s["krw_per_sec"]


# ========================================
# ğŸš€ ëŸ¬ë‹ 1ë¶„ë´‰ (Running 1m Bar) - ì¢…ê°€ í™•ì • ì „ ì‹¤ì‹œê°„ ê³„ì‚°
# ========================================
def running_1m_bar(ticks, last_candle=None):
    """
    í‹± ë°ì´í„°ë¡œ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ 1ë¶„ë´‰ì„ ì‹¤ì‹œê°„ ê³„ì‚°
    - ì¢…ê°€ í™•ì • ì „ì—ë„ í˜„ì¬ ê°€ê²©/ê±°ë˜ëŸ‰/ë³€ë™í­ íŒŒì•… ê°€ëŠ¥
    - last_candleì´ ìˆìœ¼ë©´ ì´ì „ ë´‰ ê¸°ì¤€ìœ¼ë¡œ ë³€ë™ë¥  ê³„ì‚°

    Returns: {
        'open': ì‹œê°€,
        'high': ê³ ê°€,
        'low': ì €ê°€,
        'close': í˜„ì¬ê°€ (ì§„í–‰ ì¤‘),
        'volume_krw': ê±°ë˜ëŒ€ê¸ˆ,
        'tick_count': í‹± ìˆ˜,
        'buy_ratio': ë§¤ìˆ˜ ë¹„ìœ¨,
        'change_from_prev': ì´ì „ë´‰ ëŒ€ë¹„ ë³€ë™ë¥ ,
        'range_pct': ì§„í–‰ ì¤‘ ë´‰ì˜ ë³€ë™í­ (high-low)/low
    }
    """
    if not ticks:
        return None

    now_ms = int(time.time() * 1000)
    minute_start = (now_ms // 60000) * 60000  # í˜„ì¬ ë¶„ì˜ ì‹œì‘ ì‹œì 

    # í˜„ì¬ ë¶„ ë‚´ì˜ í‹±ë§Œ í•„í„°
    current_ticks = [t for t in ticks if t.get("timestamp", 0) >= minute_start]

    if not current_ticks:
        # í˜„ì¬ ë¶„ í‹±ì´ ì—†ìœ¼ë©´ ìµœê·¼ 10ì´ˆ í‹±ìœ¼ë¡œ ëŒ€ì²´
        fallback_cutoff = now_ms - 10000
        current_ticks = [t for t in ticks if t.get("timestamp", 0) >= fallback_cutoff]
        if not current_ticks:
            return None

    prices = [t.get("trade_price", 0) for t in current_ticks if t.get("trade_price", 0) > 0]
    if not prices:
        return None

    # OHLC ê³„ì‚° (í‹±ì€ ìµœì‹ ìˆœ ì •ë ¬ì´ë¯€ë¡œ reverse í•„ìš”)
    prices_chrono = list(reversed(prices))  # ì‹œê°„ìˆœ ì •ë ¬
    open_price = prices_chrono[0]
    high_price = max(prices)
    low_price = min(prices)
    close_price = prices_chrono[-1]  # ê°€ì¥ ìµœê·¼ ê°€ê²©

    # ê±°ë˜ëŒ€ê¸ˆ/ë§¤ìˆ˜ë¹„
    volume_krw = sum(t.get("trade_price", 0) * t.get("trade_volume", 0) for t in current_ticks)
    buys = sum(1 for t in current_ticks if t.get("ask_bid") == "BID")
    buy_ratio = buys / len(current_ticks) if current_ticks else 0

    # ì´ì „ë´‰ ëŒ€ë¹„ ë³€ë™ë¥ 
    change_from_prev = 0.0
    if last_candle and last_candle.get("trade_price", 0) > 0:
        change_from_prev = close_price / last_candle["trade_price"] - 1

    # ì§„í–‰ ì¤‘ ë´‰ì˜ ë³€ë™í­
    range_pct = (high_price - low_price) / low_price if low_price > 0 else 0

    return {
        "open": open_price,
        "high": high_price,
        "low": low_price,
        "close": close_price,
        "volume_krw": volume_krw,
        "tick_count": len(current_ticks),
        "buy_ratio": buy_ratio,
        "change_from_prev": change_from_prev,
        "range_pct": range_pct,
    }


# ========================================
# ğŸš€ Pre-break ë™ì  ëŒ€ì—­ (ë³€ë™ì„± ê¸°ë°˜)
# ========================================
_PREBREAK_SUSPEND_UNTIL = 0.0  # ì—°íŒ¨ ì‹œ ì¼ì‹œ ì¤‘ì§€ íƒ€ì„ìŠ¤íƒ¬í”„

def dynamic_prebreak_band(ticks):
    """
    ë¶„ìœ„ê¸°(ê°€ê²©ë°´ë“œ í‘œì¤€í¸ì°¨, ì•¼ê°„ ì™„í™”)ì— ë”°ë¼ ê³ ì  ê·¼ì ‘ í—ˆìš©í­ ìë™ ì¡°ì ˆ
    - ê¸‰ë“±/íœ©ì˜ ì¥ë©´ì—ì„  ë” íƒ€ì´íŠ¸
    - ì¡°ìš©í•˜ë©´ ì‚´ì§ ê´€ëŒ€
    """
    # 10ì´ˆ ê°€ê²©ë°´ë“œ í‘œì¤€í¸ì°¨
    pstd = price_band_std(ticks, sec=10) if ticks else 0.0
    # ê¸°ë³¸ 0.20% Â± pstd*40% (ìƒí•œ 0.35%)
    base = PREBREAK_HIGH_PCT  # 0.002
    band = min(0.0035, base + pstd * 0.40)
    # ì•¼ê°„ ì‚´ì§ ì™„í™”
    if 0 <= now_kst().hour < 6:
        band = min(0.0038, band + 0.0004)
    return band


# ========================================
# ğŸš€ Pre-break Probe ì²´í¬ (ê³ ì  ê·¼ì²˜ ì„ í–‰ ì§„ì…)
# ========================================
def prebreak_probe_check(ticks, candles, ob, tape_stats):
    """
    Pre-break ì¡°ê±´ ì²´í¬:
    1. í˜„ì¬ê°€ê°€ ìµœê·¼ Në´‰ ê³ ì ì˜ ë™ì  ëŒ€ì—­ ì´ë‚´
    2. í…Œì´í”„ ì¡°ê±´ (ë§¤ìˆ˜ë¹„, ê±°ë˜ì†ë„) ì¶©ì¡±
    3. í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ë§¤ìˆ˜ ìš°ìœ„

    Returns: (is_prebreak, reason, running_bar)
    """
    # ğŸ”§ ì—°íŒ¨ ì‹œ Pre-break ì¼ì‹œ ì¤‘ì§€
    if time.time() < _PREBREAK_SUSPEND_UNTIL:
        return False, "prebreak_suspended(lose_streak)", None

    if not PREBREAK_ENABLED:
        return False, "prebreak_disabled", None

    if not ticks or not candles or len(candles) < 5:
        return False, "insufficient_data", None

    # ëŸ¬ë‹ 1ë¶„ë´‰ ê³„ì‚°
    last_candle = candles[-1] if candles else None
    running = running_1m_bar(ticks, last_candle)
    if not running:
        return False, "no_running_bar", None

    current_price = running["close"]

    # ìµœê·¼ 12ë´‰ ê³ ì  (ì•½ 12ë¶„)
    lookback = min(12, len(candles))
    recent_high = max(c.get("high_price", c.get("trade_price", 0)) for c in candles[-lookback:])

    # í˜„ì¬ ëŸ¬ë‹ë°” ê³ ì ë„ í¬í•¨
    recent_high = max(recent_high, running["high"])

    # ê³ ì  ëŒ€ë¹„ ê±°ë¦¬ ê³„ì‚°
    dist_from_high = (recent_high - current_price) / recent_high if recent_high > 0 else 1.0

    # ğŸ”§ ì¡°ê±´ 1: ë™ì  ëŒ€ì—­ ì‚¬ìš© (ë³€ë™ì„± ê¸°ë°˜)
    dyn_band = dynamic_prebreak_band(ticks)
    if dist_from_high > dyn_band:
        return False, f"not_near_high({dist_from_high*100:.2f}%>{dyn_band*100:.2f}%)", running

    # ì¡°ê±´ 2: í…Œì´í”„ ì¡°ê±´
    if not tape_stats:
        return False, "no_tape", running

    buy_ratio = tape_stats.get("buy_ratio", 0)
    krw_per_sec = tape_stats.get("krw_per_sec", 0)

    if buy_ratio < PREBREAK_BUY_MIN:
        return False, f"low_buy_ratio({buy_ratio:.0%}<{PREBREAK_BUY_MIN:.0%})", running

    if krw_per_sec < PREBREAK_KRW_PER_SEC_MIN:
        return False, f"low_flow({krw_per_sec/1000:.0f}K<{PREBREAK_KRW_PER_SEC_MIN/1000:.0f}K)", running

    # ì¡°ê±´ 3: í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤
    if ob:
        imbalance = calc_orderbook_imbalance(ob)
        if imbalance < PREBREAK_IMBALANCE_MIN:
            return False, f"weak_imbalance({imbalance:.2f}<{PREBREAK_IMBALANCE_MIN:.2f})", running

    # ëª¨ë“  ì¡°ê±´ ì¶©ì¡±: Pre-break íŠ¸ë¦¬ê±°
    return True, f"prebreak_ok(dist={dist_from_high*100:.2f}%,buy={buy_ratio:.0%},flow={krw_per_sec/1000:.0f}K)", running


# ===== Bot Heuristics =====
def _pct(a, b):
    try:
        return abs(a / b - 1.0)
    except:
        return 0.0


def inter_arrival_stats(ticks, sec=30):
    if not ticks: return {"cv": 9.9, "count": 0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"cv": 9.9, "count": 0}
    cutoff = newest_ts - sec * 1000
    ts = [x["timestamp"] for x in ticks if x["timestamp"] >= cutoff]
    ts = sorted(ts)
    if len(ts) < 4: return {"cv": 9.9, "count": len(ts)}
    gaps = [(b - a) / 1000.0 for a, b in zip(ts, ts[1:])]
    mu = sum(gaps) / len(gaps)
    if mu <= 0: return {"cv": 9.9, "count": len(ts)}
    var = sum((g - mu)**2 for g in gaps) / len(gaps)
    cv = (var**0.5) / mu
    return {"cv": cv, "count": len(ts)}


def price_band_std(ticks, sec=30):
    if not ticks: return 9.9
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 9.9
    cutoff = newest_ts - sec * 1000
    ps = [x["trade_price"] for x in ticks if x["timestamp"] >= cutoff]
    if len(ps) < 3: return 9.9
    m = sum(ps) / len(ps)
    var = sum((p - m)**2 for p in ps) / len(ps)
    std = (var**0.5) / max(m, 1)
    return std


def bot_pingpong_score(ticks, sec=20, band=BOT_PINGPONG_MAX_BAND):
    if not ticks: return 0.0
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 0.0
    cutoff = newest_ts - sec * 1000
    win = [x for x in reversed(ticks) if x["timestamp"] >= cutoff]
    if len(win) < 6: return 0.0
    prices = [x["trade_price"] for x in win]
    pr_min, pr_max = min(prices), max(prices)
    if _pct(pr_max, pr_min) > band:
        return 0.0
    alt = sum(1 for a, b in zip(win, win[1:])
              if a["ask_bid"] != b["ask_bid"]) / max(len(win) - 1, 1)
    return alt


def wash_trade_pattern(ticks, sec=30, repeats=BOT_WASH_REPEAT_VOL_N):
    if not ticks: return False
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return False
    cutoff = newest_ts - sec * 1000
    vols = {}
    for x in ticks:
        if x["timestamp"] < cutoff: break
        v = round(x["trade_volume"], 6)
        vols[v] = vols.get(v, 0) + 1
    if not vols: return False
    top = max(vols.values())
    return top >= repeats


def bot_accum_trigger_ok(m, ticks, ob, c1):
    if not ticks or not ob or not c1: return (False, "BOTACC_INIT_FAIL")
    t30 = micro_tape_stats_from_ticks(ticks, 30)
    if not (BOT_ACCUM_MIN_BUY <= t30["buy_ratio"] <= BOT_ACCUM_MAX_BUY):
        return (False, "BOTACC_BUY_RANGE")
    ia = inter_arrival_stats(ticks, 30)
    if ia["cv"] > BOT_TWAP_MAX_CV or ia["count"] < 6:
        return (False, "BOTACC_CV_LOWCOUNT")
    if price_band_std(ticks, 30) > BOT_TWAP_MAX_PSTD:
        return (False, "BOTACC_PSTD")
    if not uptick_streak_from_ticks(ticks, need=2):
        return (False, "BOTACC_NO_UPTICK")
    try:
        raw = ob["raw"]["orderbook_units"][:3]
        bid = sum(u["bid_price"] * u["bid_size"] for u in raw)
        ask = sum(u["ask_price"] * u["ask_size"] for u in raw)
        if bid / max(ask, 1) < 1.10:
            return (False, "BOTACC_BIDASK_WEAK")
    except:
        pass
    cur = c1[-1]
    if cur["trade_price"] <= cur["opening_price"]:
        return (False, "BOTACC_NOT_GREEN")
    return (True, "BOTACC_OK")


def _win_stats(ticks, start_s, end_s):
    if not ticks:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    lo = newest_ts - end_s * 1000
    hi = newest_ts - start_s * 1000
    win = [x for x in ticks if lo <= x.get("timestamp", 0) <= hi]
    if len(win) < 2:
        return {
            "n": len(win),
            "buy_ratio": 0.0,
            "rate": 0.0,
            "krw_per_sec": 0.0
        }
    win = sorted(win, key=lambda t: t["timestamp"])
    dur = max((win[-1]["timestamp"] - win[0]["timestamp"]) / 1000.0, 1.0)
    buys = sum(1 for x in win if x.get("ask_bid") == "BID")
    krw = sum(x["trade_price"] * x["trade_volume"] for x in win)
    return {
        "n": len(win),
        "buy_ratio": buys / max(len(win), 1),
        "rate": len(win) / dur,
        "krw_per_sec": krw / dur
    }


def buy_decay_flag(ticks):
    early = _win_stats(ticks, start_s=10, end_s=20)
    now = _win_stats(ticks, start_s=0, end_s=5)
    if early["n"] < 4 or now["n"] < 2:
        return False, {"early": early, "now": now}
    drop_buy = early["buy_ratio"] - now["buy_ratio"]
    cond = (drop_buy >= 0.12 and now["rate"] <= early["rate"] * 0.80
            and now["krw_per_sec"] <= early["krw_per_sec"] * 0.70)
    return cond, {"early": early, "now": now, "drop_buy": drop_buy}


# =========================
# ì‹œì¥ í•„í„°
# =========================
def btc_5m_change():
    c = get_minutes_candles(5, "KRW-BTC", 3)
    if len(c) < 2: return 0.0
    return c[-1]["trade_price"] / max(c[-2]["trade_price"], 1) - 1

# =========================
# ë³´ì¡°: ìº”ë“¤/ATR/EMA
# =========================
def wick_body_ratio(c):
    try:
        rng = c["high_price"] - c["low_price"]
        body = abs(c["trade_price"] - c["opening_price"])
        if rng <= 0: return 1.0
        return body / rng
    except:
        return 1.0


def ema_series(vals, period):
    if not vals: return []
    k = 2 / (period + 1)
    out = []
    ema = vals[0]
    for v in vals:
        ema = v * k + ema * (1 - k)
        out.append(ema)
    return out


def ema_last(vals, period):
    if len(vals) == 0: return None
    return ema_series(vals, period)[-1]


def vol_ma_from_candles(candles, period=20):
    """ìµœê·¼ Në´‰ ê±°ë˜ëŸ‰ í‰ê·  (ê±°ë˜ëŒ€ê¸ˆ ê¸°ì¤€)"""
    if len(candles) < period:
        return 0
    vols = [c.get("candle_acc_trade_price", 0) for c in candles[-period:]]
    return sum(vols) / len(vols) if vols else 0


def prev_high_from_candles(candles, lookback=12, skip_recent=1):
    """ìµœê·¼ Në´‰ ì¤‘ ê³ ì  (ìµœê·¼ skip_recentë´‰ ì œì™¸)"""
    if len(candles) < lookback + skip_recent:
        return 0
    subset = candles[-(lookback + skip_recent):-skip_recent] if skip_recent > 0 else candles[-lookback:]
    if not subset:
        return 0
    return max(c.get("high_price", 0) for c in subset)


# ========================================
# ğŸ”¥ ì í™” ê°ì§€ (Ignition Detection) - ê¸‰ë“± ì´ˆì… 0~30ì´ˆ ë‚´ ê°ì§€
# ========================================
def update_baseline_tps(market: str, ticks, window_sec: int = 300):
    """
    í‰ì‹œ í‹±/ì´ˆ (baseline TPS) ì—…ë°ì´íŠ¸
    - ìµœê·¼ 5ë¶„ê°„ í‹± ë°ì´í„°ë¡œ í‰ê·  ticks-per-second ê³„ì‚°
    - ì í™” ê°ì§€ì˜ ìƒëŒ€ ì„ê³„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©
    """
    if not ticks or len(ticks) < 10:
        return

    now_ts = ticks[0].get("timestamp", ticks[0].get("ts", 0))
    cutoff = now_ts - (window_sec * 1000)

    # window_sec ë‚´ì˜ í‹±ë§Œ í•„í„°
    window_ticks = [t for t in ticks if t.get("timestamp", t.get("ts", 0)) >= cutoff]

    if len(window_ticks) < 5:
        return

    # í‹± ìˆ˜ / ì‹œê°„(ì´ˆ) = TPS
    first_ts = window_ticks[-1].get("timestamp", window_ticks[-1].get("ts", 0))
    last_ts = window_ticks[0].get("timestamp", window_ticks[0].get("ts", 0))
    duration_sec = max((last_ts - first_ts) / 1000, 1)

    tps = len(window_ticks) / duration_sec

    with _IGNITION_LOCK:
        # ì§€ìˆ˜ì´ë™í‰ê· ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ì—…ë°ì´íŠ¸
        old_tps = _IGNITION_BASELINE_TPS.get(market, tps)
        _IGNITION_BASELINE_TPS[market] = old_tps * 0.8 + tps * 0.2


def ignition_detected(
    market: str,
    ticks,
    avg_candle_volume: float,
    ob=None,
    cooldown_ms: int = 10000
) -> tuple:
    """
    ì í™” ê°ì§€: ê¸‰ë“± ì‹œì‘ 0~30ì´ˆ ë‚´ ê°ì§€

    4ìš”ê±´ ì¤‘ 3ê°œ ì¶©ì¡± ì‹œ ì í™”:
    1. í‹± í­ì£¼: ìµœê·¼ 10ì´ˆ í‹±ìˆ˜ >= í‰ì‹œì˜ 3ë°°
    2. ì—°ì† ë§¤ìˆ˜: 10ì´ˆ ë‚´ 5íšŒ ì´ìƒ ì—°ì† ë§¤ìˆ˜
    3. ê°€ê²© ì„í„ìŠ¤: 0.3% ì´ìƒ ìƒìŠ¹ + ìµœê·¼ 6í‹± ë‹¨ì¡°ì¦ê°€
    4. ê±°ë˜ëŸ‰ í­ë°œ: 10ì´ˆ ê±°ë˜ëŸ‰ >= 1ë¶„í‰ê· ì˜ 25%

    ì¶”ê°€ í•„í„°:
    - ìŠ¤í”„ë ˆë“œ ì•ˆì •ì„± (í‰ì‹œ 2ë°° ì´í•˜)
    - ì¿¨ë‹¤ìš´ (15ì´ˆê°„ ì¬ì í™” ê¸ˆì§€)

    Returns: (is_ignition, reason, score)
    """
    if not ticks or len(ticks) < 10:
        return False, "í‹±ë¶€ì¡±", 0

    now_ts = ticks[0].get("timestamp", ticks[0].get("ts", int(time.time() * 1000)))

    # ---- ì¿¨ë‹¤ìš´ ì²´í¬ ----
    with _IGNITION_LOCK:
        last_signal = _IGNITION_LAST_SIGNAL.get(market, 0)
        if (now_ts - last_signal) < cooldown_ms:
            return False, f"ì¿¨ë‹¤ìš´({(cooldown_ms - (now_ts - last_signal)) / 1000:.1f}ì´ˆ)", 0

    # ---- ìµœê·¼ 10ì´ˆ ìœˆë„ìš° ì¶”ì¶œ ----
    cutoff_10s = now_ts - 10000
    window = [t for t in ticks if t.get("timestamp", t.get("ts", 0)) >= cutoff_10s]

    if len(window) < 6:
        return False, "10ì´ˆìœˆë„ìš°ë¶€ì¡±", 0

    # ---- 1) í‹± í­ì£¼ (ìƒëŒ€ ì„ê³„ì¹˜) ----
    with _IGNITION_LOCK:
        baseline_tps = _IGNITION_BASELINE_TPS.get(market, 0.5)  # ê¸°ë³¸ê°’ 0.5 tps

    t10 = micro_tape_stats_from_ticks(ticks, 10)
    # í‰ì‹œì˜ 3ë°° ì´ìƒ, ìµœì†Œ 12í‹±
    tps_threshold = max(12, 3 * baseline_tps * 10)
    tps_burst = t10["n"] >= tps_threshold

    # ---- 2) ì—°ì† ë§¤ìˆ˜ (10ì´ˆ ìœˆë„ìš°) ----
    consec_buys = calc_consecutive_buys(window, 10) >= 5

    # ---- 3) ê°€ê²© ì„í„ìŠ¤ (ìˆ˜ìµë¥  + ëŒ€ë¶€ë¶„ ìƒìŠ¹) ----
    prices = [t["trade_price"] for t in reversed(window)]  # ì˜¤ë˜ëœ â†’ ìµœì‹ 
    if len(prices) >= 6:
        ret = (prices[-1] / prices[0]) - 1 if prices[0] > 0 else 0
        # ğŸ”§ ì™„í™”: 5í‹± ì¤‘ 4í‹± ì´ìƒ ìƒìŠ¹ (ê¸°ì¡´: 6í‹± ëª¨ë‘ ìƒìŠ¹)
        up_count = sum(1 for a, b in zip(prices[-6:-1], prices[-5:]) if b > a)
        mostly_up = up_count >= 4
        price_impulse = (ret >= 0.003) and mostly_up  # 0.3% ì´ìƒ + ëŒ€ë¶€ë¶„ ìƒìŠ¹
    else:
        ret = 0
        price_impulse = False

    # ---- 4) ê±°ë˜ëŸ‰ í­ë°œ (10ì´ˆ ê±°ë˜ëŸ‰ >= 1ë¶„í‰ê· ì˜ 25%) ----
    vol_burst = t10["krw"] >= 0.25 * avg_candle_volume if avg_candle_volume > 0 else False

    # ---- ìŠ¤í”„ë ˆë“œ ì•ˆì •ì„± í•„í„° (ì˜µì…˜) ----
    spread_ok = True
    if ob and ob.get("spread", 0) > 0:
        # ìŠ¤í”„ë ˆë“œê°€ 0.5% ì´ˆê³¼í•˜ë©´ ë¶ˆì•ˆì •ìœ¼ë¡œ íŒë‹¨
        spread_ok = ob["spread"] <= 0.5

    # ---- ì ìˆ˜ ê³„ì‚° ----
    score = sum([tps_burst, consec_buys, price_impulse, vol_burst])

    # ---- ì í™” íŒì •: 4ìš”ê±´ ì¤‘ 4ê°œ ëª¨ë‘ + ìŠ¤í”„ë ˆë“œ ì–‘í˜¸ ----
    # ğŸ”§ 3/4 â†’ 4/4ë¡œ ê°•í™” (ì í™” ìŠ¹ë¥  15~22%ë¡œ ê°€ì¥ ë‚®ìŒ)
    is_ignition = (score >= 4) and spread_ok

    if is_ignition:
        # ë§ˆì§€ë§‰ ì‹ í˜¸ ì‹œê° ê¸°ë¡
        with _IGNITION_LOCK:
            _IGNITION_LAST_SIGNAL[market] = now_ts

    # ìƒì„¸ reason ìƒì„±
    details = []
    details.append(f"í‹±{'âœ“' if tps_burst else 'âœ—'}({t10['n']:.0f}>={tps_threshold:.0f})")
    details.append(f"ì—°ë§¤{'âœ“' if consec_buys else 'âœ—'}")
    details.append(f"ê°€ê²©{'âœ“' if price_impulse else 'âœ—'}({ret*100:.2f}%)")
    details.append(f"ê±°ë˜ëŸ‰{'âœ“' if vol_burst else 'âœ—'}")
    if not spread_ok:
        details.append("ìŠ¤í”„ë ˆë“œâœ—")

    reason = ",".join(details)

    return is_ignition, reason, score


def atr14_from_candles(candles, period=14):
    if len(candles) < period + 1:
        return None
    trs = []
    for i in range(1, len(candles)):
        h = candles[i]["high_price"]
        l = candles[i]["low_price"]
        pc = candles[i - 1]["trade_price"]
        tr = max(h - l, abs(h - pc), abs(l - pc))
        trs.append(tr)
    return sum(trs[-period:]) / period if len(trs) >= period else None


# =========================
# â˜… ê·¸ë¼ì¸ë“œ(ê³„ë‹¨ì‹ ìƒìŠ¹) ì˜ˆì™¸
# =========================
# === PATCH: grind detector ===
def grind_break_ok(c1, ticks):
    """ê³„ë‹¨ì‹(ê·¸ë¼ì¸ë“œ) ìƒìŠ¹ ì˜ˆì™¸:
       - ìµœê·¼ 8ë´‰ ì¤‘ 7ë´‰ ì´ìƒì´ EMA5 ìœ„
       - ë§¤ìˆ˜ë¹„(15s) >= 0.56
       - ì²´ê²°ê°„ ê°„ê²© ë³€ë™ê³„ìˆ˜(CV, 30s) <= 0.95 (ë„ˆë¬´ ê³ ë¥¸ TWAP/ë´‡ ì œì™¸)
    """
    if len(c1) < 10 or not ticks:
        return False
    closes = [x["trade_price"] for x in c1]
    e5 = ema_series(closes, 5)
    last8 = list(zip(c1[-8:], e5[-8:]))
    above = sum(1 for c, e in last8 if c["trade_price"] >= e)
    ema_slope = (e5[-1] - e5[-4]) if len(e5) >= 4 else 0
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    ia = inter_arrival_stats(ticks, 30)
    return (above >= 7 and ema_slope > 0 and t15.get("buy_ratio", 0) >= 0.56
            and ia.get("cv", 9.9) <= 0.95)


# =========================
# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ íŒì •
# =========================
def is_mega_breakout(c1):
    if not ULTRA_RELAX_ON_MEGA or len(c1) < 6:
        return False
    cur = c1[-1]
    prev_high = max(x["high_price"] for x in c1[-6:-1])
    gap = cur["high_price"] / max(prev_high, 1) - 1
    chg_1m = cur["trade_price"] / max(c1[-2]["trade_price"], 1) - 1 if len(
        c1) >= 2 else 0
    z = zscore_krw_1m(c1, 30)
    abs_krw = cur.get("candle_acc_trade_price", 0)
    return (gap >= MEGA_BREAK_MIN_GAP) and (chg_1m >= MEGA_MIN_1M_CHG) and (
        (z >= MEGA_VOL_Z) or (abs_krw >= MEGA_ABS_KRW))


# =========================
# í—ˆìˆ˜ ë°©ì–´ / ì í™” / ì¡°ê¸° ë¸Œë ˆì´í¬
# =========================
def _turn_needed(ob_depth_krw):
    if ob_depth_krw >= 30_000_000:
        return 0.022
    elif ob_depth_krw >= 15_000_000:
        return 0.026
    elif ob_depth_krw >= 8_000_000:
        return 0.025
    else:
        return 0.023

def is_fake_pump(m,
                 current_volume,
                 current_price,
                 ob_snapshot,
                 tape30,
                 ticks=None,
                 c1=None):
    h = now_kst().hour
    min_depth = 6_000_000 if (0 <= h < 6) else MIN_DEPTH_KRW
    if not ob_snapshot or ob_snapshot.get("depth_krw", 0) < min_depth:
        return True
    if tape30.get("n", 0) < MIN_REAL_TRADES:
        return True
    if ticks:
        if wash_trade_pattern(ticks, 30, BOT_WASH_REPEAT_VOL_N):
            cut("BOT_WASH", f"{m} wash-like repeat vol")
            return True
        pp = bot_pingpong_score(ticks, 20, BOT_PINGPONG_MAX_BAND)
        if pp >= BOT_PINGPONG_MIN_ALT:
            ia = inter_arrival_stats(ticks, 30)
            pstd = price_band_std(ticks, 30)
            buy = micro_tape_stats_from_ticks(ticks, 30).get("buy_ratio", 0)
            if (pstd <= 0.0009) and (ia["cv"] <= 0.35) and (buy < 0.45
                                                            or buy > 0.75):
                cut(
                    "BOT_PINGPONG",
                    f"{m} alt {pp:.2f} | buy {buy:.2f} | cv {ia['cv']:.2f} | pstd {pstd:.4f}"
                )
                return True
    if c1 is None:
        c1 = get_minutes_candles(1, m, 5)
    if len(c1) >= 3:
        v = [c["candle_acc_trade_price"] for c in c1[-3:]]
        if len(v) >= 2 and v[-1] < v[-2] * 0.3:
            return True
    return False


def ignition_trigger_ok(m, c1, ticks, ob):
    if not c1 or not ticks or not ob:
        return False, "IGN_INIT_FAIL"
    cur = c1[-1]
    try:
        prev_high = max(x["high_price"]
                        for x in c1[-(IGN_BREAK_LOOKBACK + 1):-1])
    except:
        prev_high = 0
    if cur["high_price"] <= prev_high:
        return False, "IGN_NO_BREAK"
    if body_ratio(cur) < IGN_MIN_BODY:
        return False, "IGN_BODY_SMALL"
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    turn = t15["krw"] / max(ob.get("depth_krw", 1), 1)
    if t15["buy_ratio"] < IGN_MIN_BUY:
        return False, "IGN_BUY_WEAK"
    if turn < _turn_needed(ob.get("depth_krw", 0)):
        return False, "IGN_TURN_LOW"
    if ob.get("spread", 999) > MAX_SPREAD_FAST:
        return False, "IGN_SPREAD"
    if not five_min_context_ok(m):
        return False, "IGN_5M_WEAK"
    return True, "IGNITION_OK"


def tick_breakout_ok(m, c1, ticks, ob, lookback=12):
    if not (USE_TICK_BREAK and c1 and ticks and ob): return False
    try:
        prev_high = max(x["high_price"] for x in c1[-(lookback + 1):-1])
    except:
        return False
    last_prices = [x["trade_price"] for x in ticks[:20]]
    if not last_prices: return False
    cur_max = max(last_prices)
    gap = cur_max / max(prev_high, 1) - 1
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    depth_ok = ob.get("depth_krw", 0) >= 12_000_000
    return (gap >= TICK_BREAK_GAP) and (t15["buy_ratio"]
                                        >= 0.60) and uptick_streak_from_ticks(
                                            ticks, need=2) and depth_ok


def meets_volume_surge(current_volume, past_volumes):
    avg_past = statistics.mean(
        past_volumes) if past_volumes else current_volume / 8
    rel_x = current_volume / max(avg_past, 1)
    return (rel_x >= MIN_RELATIVE_KRW_X) or (current_volume >= ABS_SURGE_KRW
                                             and rel_x >= RELAXED_X)


# =========================
# ê°ì§€ / ê²€ì¦
# =========================

# ========================================
# â˜…â˜…â˜… 1ë‹¨ê³„ ê²Œì´íŠ¸ (ë‹¨ì¼ í†µí•© - final_check ëŒ€ì²´) â˜…â˜…â˜…
# ========================================
def stage1_gate(*, spread, accel, volume_surge, turn_pct, buy_ratio, imbalance, fresh_ok,
                 fresh_age=0.0, fresh_max_age=2.0,
                 current_volume=0, price_change=0, mega=False,
                 ema20_breakout=False, high_breakout=False, vol_vs_ma=0.0,
                 ignition_score=0):
    """
    1ë‹¨ê³„ ì§„ì… ê²Œì´íŠ¸: ë‹¨ì¼ í†µí•© í•„í„° (ì í™” í†µí•©)

    [ğŸ”¥ ì í™” ì ìˆ˜ = ê°€ì /ì™„í™” ìš”ì†Œ]
    - ignition_scoreê°€ ë†’ìœ¼ë©´ ì„ê³„ì¹˜ê°€ ë™ì ìœ¼ë¡œ ì™„í™”ë¨
    - ë³„ë„ ë¶„ê¸° ì—†ì´ ë‹¨ì¼ íë¦„ìœ¼ë¡œ ì²˜ë¦¬
    - í•™ìŠµ/íŠœë‹ í¬ì¸íŠ¸: GATE_* ë³€ìˆ˜ í•˜ë‚˜

    [ì „ì—­ ë³€ìˆ˜ ì„ê³„ì¹˜ ì‚¬ìš© - ìë™í•™ìŠµ ëŒ€ìƒ]
    - GATE_TURN_MIN: íšŒì „ìœ¨ í•˜í•œ
    - GATE_SPREAD_MAX: ìŠ¤í”„ë ˆë“œ ìƒí•œ
    - GATE_ACCEL_MIN: ê°€ì†ë„ í•˜í•œ
    - GATE_BUY_RATIO_MIN: ë§¤ìˆ˜ë¹„ í•˜í•œ
    - GATE_IMBALANCE_MIN: í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ í•˜í•œ
    - GATE_VOL_MIN: ê±°ë˜ëŒ€ê¸ˆ í•˜í•œ
    - GATE_SURGE_MIN: ê±°ë˜ëŸ‰ê¸‰ë“± í•˜í•œ
    - GATE_PRICE_MIN: ê°€ê²©ë³€ë™ í•˜í•œ
    - GATE_FRESH_AGE_MAX: í‹±ì‹ ì„ ë„ ìƒí•œ(ì´ˆ)

    [ë¡œê·¸ í˜•ì‹ í†µì¼]
    - ì»· ë©”ì‹œì§€: "í•­ëª© í˜„ì¬ê°’<ê¸°ì¤€ê°’" ë˜ëŠ” "í˜„ì¬ê°’>ê¸°ì¤€ê°’"
    - ëª¨ë“  ì»·ì— í˜„ì¬ê°’ê³¼ ë™ì  ê¸°ì¤€ê°’ í‘œì‹œ

    Returns: (allow, reason)
    """
    # ============================================================
    # ğŸ”¥ ì í™” ì ìˆ˜ì— ë”°ë¥¸ ë™ì  ì„ê³„ì¹˜ ì™„í™” (ë³„ë„ ë¶„ê¸° X, ê°€ì  ë°©ì‹)
    # ignition_score: 0~4, ì ìˆ˜ë‹¹ ì™„í™” ë¹„ìœ¨ ì ìš©
    # ============================================================
    relax = ignition_score * 0.08  # ì ìˆ˜ë‹¹ 8% ì™„í™” (3ì ì´ë©´ 24% ì™„í™”)

    # ë™ì  ì„ê³„ì¹˜ ê³„ì‚° (ì í™” ì ìˆ˜ ë†’ìœ¼ë©´ ì¡°ê±´ ì™„í™”)
    eff_surge_min = max(0.1, GATE_SURGE_MIN * (1 - relax))       # 1.5 â†’ 0.4 (3ì )
    eff_vol_vs_ma = max(0.2, 0.5 * (1 - relax))                  # 0.5 â†’ 0.2 (3ì ) - ì§„ì…ì‹ í˜¸ìš©
    eff_vol_vs_ma20_min = max(0.5, GATE_VOL_VS_MA20_MIN * (1 - relax))  # 1.0 â†’ 0.5 (3ì ) - GATE í•„í„°
    eff_price_min = max(0, GATE_PRICE_MIN * (1 - relax * 2))     # ê±°ì˜ 0
    eff_turn_min = max(0.5, GATE_TURN_MIN * (1 - relax))         # 2.0 â†’ 0.5 (3ì )
    eff_buy_min = max(0.45, GATE_BUY_RATIO_MIN * (1 - relax * 0.5))  # 0.55 â†’ 0.48 (3ì )
    eff_imb_min = max(0.15, GATE_IMBALANCE_MIN * (1 - relax))    # 0.35 â†’ 0.15 (3ì )
    eff_spread_max = GATE_SPREAD_MAX * (1 + relax)               # 0.4 â†’ 0.5 (3ì )
    eff_accel_min = max(0.1, GATE_ACCEL_MIN * (1 - relax))       # 0.3 â†’ 0.1 (3ì )

    # ì í™” ì—¬ë¶€ (ë¡œê·¸ìš©)
    is_ignition = (ignition_score >= 4)  # ğŸ”§ 3â†’4 ê°•í™”

    # ğŸ“Š ì£¼ìš” ì§€í‘œ í•œì¤„ ìš”ì•½ (íŠœë‹ìš© - ëª¨ë“  ì»·/í†µê³¼ì— í‘œì‹œ)
    metrics = (f"ì í™”={ignition_score} surge={volume_surge:.2f}x MAëŒ€ë¹„={vol_vs_ma:.1f}x "
               f"ë³€ë™={price_change*100:.2f}% íšŒì „={turn_pct:.1f}% ë§¤ìˆ˜ë¹„={buy_ratio:.0%} "
               f"ìŠ¤í”„ë ˆë“œ={spread:.2f}% ì„ë°¸={imbalance:.2f} ê°€ì†={accel:.1f}x")

    # ============================================================
    # ë‹¨ì¼ íë¦„: ëª¨ë“  ì¡°ê±´ ì²´í¬ (ë™ì  ì„ê³„ì¹˜ ì‚¬ìš©)
    # ============================================================

    # === ì‹ ì„ ë„ ì²´í¬ (í•„ìˆ˜ - ì™„í™” ì—†ìŒ) ===
    if not fresh_ok:
        return False, f"í‹±ì‹ ì„ ë„ë¶€ì¡± {fresh_age:.1f}ì´ˆ>{fresh_max_age:.1f}ì´ˆ"

    # === ê±°ë˜ëŒ€ê¸ˆ ì»· ===
    if current_volume < GATE_VOL_MIN and not mega:
        return False, f"ê±°ë˜ëŒ€ê¸ˆë¶€ì¡± {current_volume/1e6:.0f}M<{GATE_VOL_MIN/1e6:.0f}M"

    # === ê±°ë˜ëŸ‰ ê¸‰ë“± ì¡°ê±´ (ë™ì ) ===
    vol_ok = (volume_surge >= eff_surge_min) or (vol_vs_ma >= eff_vol_vs_ma)
    if not vol_ok and not mega:
        return False, f"ê±°ë˜ëŸ‰ë¶€ì¡± surge{volume_surge:.1f}x<{eff_surge_min:.1f}x MA{vol_vs_ma:.1f}x<{eff_vol_vs_ma:.1f}x"

    # === ê°€ê²©ë³€ë™ í•˜í•œ ì»· (ë™ì ) ===
    if price_change < eff_price_min and not mega:
        return False, f"ë³€ë™ë¶€ì¡± {price_change*100:.2f}%<{eff_price_min*100:.2f}%"

    # === vol/MA20 í•˜í•œ ì»· (ë™ì ) - v2ë¶„ì„ AUC=0.841 ===
    if vol_vs_ma < eff_vol_vs_ma20_min and not mega:
        return False, f"MA20ëŒ€ë¹„ë¶€ì¡± {vol_vs_ma:.2f}x<{eff_vol_vs_ma20_min:.2f}x"

    # === íšŒì „ìœ¨ ì»· (ë™ì ) ===
    if turn_pct < eff_turn_min:
        return False, f"íšŒì „ìœ¨ë¶€ì¡± {turn_pct:.1f}%<{eff_turn_min:.1f}%"
    # ğŸ”§ CRITICAL: ê³¼íšŒì „ + ìŠ¤í”„ë ˆë“œ ë„“ìŒ = ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ (120â†’50 í˜„ì‹¤í™”)
    if turn_pct > 50 and spread > 0.25:
        return False, f"ê³¼íšŒì „+ìŠ¤í”„ë ˆë“œ íšŒì „{turn_pct:.0f}%>50% ìŠ¤í”„{spread:.2f}%>0.25%"

    # === ìŠ¤í”„ë ˆë“œ ì»· (ë™ì ) ===
    if spread > eff_spread_max:
        return False, f"ìŠ¤í”„ë ˆë“œê³¼ë‹¤ {spread:.2f}%>{eff_spread_max:.2f}%"

    # === ê³¼ì—´ í•„í„° (ì™„í™” ì—†ìŒ - ì•ˆì „ì¥ì¹˜) ===
    overheated = accel * volume_surge
    if overheated > GATE_OVERHEAT_MAX:
        return False, f"ê³¼ì—´ {overheated:.1f}>{GATE_OVERHEAT_MAX}"

    # === ê°€ì†ë„ ì»· (ë™ì ) ===
    if accel < eff_accel_min:
        return False, f"ê°ì†ì¤‘ ê°€ì†{accel:.1f}x<{eff_accel_min:.1f}x"
    if accel > GATE_ACCEL_MAX:
        return False, f"ê°€ì†ê³¼ë‹¤ {accel:.1f}x>{GATE_ACCEL_MAX}x"

    # === ë§¤ìˆ˜ë¹„ ì»· (ë™ì ) ===
    if buy_ratio < eff_buy_min:
        return False, f"ë§¤ìˆ˜ë¹„ë¶€ì¡± {buy_ratio:.0%}<{eff_buy_min:.0%}"

    # === ë§¤ìˆ˜ë¹„ 100% ì»· (ìŠ¤í‘¸í•‘ ì˜ì‹¬ - ì™„í™” ì—†ìŒ) ===
    if abs(buy_ratio - 1.0) < 1e-6:
        return False, "ë§¤ìˆ˜ë¹„100%(ìŠ¤í‘¸í•‘)"

    # === ê¸‰ë“± ì»· (ì™„í™” ì—†ìŒ - ì•ˆì „ì¥ì¹˜) ===
    if volume_surge > GATE_SURGE_MAX:
        return False, f"ê¸‰ë“±ê³¼ë‹¤ {volume_surge:.1f}x>{GATE_SURGE_MAX}x"

    # === í˜¸ê°€ ì„ë°¸ëŸ°ìŠ¤ ì»· (ë™ì ) ===
    if imbalance < eff_imb_min:
        return False, f"í˜¸ê°€ê· í˜•ì·¨ì•½ ì„ë°¸{imbalance:.2f}<{eff_imb_min:.2f}"

    # === ì§„ì… ì‹ í˜¸ ì²´í¬ (ë™ì ) ===
    # ëŒíŒŒ ì ìˆ˜: EMA20 ëŒíŒŒ + ê³ ì  ëŒíŒŒ
    breakout_score = int(ema20_breakout) + int(high_breakout)

    # ì§„ì… ì¡°ê±´: ëŒíŒŒ 1ê°œ OR vol_vs_ma OR ì í™” 4ì  (4/4 ëª¨ë‘ ì¶©ì¡±)
    entry_signal = (breakout_score >= 1) or (vol_vs_ma >= eff_vol_vs_ma) or (ignition_score >= 4)

    if not entry_signal:
        return False, f"ì§„ì…ì¡°ê±´ë¯¸ë‹¬ EMAëŒíŒŒ={ema20_breakout} ê³ ì ëŒíŒŒ={high_breakout} MA{vol_vs_ma:.1f}x"

    # === í†µê³¼ ===
    # ì‹ í˜¸ íƒ€ì… í‘œì‹œ (ì í™” / ê°•ëŒíŒŒ / EMAâ†‘ / ê³ ì â†‘ / ê±°ë˜ëŸ‰â†‘)
    if is_ignition:
        signal_tag = "ğŸ”¥ì í™”"
    elif breakout_score == 2:
        signal_tag = "ê°•ëŒíŒŒ (EMAâ†‘+ê³ ì â†‘)"
    elif ema20_breakout:
        signal_tag = "EMAâ†‘"
    elif high_breakout:
        signal_tag = "ê³ ì â†‘"
    else:
        signal_tag = "ê±°ë˜ëŸ‰â†‘"

    # í†µê³¼ ì‹œ ì£¼ìš” ì§€í‘œë§Œ ê°„ëµ í‘œì‹œ
    pass_summary = f"ë§¤ìˆ˜{buy_ratio:.0%} íšŒì „{turn_pct:.1f}% ì„ë°¸{imbalance:.2f}"
    return True, f"{signal_tag} PASS | {pass_summary}"


# === ğŸ”§ í‹±ë²„ìŠ¤íŠ¸ í—ˆìš© íŒë‹¨ (ë¹„í™œì„±í™”ë¨) ===
def allow_tick_burst(buy_ratio, turn_pct, tick_count, spread, symbol_median_spread=None):
    """
    ğŸ”§ ë¹„í™œì„±í™”: tick_burst ê²½ë¡œ ì œê±°ë¡œ ë” ì´ìƒ ì‚¬ìš© ì•ˆí•¨
    """
    # --- ê³µí†µ í•˜ë“œì»· ---
    # ğŸ”¥ ê°•í™”: 3 â†’ 4í‹±
    if tick_count < 4:
        return False, None, "í‹±ìˆ˜ ë¶€ì¡±(<4)"

    if buy_ratio <= 0.05:
        return False, None, "ë§¤ìˆ˜ë¹„ 0% í¸í–¥"

    # ğŸ”¥ ê°•í™”: ë§¤ìˆ˜ë¹„ >= 65% (ë¦¬í¬íŠ¸: íŒ¨ë°° ì¼€ì´ìŠ¤ì— ë‚®ì€ ë§¤ìˆ˜ë¹„ ë‹¤ìˆ˜)
    if buy_ratio < 0.65:
        return False, None, f"ë§¤ìˆ˜ë¹„ ë¶€ì¡±({buy_ratio:.0%}<65%)"

    # ğŸ”¥ ê°•í™”: íšŒì „ìœ¨ >= 5% (ë¦¬í¬íŠ¸: íŒ¨ë°°ì— turn 0.1% ì¼€ì´ìŠ¤)
    if turn_pct < 5.0:
        return False, None, f"íšŒì „ìœ¨ ë¶€ì¡±({turn_pct:.1f}%<5%)"

    # ğŸ”¥ ê°•í™”: ìŠ¤í”„ë ˆë“œ <= 0.25% (ë¦¬í¬íŠ¸: íŒ¨ë°°ì— 0.4% ì¼€ì´ìŠ¤)
    thr_spread = 0.25
    if spread > thr_spread:
        return False, None, f"ìŠ¤í”„ë ˆë“œ ì´ˆê³¼({spread:.2f}%>{thr_spread:.2f}%)"

    # --- ìœ ë™ì„± ë ˆì§ ë¶„ê¸° (í•˜ë“œì»· ëŒ€ì‹  ì‚¬ì´ì§•) ---
    # ğŸ”¥ ê°•í™”: ì‚¬ì´ì§• ê¸°ì¤€ ìƒí–¥
    if turn_pct >= 10.0 and buy_ratio >= 0.75:
        # ê³ ìœ ë™+ê³ ë§¤ìˆ˜ë¹„: confirm
        size = "normal"
    elif turn_pct >= 8.0:
        # ê³ ìœ ë™: half
        size = "half"
    else:
        # ê·¸ ì™¸: probe
        size = "probe"

    return True, size, f"í†µê³¼(íšŒì „{turn_pct:.1f}%,ë§¤ìˆ˜{buy_ratio:.0%},ì‚¬ì´ì¦ˆ={size})"


def detect_leader_stock(m, obc, c1, tight_mode=False):
    """
    í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… íƒì§€ ì—”ì§„:
      - Probe(ì†Œì•¡): ì™„í™”ëœ early íë¦„ ê°ì§€ â†’ ì´ˆê¸° ì—¼íƒ ì§„ì…
      - Confirm(ì¶”ì„¸): ê°•í•œ ì í™”/ë§¤ì§‘/ëŒíŒŒ â†’ í™•ì • ì§„ì…
    """
    if len(c1) < 3:
        return None

    # === ğŸ”§ ìŠ¤í…Œì´ë¸”ì½”ì¸ ì°¨ë‹¨ (USDT, USDC ë“± ê°€ê²©ë³€ë™ ì—†ëŠ” ì½”ì¸) ===
    if any(stable in m.upper() for stable in ["USDT", "USDC", "DAI", "TUSD", "BUSD"]):
        cut("STABLECOIN", f"{m} ìŠ¤í…Œì´ë¸”ì½”ì¸ ì œì™¸")
        return None

    # === ë™ì¼ ì¢…ëª© ì¤‘ë³µ ì§„ì… ë°©ì§€ (í¬ì§€ì…˜ ë³´ìœ  ì‹œ ìŠ¤í‚µ) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if pos:
            # ğŸ”§ FIX: ë½ ë‚´ë¶€ì—ì„œ ì²´í¬í•´ì•¼ race condition ë°©ì§€
            return None

    # === í‹± ê¸°ë°˜ ì´ˆë´‰(10ì´ˆ) ì„ í–‰ ì§„ì… ì‹œê·¸ë„ ===
    # ğŸ”§ ë¹„í™œì„±í™”: tick_burst ê²½ë¡œ ì œê±° (normal ê²½ë¡œë¡œ í†µí•©)
    # - probe ì§„ì… í›„ ë³¸ì§„ì… ì „ëµì´ ì‹¤ì œë¡œ íš¨ê³¼ ì—†ìŒ
    # - tick_burst vs normal ì„ê³„ì¹˜ê°€ ê±°ì˜ ë™ì¼í•´ì„œ ë¶„ë¦¬ ì˜ë¯¸ ì—†ìŒ
    # ticks_now = get_recent_ticks(m, 80)
    # if ticks_now: ... (ì „ì²´ tick_burst ë¡œì§ ë¹„í™œì„±í™”)

    # (ì´í•˜ ê¸°ì¡´ detect_leader_stock ì½”ë“œ ê³„ì†)

    ob = obc.get(m)
    if not ob or not isinstance(ob.get("raw"), dict):
        return None
    if not ob.get("raw", {}).get("orderbook_units"):
        return None
    if ob.get("depth_krw", 0) <= 0:
        return None

    mega = is_mega_breakout(c1)
    th = get_dynamic_thresholds()
    cur, prev = c1[-1], c1[-2]
    price_change = (cur["trade_price"] / max(prev["trade_price"], 1) - 1)

    # ğŸ”§ SPREAD_HIGH, VOL_LOW, SURGE_LOW, PRICE_LOW â†’ stage1_gateë¡œ ì´ë™
    # ê±°ë˜ëŸ‰ ë°ì´í„° (stage1_gateì—ì„œ ì‚¬ìš©)
    current_volume = cur.get("candle_acc_trade_price", 0)
    past_volumes = [c["candle_acc_trade_price"] for c in c1[-7:-2] if c["candle_acc_trade_price"] > 0]

    # í‹± í™•ë³´
    ticks = get_recent_ticks(m, 100)
    if not ticks:
        cut("TICKS_LOW", f"{m} no ticks")
        return None

    # ğŸ”¥ í‰ì‹œ TPS ì—…ë°ì´íŠ¸ (ì í™” ê°ì§€ìš©)
    update_baseline_tps(m, ticks)

    # === í…Œì´í”„ ì§€í‘œ (stage1_gateìš©) ===
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    t45 = micro_tape_stats_from_ticks(ticks, 45)
    twin = t15 if t15["krw_per_sec"] >= t45["krw_per_sec"] else t45
    turn = twin["krw"] / max(ob["depth_krw"], 1)

    # ğŸ”¥ 1ë‹¨ê³„ ê²Œì´íŠ¸ ì ìš© (ë‹¨ì¼ í†µí•© í•„í„°)
    # ì í™” ê°ì§€ë„ stage1_gate ë‚´ì—ì„œ ì²˜ë¦¬
    vol_surge = current_volume / max(statistics.mean(past_volumes) if past_volumes else current_volume / 8, 1)
    accel = calc_flow_acceleration(ticks)
    turn_pct = turn * 100  # decimal â†’ %
    imbalance = calc_orderbook_imbalance(ob)
    fresh_ok, fresh_age, fresh_max_age = last_two_ticks_fresh(ticks, return_age=True)

    # ğŸ”¥ ì„€ë„ìš° ëª¨ë“œìš© ì§€í‘œ ë¯¸ë¦¬ ê³„ì‚°
    ia = inter_arrival_stats(ticks, 30)
    cv = ia["cv"]
    pstd10 = price_band_std(ticks, 10)
    cons_buys = calc_consecutive_buys(ticks, 15)
    overheat = accel * vol_surge
    spread = ob.get("spread", 9.9)

    # ğŸ›‘ í•˜ë“œ ì»·: ê·¹ë‹¨ ìŠ¤í‘¸í•‘ íŒ¨í„´ (í™•ì‹  êµ¬ê°„ë§Œ ì°¨ë‹¨)
    # buy_ratio >= 0.98 AND pstd <= 0.001 AND CV >= 2.5
    if twin["buy_ratio"] >= 0.98 and pstd10 <= 0.001 and cv >= 2.5:
        cut("FAKE_FLOW_HARD", f"{m} buy{twin['buy_ratio']:.2f} pstd{pstd10:.4f} cv{cv:.2f}")
        return None

    # ğŸ” ì„€ë„ìš° íƒœê¹… (ì‹¤ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, íƒœê·¸ë§Œ ê¸°ë¡)
    shadow_flags = []
    if cv > 2.2:
        shadow_flags.append("CV22")
    if turn_pct >= 12 and (cons_buys > 18 or overheat > 3):
        shadow_flags.append("TURNxCONS/HEAT")
    if accel >= 3.0 and not (imbalance >= 0.40 and spread <= 0.12):
        shadow_flags.append("ACCEL_WEAK_CTX")
    would_cut = len(shadow_flags) > 0

    # ğŸ”§ ë°ì´í„° ê¸°ë°˜ í•„í„°: ì—°ì†ë§¤ìˆ˜, CV (ìŠ¹ë¥  ë¶„ì„ ê²°ê³¼)
    if cons_buys > GATE_CONSEC_MAX:
        cut("CONSEC_HIGH", f"{m} ì—°ì†ë§¤ìˆ˜{cons_buys}>{GATE_CONSEC_MAX} (ì¶”ê²©ë§¤ìˆ˜ ìœ„í—˜)")
        return None
    if cv > GATE_CV_MAX:
        cut("CV_HIGH", f"{m} CV{cv:.2f}>{GATE_CV_MAX} (ë³€ë™ì„± ê³¼ì—´)")
        return None

    # ğŸš€ ì‹ ê·œ ì¡°ê±´ ê³„ì‚°: EMA20 ëŒíŒŒ, ê³ ì  ëŒíŒŒ, ê±°ë˜ëŸ‰ MA ëŒ€ë¹„
    cur_price = cur["trade_price"]
    closes = [x["trade_price"] for x in c1]
    ema20 = ema_last(closes, 20) if len(closes) >= 20 else None
    ema20_breakout = (ema20 is not None and cur_price > ema20)

    prev_high = prev_high_from_candles(c1, lookback=12, skip_recent=1)
    high_breakout = (prev_high > 0 and cur_price > prev_high)

    vol_ma20 = vol_ma_from_candles(c1, period=20)
    vol_vs_ma = current_volume / max(vol_ma20, 1) if vol_ma20 > 0 else 0.0

    # ğŸ”¥ ì í™” ê°ì§€ ì ìˆ˜ ê³„ì‚° (stage1_gateì— ì „ë‹¬)
    _, ignition_reason, ignition_score = ignition_detected(
        market=m,
        ticks=ticks,
        avg_candle_volume=vol_ma20,
        ob=ob,
        cooldown_ms=15000
    )

    gate_ok, gate_reason = stage1_gate(
        spread=ob["spread"],
        accel=accel,
        volume_surge=vol_surge,
        turn_pct=turn_pct,
        buy_ratio=twin["buy_ratio"],
        imbalance=imbalance,
        fresh_ok=fresh_ok,
        fresh_age=fresh_age,
        fresh_max_age=fresh_max_age,
        current_volume=current_volume,
        price_change=price_change,
        mega=mega,
        # ğŸš€ ì‹ ê·œ íŒŒë¼ë¯¸í„°
        ema20_breakout=ema20_breakout,
        high_breakout=high_breakout,
        vol_vs_ma=vol_vs_ma,
        ignition_score=ignition_score
    )
    if not gate_ok:
        # STAGE1_GATEëŠ” í…”ë ˆê·¸ë¨ ì•ŒëŒ ì „ì— ì»·ë˜ë¯€ë¡œ near_miss=False
        cut("STAGE1_GATE", f"{m} {gate_reason}", near_miss=False)
        return None

    # === ê²°ê³¼ íŒ¨í‚¤ì§• ===
    # ğŸ”¥ signal_tag ì¶”ì¶œ (gate_reason: "{signal_tag} PASS | {metrics}")
    signal_tag = gate_reason.split(" PASS")[0] if " PASS" in gate_reason else "ê¸°ë³¸"

    pre = {
        "price": cur["trade_price"],
        "change": price_change,
        "current_volume": current_volume,
        "volume_surge": vol_surge,
        "ob": ob,
        "tape": twin,
        "ticks": ticks,
        "flow_accel": accel,
        "imbalance": imbalance,
        "turn_pct": turn_pct,
        "spread": ob["spread"],
        "buy_ratio": twin["buy_ratio"],
        "fresh_ok": fresh_ok,  # ğŸ”§ CRITICAL: fresh_ok ì „ë‹¬ (ìŠ¤ì½”ì–´ ê³„ì‚°ìš©)
        "mega": mega,
        "filter_type": "stage1_gate",
        "ignition_score": ignition_score,
        "gate_reason": gate_reason,
        # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ í†µì¼ (ì í™”3, EMAâ†‘, ê³ ì â†‘, ê±°ë˜ëŸ‰â†‘ ë“±)
        "signal_tag": signal_tag,
        # ğŸ” ì„€ë„ìš° ëª¨ë“œìš© (ê±°ë˜ëŠ” ê·¸ëŒ€ë¡œ, ë‚˜ì¤‘ì— ë¶„ì„ìš©)
        "shadow_flags": ",".join(shadow_flags) if shadow_flags else "",
        "would_cut": would_cut,
        "cv": cv,
        "pstd": pstd10,
        "consecutive_buys": cons_buys,
        "overheat": overheat,
    }

    return pre

def final_check_leader(m, pre, tight_mode=False):
    """
    ğŸ”§ ë‹¨ìˆœ íŒ¨ìŠ¤ì“°ë£¨: stage1_gate/prebreakì—ì„œ ëª¨ë“  í•„í„°ë§ ì™„ë£Œ
    í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ëŠ” ìœ ì§€í•˜ë˜, ë°”ë¡œ payload ë°˜í™˜
    """
    t = pre["tape"]
    ob = pre["ob"]

    # Pre-breakëŠ” í‹±ìˆ˜ ì²´í¬ ìŠ¤í‚µ (ì´ë¯¸ ì¡°ê±´ ì¶©ì¡±)
    filter_type = pre.get("filter_type", "stage1_gate")
    if filter_type != "prebreak":
        # ìµœì†Œ í‹±ìˆ˜ë§Œ ì²´í¬ (ì´ê±´ stage1_gate ì „ì— í•„ìš”)
        if t["n"] < MIN_TICKS_COUNT:
            cut("TICKS_LOW", f"{m} {t['n']}")
            return None

    # í•„í„° íƒ€ì…ì— ë”°ë¥¸ í‘œì‹œ: signal_tag ì‚¬ìš©
    if filter_type == "prebreak":
        display_filter = "ğŸš€ì„ í–‰ì§„ì…"
    elif "ì í™”" in pre.get("signal_tag", ""):
        display_filter = "ë¹ ë¥¸ì§„ì…"
    else:
        display_filter = "í†µí•©ê²Œì´íŠ¸"

    # ğŸ”§ FIX: score ê³„ì‚° ë³µì› (calc_risk_score í˜¸ì¶œ)
    buy_ratio = pre.get("buy_ratio", 0.5)
    spread = pre.get("spread", 0.5)
    # ğŸ”§ CRITICAL: turn ë‹¨ìœ„ ë³´ì • (í¼ì„¼íŠ¸ â†’ ì†Œìˆ˜)
    turn = (pre.get("turn_pct", 1.0) or 1.0) / 100.0
    imbalance = pre.get("imbalance", 0.0)
    volume_surge = pre.get("volume_surge", 1.0)
    fresh_ok = pre.get("fresh_ok", True)

    score = calc_risk_score(buy_ratio, spread, turn, imbalance, fresh_ok, volume_surge)

    # í”„ë¦¬ì‹œì „ í¬ì¼“: ì„ë°¸ >= 0.6 AND ë§¤ìˆ˜ë¹„ >= 63.5%
    is_precision = (imbalance >= 0.6 and buy_ratio >= 0.635)

    # ì´ë¯¸ stage1_gate/prebreakì—ì„œ ëª¨ë“  í•„í„°ë§ ì™„ë£Œ
    # ê¸°ì¡´ í˜¸ì¶œ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•´ payload í˜•ì‹ìœ¼ë¡œ ë°˜í™˜
    return {
        "price": pre["price"],
        "chg": round(pre.get("change", 0) * 100, 2),
        "current_volume": int(pre.get("current_volume", 0)),
        "volume_surge": round(pre.get("volume_surge", 0.0), 2),
        "buy": round(pre.get("buy_ratio", 0) * 100, 1),
        "n": t["n"],
        "spread": round(pre.get("spread", 0), 2),
        "turn": round(pre.get("turn_pct", 0), 2),
        "imbalance": round(imbalance, 3),
        "score": score,
        "is_precision_pocket": is_precision,
        "filter_type": display_filter,
        "is_prebreak": filter_type == "prebreak",
    }


# =========================
# === [DL LOGGING]
# =========================
LOG_PATH = os.path.join(os.getcwd(), os.getenv("DL_LOG_PATH",
                                               "signals_log.csv"))
_CSV_LOCK = threading.Lock()

DL_FIELDS = [
    "ts", "market", "entry_price", "chg_1m", "chg_5m", "chg_15m", "zscore_1m",
    "vwap_gap", "t15_buy", "t15_n", "t15_rate", "t15_krw", "turn", "spread",
    "depth_krw", "bidask_ratio", "volume_surge", "btc_1m", "btc_5m", "hour",
    "dow", "two_green_break", "ignition_ok", "early_ok", "uptick_ok",
    # ğŸ”¥ ìƒˆ ì§€í‘œ ì¶”ê°€
    "consecutive_buys", "avg_krw_per_tick", "flow_acceleration",
    # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ ì¶”ê°€
    "imbalance", "overheat", "fresh_age",
    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ì¶”ê°€
    "cv", "pstd", "best_ask_krw", "prebreak_band", "is_prebreak",
    "ret_3m", "ret_10m", "ret_15m", "maxdd_10m", "maxrun_10m", "label_win10",
    "label_fail10"
]


def append_csv(row: dict):
    with _CSV_LOCK:
        new = not os.path.exists(LOG_PATH)
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=DL_FIELDS)
            if new: w.writeheader()
            for k in DL_FIELDS:
                if k not in row: row[k] = ""
            w.writerow(row)


def snapshot_row(m, entry_price, payload, pre, c1, ob, t15, btc1m, btc5m,
                 flags):
    try:
        raw_ob = ob["raw"]["orderbook_units"][:3]
        bid_sum = sum(u["bid_size"] * u["bid_price"] for u in raw_ob)
        ask_sum = sum(u["ask_size"] * u["ask_price"] for u in raw_ob)
        bidask_ratio = bid_sum / max(ask_sum, 1)
    except:
        bidask_ratio = 0.0

    # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°
    ticks = pre.get("ticks", [])
    cons_buys = calc_consecutive_buys(ticks, 15)
    avg_krw = calc_avg_krw_per_tick(t15)
    flow_accel = calc_flow_acceleration(ticks)

    # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
    imbalance = pre.get("imbalance", 0.0)
    overheat = flow_accel * float(payload.get("volume_surge", 1.0))  # accel * surge
    # í‹± ì‹ ì„ ë„: ë§ˆì§€ë§‰ í‹± ë‚˜ì´ (ì´ˆ)
    fresh_age = 0.0
    if ticks:
        now_ms = int(time.time() * 1000)
        last_tick_ts = ticks[0].get("timestamp", now_ms)
        fresh_age = (now_ms - last_tick_ts) / 1000.0

    # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
    ia_stats = inter_arrival_stats(ticks, 30) if ticks else {"cv": 0.0}
    cv = ia_stats.get("cv", 0.0)
    pstd = price_band_std(ticks, sec=10) if ticks else 0.0
    prebreak_band = dynamic_prebreak_band(ticks) if ticks else PREBREAK_HIGH_PCT
    is_prebreak = 1 if pre.get("filter_type") == "prebreak" else 0
    # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
    try:
        u0 = ob.get("raw", {}).get("orderbook_units", [])[0]
        best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
    except Exception:
        best_ask_krw = 0.0

    row = {
        "ts": now_kst_str(),
        "market": m,
        "entry_price": int(entry_price),
        "chg_1m": round(flags.get("chg_1m", 0.0), 4),
        "chg_5m": flags.get("chg_5m", ""),
        "chg_15m": flags.get("chg_15m", ""),
        "zscore_1m": flags.get("zscore", ""),
        "vwap_gap": flags.get("vwap_gap", ""),
        "t15_buy": round(t15.get("buy_ratio", 0.0), 4),
        "t15_n": t15.get("n", 0),
        "t15_rate": round(t15.get("rate", 0.0), 4),
        "t15_krw": int(t15.get("krw", 0)),
        "turn": flags.get("turn", ""),
        "spread": payload.get("spread", ""),
        "depth_krw": ob.get("depth_krw", ""),
        "bidask_ratio": round(bidask_ratio, 3),
        "volume_surge": payload.get("volume_surge", ""),
        "btc_1m": btc1m,
        "btc_5m": btc5m,
        "hour": now_kst().hour,
        "dow": now_kst().weekday(),
        "two_green_break": 1 if flags.get("two_green_break") else 0,
        "ignition_ok": 1 if flags.get("ign_ok") else 0,
        "early_ok": 1 if flags.get("early_ok") else 0,
        "uptick_ok": 1 if flags.get("uptick_ok") else 0,
        # ğŸ”¥ ìƒˆ ì§€í‘œ
        "consecutive_buys": cons_buys,
        "avg_krw_per_tick": round(avg_krw, 0),
        "flow_acceleration": round(flow_accel, 2),
        # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ
        "cv": round(cv, 2),
        "pstd": round(pstd * 100, 4),  # % ë‹¨ìœ„
        "best_ask_krw": int(best_ask_krw),
        "prebreak_band": round(prebreak_band * 100, 2),  # % ë‹¨ìœ„
        "is_prebreak": is_prebreak,
        # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
        "imbalance": round(imbalance, 3),
        "overheat": round(overheat, 2),
        "fresh_age": round(fresh_age, 2),
        "ret_3m": "",
        "ret_10m": "",
        "ret_15m": "",
        "maxdd_10m": "",
        "maxrun_10m": "",
        "label_win10": "",
        "label_fail10": ""
    }
    return row


# =========================
# í¬ìŠ¤íŠ¸ì²´í¬ 6ì´ˆ
# =========================
from collections import deque


def postcheck_6s(m, pre):
    # ğŸ”¥ ì í™” ì§„ì…ì€ í¬ìŠ¤íŠ¸ì²´í¬ ë°”ì´íŒ¨ìŠ¤ (signal_tagì— "ì í™”" í¬í•¨ ì‹œ)
    is_ignition = "ì í™”" in pre.get("signal_tag", "")
    # âœ… FIX: tick-burst ê²½ë¡œ ì œê±°ì— ë§ì¶° ì•ˆì „ ê¸°ë³¸ê°’ (NameError ë°©ì§€)
    is_tick_burst = "í‹±ë²„ìŠ¤íŠ¸" in pre.get("signal_tag", "")

    if not POSTCHECK_ENABLED:
        return True, "SKIP"
    # ğŸ”¥ ì í™” ì§„ì…ì€ ë°”ì´íŒ¨ìŠ¤
    if is_ignition:
        return True, "BYPASS_IGNITION"
    if pre.get("ign_ok") or pre.get("two_green_break") or pre.get(
            "mega_ok", False):
        return True, "BYPASS_STRONG_BREAK"

    # â˜…â˜…â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
    r = relax_knob()
    pc_min_buy = max(0.46, POSTCHECK_MIN_BUY - 0.05 * r)   # 0.48 -> 0.46, ì™„í™”í­ ì‚´ì§â†‘
    pc_min_rate = max(0.14, POSTCHECK_MIN_RATE - 0.09 * r) # 0.16 -> 0.14
    pc_max_pstd = POSTCHECK_MAX_PSTD + 0.0005 * r          # ì‚´ì§ ë” ê´€ëŒ€
    pc_max_cv = POSTCHECK_MAX_CV + 0.18 * r
    pc_max_dd = POSTCHECK_MAX_DD + 0.005 * r

    window = POSTCHECK_WINDOW_SEC
    start = time.time()
    acc = deque(maxlen=400)  # ëˆ„ìˆ˜ ë°©ì§€
    seen = set()  # ì¤‘ë³µ ì°¨ë‹¨

    last_fetch = 0.0
    net_calls = 0  # â˜… ì´ë²ˆ postcheckì—ì„œ ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜
    # ë°¤ì—ëŠ” ì¡°ê¸ˆ ëŠìŠ¨, ì£¼ê°„ì—” ì•½ê°„ ë¹ ë¥´ê²Œ
    fetch_interval = 2.0 if (0 <= now_kst().hour < 6) else 1.6
    ok_streak = 0

    base_price = pre["price"]
    peak = base_price
    trough_after_peak = base_price  # í”¼í¬ ì´í›„ ìµœì €ê°€ ì¶”ì 

    # â˜…â˜…â˜… ì—¬ê¸° í•œ ì¤„ ì¶”ê°€ (postcheck ì¤‘ ìµœëŒ€ í—ˆìš© ê¸‰ë“±)
    # ğŸ”¥ í‹±ë²„ìŠ¤íŠ¸ëŠ” ë” ë³´ìˆ˜ì ìœ¼ë¡œ (1.0%), ì¼ë°˜ ê²½ë¡œëŠ” 1.5%
    MAX_SURGE = 0.010 if is_tick_burst else 0.015

    while True:
        now = time.time()
        if now - start > window:
            break

        # ìºì‹œ ì¬ì‚¬ìš© + ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜ ì œí•œ
        if (now - last_fetch >= fetch_interval) and (net_calls < 2):
            # ìµœëŒ€ 2ë²ˆê¹Œì§€ë§Œ ì‹¤ì œ API í˜¸ì¶œ
            ticks = get_recent_ticks(m, 100, allow_network=True)
            last_fetch = now
            net_calls += 1
        else:
            # ë‚˜ë¨¸ì§€ëŠ” ìºì‹œë§Œ ì‚¬ìš©
            ticks = get_recent_ticks(m, 100, allow_network=False)

        if not ticks:
            time.sleep(0.45)
            continue

        # accì— ìµœì‹  í‹±ë§Œ ì¤‘ë³µì—†ì´ ì¶•ì 
        # ğŸ”§ FIX: appendleft ì‚¬ìš© - ìƒˆ í‹±ì„ ì™¼ìª½ì— ì¶”ê°€í•´ì•¼ acc[0]ì´ ìµœì‹  ìœ ì§€
        for x in reversed(ticks[:12]):  # ê³¼ê±°â†’ìµœì‹  ìˆœìœ¼ë¡œ ë°˜ë³µ
            key = (x.get("timestamp"), x.get("trade_price"),
                   x.get("trade_volume"))
            if key in seen:
                continue
            seen.add(key)
            acc.appendleft(x)  # âœ… ìµœì‹ ì´ index 0 ìœ ì§€

        curp = ticks[0].get("trade_price", base_price)

        # â˜…â˜…â˜… ê°€ê²© ê¸‰ë“± ì»· ì¶”ê°€
        if base_price > 0:
            surge = (curp / base_price - 1.0)
            if surge >= MAX_SURGE:
                return False, f"SURGE_IN_POST({surge*100:.2f}%)"

        if curp > peak:
            peak = curp
            trough_after_peak = curp  # ìƒˆ í”¼í¬ê°€ ìƒê¸°ë©´ íŠ¸ë¡œí”„ ë¦¬ì…‹
        else:
            trough_after_peak = min(trough_after_peak, curp)

        # âœ” DDëŠ” í”¼í¬ ëŒ€ë¹„ í•˜ë½ë¥ (ìŒìˆ˜)ë¡œ ì²´í¬
        dd = (curp / peak - 1.0)

        t10 = micro_tape_stats_from_ticks(list(acc), 10)
        ia = inter_arrival_stats(list(acc), 20)
        pstd = price_band_std(list(acc), 20)

        # â˜… ê°€ë³€ ì„ê³„ì¹˜ ì ìš©
        pass_now = (t10["buy_ratio"] >= pc_min_buy
                    and t10["rate"] >= pc_min_rate and pstd <= pc_max_pstd
                    and ia["cv"] <= pc_max_cv and dd >= -pc_max_dd)

        if pass_now:
            ok_streak += 1
            if ok_streak >= 2:
                return True, "OK_EARLY"
        else:
            ok_streak = 0

        # í‹±ì´ ì¶©ë¶„íˆ ëŠë¦¬ë©´ ìŠ¬ë¦½ì„ ë” ê¸¸ê²Œ
        time.sleep(0.6 if t10["rate"] >= 0.6 else 1.0)

    if not acc:
        return False, "POST_NO_TICKS"

    # ì¢…ë£Œ ì‹œì  ì¬í‰ê°€ (acc ê¸°ë°˜ìœ¼ë¡œ í”¼í¬/íŠ¸ë¡œí”„ ê³„ì‚°)
    prices = [x.get("trade_price", base_price) for x in list(acc)]
    if prices:
        peak2 = max(prices + [base_price])
        curp2 = prices[0]
        dd2 = (curp2 / peak2 - 1.0)
    else:
        dd2 = 0.0

    t10 = micro_tape_stats_from_ticks(list(acc), 10)
    ia = inter_arrival_stats(list(acc), 20)
    pstd = price_band_std(list(acc), 20)

    # â˜… ìµœì¢… íŒì •ë„ ê°€ë³€ ì„ê³„ì¹˜ë¡œ
    if t10["buy_ratio"] < pc_min_buy:
        return False, f"BUY_LOW({t10['buy_ratio']:.2f})"
    if t10["rate"] < pc_min_rate: return False, f"RATE_LOW({t10['rate']:.2f})"
    if pstd > pc_max_pstd: return False, f"PSTD_HIGH({pstd:.4f})"
    if ia["cv"] > pc_max_cv: return False, f"CV_HIGH({ia['cv']:.2f})"
    if dd2 < -pc_max_dd: return False, f"DD_TOO_DEEP({dd2:.4f})"
    return True, "OK"

# =========================
# ğŸ¯ í‹± ê¸°ë°˜ ì†ì ˆ í—¬í¼ í•¨ìˆ˜
# =========================
def upbit_tick_size(price: float) -> float:
    """ì—…ë¹„íŠ¸ KRW ë§ˆì¼“ í˜¸ê°€ ë‹¨ìœ„ (ë³´ìˆ˜ì : 100~1000ì› êµ¬ê°„ì€ 1ì›)"""
    p = float(price)
    if p >= 2_000_000: return 1000.0
    if p >= 1_000_000: return 500.0
    if p >=   500_000: return 100.0
    if p >=   100_000: return 50.0
    if p >=    10_000: return 10.0
    if p >=     1_000: return 5.0
    if p >=       100: return 1.0    # ë³´ìˆ˜ì  (ì¼ë¶€ ì¢…ëª© 0.1ì›ì´ì§€ë§Œ 1ì›ìœ¼ë¡œ)
    if p >=        10: return 0.1
    if p >=         1: return 0.01
    return 0.001

def round_to_tick(px: float, tick: float) -> float:
    """ê°€ê²©ì„ í‹± ë‹¨ìœ„ë¡œ ë‚´ë¦¼"""
    return math.floor(px / tick) * tick

def ticks_between(a: float, b: float, tick: float) -> int:
    """ë‘ ê°€ê²© ì‚¬ì´ í‹± ìˆ˜"""
    return int(abs(a - b) / max(tick, 1e-12) + 1e-9)

def compute_tick_distance(cur_price: float, c1: list, ob: dict) -> int:
    """
    ì‹œì¥ ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ í•„ìš” í‹± ê°„ê²© ê³„ì‚°
    - ìŠ¤í”„ë ˆë“œ í‹±ìˆ˜ + ì—¬ìœ 
    - ATR ê¸°ë°˜ í‹±ìˆ˜
    - ìµœì†Œ í‹±ìˆ˜
    """
    tick = upbit_tick_size(cur_price)

    # ìŠ¤í”„ë ˆë“œ(ì ˆëŒ€ê°’) â†’ í‹±ìˆ˜
    spread_ticks = 0
    try:
        if ob and "raw" in ob:
            u0 = ob["raw"]["orderbook_units"][0]
            ask, bid = float(u0["ask_price"]), float(u0["bid_price"])
            spread_abs = max(ask - bid, 0.0)
            spread_ticks = int(math.ceil(spread_abs / max(tick, 1e-12))) if spread_abs > 0 else 0
    except:
        pass

    # ATR â†’ í‹±ìˆ˜
    atr_ticks = 0
    try:
        atr = atr14_from_candles(c1, 14) if c1 else 0.0
        if atr and atr > 0:
            atr_ticks = int(math.ceil((atr * ATR_TICKS_MULT) / max(tick, 1e-12)))
    except:
        pass

    # ìµœëŒ€ê°’ ì‚¬ìš©
    base_ticks = max(MIN_TICK_DIST, spread_ticks + SPREAD_TICKS_PAD, atr_ticks)
    return int(base_ticks)


# =========================
# ë™ì  ì†ì ˆ (% ê¸°ë°˜, í‹±ìŠ¤íƒ‘ ë°±ì—…ìš©)
# =========================
def dynamic_stop_loss(entry_price, c1, signal_type=None, current_price=None):
    atr = atr14_from_candles(c1, ATR_PERIOD)
    if not atr or atr <= 0:
        return entry_price * (1 - STOP_LOSS_PCT), STOP_LOSS_PCT, None

    base_pct = (atr / max(entry_price, 1)) * ATR_MULT
    pct = min(max(base_pct, DYN_SL_MIN), DYN_SL_MAX)  # ìë™íŠœë‹ ê°’ ê·¸ëŒ€ë¡œ ì ìš©

    # ğŸš€ ì‹ í˜¸ ìœ í˜•ë³„ ì™„í™”
    if signal_type in ("early", "ign", "mega"):
        pct *= 1.3

    # ğŸ’ ìµì ˆ ì¤‘ì´ë©´ ì†ì ˆí­ ë” ì™„í™” (ëˆŒë¦¼ ë°©ì§€)
    if current_price and current_price > entry_price * 1.008:
        pct *= 1.5  # ìˆ˜ìµ ì¤‘ì—ëŠ” SLì„ ë” ë©€ë¦¬ ë‘ 

    # ATR ìƒì„¸ (í…”ë ˆê·¸ë¨ìš©) - ì½ê¸° ì‰¬ìš´ í¬ë§·
    atr_info = f"ATR {atr:.0f}ì›Ã—{ATR_MULT}ë°°"
    return entry_price * (1 - pct), pct, atr_info

# =========================
# ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì²­ì‚° ì ìˆ˜
# =========================
def context_exit_score(m, ticks, ob_depth_krw, entry_price, last_price, c1):
    """
    íœ˜í•‘ ë°©ì§€í˜• ì»¨í…ìŠ¤íŠ¸ ì ìˆ˜:
    - ë‹¨ì¼ ì‹ í˜¸ë¡œ ì²­ì‚° ìœ ë„ ê¸ˆì§€ (ë³µí•© ì¡°ê±´ ëˆ„ì )
    - ì¶”ì„¸ ì—­ì „(EMA5/VWAP ì´íƒˆ + uptick ë¶€ì¬) ìª½ì— ê°€ì¤‘ì¹˜
    """
    score = 0
    reasons = []

    # í…Œì´í”„ ë³€í™”
    w_now = _win_stats(ticks, 0, 10)
    w_early = _win_stats(ticks, 10, 30)
    decay, _ = buy_decay_flag(ticks)

    if w_now["krw_per_sec"] < w_early["krw_per_sec"] * 0.60:
        score += 1
        reasons.append("FLOW_DROP")
    if not uptick_streak_from_ticks(ticks, need=2):
        score += 1
        reasons.append("NO_UPTICK")
    if w_now["rate"] < 0.25:  # ë„ˆë¬´ ëŠë¦¬ë©´ 1ì 
        score += 1
        reasons.append("RATE_SLOW")

    # ê°€ê²©/ì»¨í…ìŠ¤íŠ¸
    vwap = vwap_from_candles_1m(c1, 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in c1], 5) if c1 else 0
    if vwap and last_price < vwap:
        score += 1
        reasons.append("VWAP_LOSS")
    if ema5 and last_price < ema5:
        score += 1
        reasons.append("EMA5_LOSS")

    # ğŸ’ ì•½ìƒìŠ¹/íš¡ë³´ ì‹œ ì²­ì‚° ì ìˆ˜ ì™„í™”
    gain_now = (last_price / entry_price - 1.0)
    if -0.004 <= gain_now <= 0.008:  # ì™„í™” ë²”ìœ„ í™•ëŒ€
        score = max(0, score - 1)
        reasons.append("MILD_GAIN_RELAX")

    # ìˆ˜ìµ êµ¬ê°„ì—ì„œì˜ ê¸‰ê°
    if last_price > entry_price * 1.008 and decay:
        score += 1
        reasons.append("DECAY_AFTER_GAIN")

    return score, reasons

# =========================
# â˜… ëª¨ë‹ˆí„°ë§ ì‹œê°„ ê²°ì • (ì‹ ê·œ ì¶”ê°€)
# =========================
def decide_monitor_secs(pre: dict, tight_mode: bool = False) -> int:
    """
    í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì´ ì‹œê°„(ì´ˆ)ì„ ìƒí™©ë³„ë¡œ ê²°ì •.
    - early_ok: ë¹„êµì  ì§§ê²Œ ì¶”ì„¸ í™•ì¸
    - ignition_ok / mega_ok: ìƒëŒ€ì ìœ¼ë¡œ ê¸¸ê²Œ (ì¶”ì„¸ ì´ì–´ì§ˆ ê°€ëŠ¥ì„±)
    - ì‹œì¥ ëª¨ë“œ(TIGHT), ì•¼ê°„, BTC ëª¨ë©˜í…€, ì˜¤ë”ë¶ ê¹Šì´ ë“±ì— ë”°ë¼ ê°€/ê°
    """
    try:
        r = relax_knob()  # 0.0 ~ 1.5
    except Exception:
        r = 0.0

    base = 150  # ê¸°ë³¸ê°’

    # ì‹ í˜¸ ìœ í˜• ê°€ì¤‘
    if pre.get("mega_ok"):
        base = 300
    elif pre.get("ign_ok"):
        base = 240
    elif pre.get("botacc_ok"):
        base = 210
    elif pre.get("early_ok"):
        base = 180
    elif pre.get("two_green_break"):
        base = 210

    # ì˜¤ë”ë¶ ê¹Šì´ ê¸°ë°˜ (ê¹Šìœ¼ë©´ ì—¬ìœ  ìˆê²Œ)
    ob_depth = 0
    try:
        ob_depth = pre.get("ob", {}).get("depth_krw", 0) or 0
    except Exception:
        pass
    if ob_depth >= 30_000_000:
        base += 30
    elif ob_depth <= 6_000_000:
        base -= 30

    # BTC 5ë¶„ ëª¨ë©˜í…€
    try:
        b5 = btc_5m_change()
    except Exception:
        b5 = 0.0
    if b5 >= 0.006:
        base += 30
    elif b5 <= -0.008:
        base -= 30

    # ì•¼ê°„(00~06 KST)ì—” í”ë“¤ë¦¼ ëŒ€ë¹„ ì•½ê°„ ë‹¨ì¶•
    h = now_kst().hour
    if 0 <= h < 6:
        base -= 15

    # ì¥ì„¸ ì™„í™” ë…¸ë¸Œ ë°˜ì˜
    base += int(10 * r)

    # íƒ€ì´íŠ¸ ëª¨ë“œ(ê¸‰ë½ ë°©ì–´)ë©´ ë‹¨ì¶•
    if tight_mode:
        base -= 30

    # í•˜í•œ/ìƒí•œ í´ë¨í”„
    base = max(90, min(base, 360))
    return int(base)


# =========================
# ëì•ŒëŒ ê¶Œê³  ìƒì„± (END RECO)
# =========================
def _end_reco(entry_price, last_price, c1, ticks, ob_depth_krw, ctx_thr=3):
    """
    ëì•ŒëŒìš© ê¶Œê³  ìƒì„±:
      - ìˆ˜ìµ/ì†ì‹¤, ì»¨í…ìŠ¤íŠ¸, í…Œì´í”„ íë¦„ ì¢…í•©ìœ¼ë¡œ
        ğŸ‘‰ ìœ ì§€ / ë¶€ë¶„ì²­ì‚° / ì „ëŸ‰ì²­ì‚° ì„¸ ê°€ì§€ ì•¡ì…˜ ì œì•ˆ
    """
    try:
        ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
    except:
        ret_pct = 0.0

    # ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´(ì¶”ì„¸ì—­ì „ ì‹ í˜¸ë“¤)
    try:
        ctx_score, ctx_reasons = context_exit_score(
            "KRW-XXX",
            ticks or [],
            ob_depth_krw or 10_000_000,
            entry_price,
            last_price,
            c1 or [],
        )
    except Exception:
        ctx_score, ctx_reasons = (0, [])

    # í…Œì´í”„(ìµœê·¼ 15s)
    t15 = micro_tape_stats_from_ticks(ticks or [], 15)
    buy = t15.get("buy_ratio", 0.0)
    n = t15.get("n", 0)

    # ì»¨í…ìŠ¤íŠ¸(EMA5 / VWAP)
    vwap = vwap_from_candles_1m(c1 or [], 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in (c1 or [])], 5) if c1 else 0
    vwap_ok = bool(vwap and last_price >= vwap)
    ema_ok = bool(ema5 and last_price >= ema5)

    # ğŸ’ ê±°ë˜ ë‘”í™” + ì•½ìƒìŠ¹ â†’ ë³¸ì ˆ ìµì ˆ ìœ ë„
    if -0.2 <= ret_pct <= 0.4 and t15.get("krw_per_sec", 0) < 12000 and ctx_score <= ctx_thr:
        action = "ë¶€ë¶„ ì²­ì‚°(ë³¸ì ˆ)"
        rationale = f"ê±°ë˜ë‘”í™” êµ¬ê°„ ë³¸ì ˆ ìµì ˆ ({ret_pct:+.2f}%)"
        return action, rationale

    # -----------------------------
    # 1) ì „ëŸ‰ ì²­ì‚° ê¶Œê³  ì¡°ê±´ (ê°•í•œ ì²­ì‚°)
    # -----------------------------
    full_exit = False
    why_full = []

    # (1) ì†ì‹¤ì´ ë§ì´ ì»¤ì¡Œì„ ë•Œ
    if ret_pct <= -2.0:
        full_exit = True
        why_full.append(f"ì†ì‹¤ {ret_pct:+.2f}%")

    # (2) ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´ê°€ ì„ê³„ì¹˜ë³´ë‹¤ ë§ì´ ë†’ê³ , VWAP/EMAë„ ê¹¨ì ¸ ìˆì„ ë•Œ
    if ctx_score >= (ctx_thr + 1) and not vwap_ok and not ema_ok:
        full_exit = True
        why_full.append(f"ì»¨í…ìŠ¤íŠ¸ {ctx_score}/{ctx_thr}")

    # (3) ì•½ì†ì‹¤ ìƒíƒœì—ì„œ ë§¤ìˆ˜ì„¸Â·í…Œì´í”„ê°€ ë§ì´ ì£½ì€ ê²½ìš°
    if ret_pct < -0.8 and buy < 0.50 and n >= 4:
        full_exit = True
        why_full.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    if full_exit:
        action = "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ "
        rationale = " Â· ".join(why_full) if why_full else "ë¦¬ìŠ¤í¬ ìš°ìœ„"
        return action, rationale

    # -----------------------------
    # 2) ë¶€ë¶„ ì²­ì‚° ê¶Œê³  (ì• ë§¤/ê²½ê³  êµ¬ê°„)
    # -----------------------------
    partial_exit = False
    why_partial = []

    # ìˆ˜ìµì´ í¬ì§€ ì•Šì€ êµ¬ê°„
    if -0.8 < ret_pct < 0.8:
        partial_exit = True
        why_partial.append(f"ìˆ˜ìµ {ret_pct:+.2f}%")

    # ì»¨í…ìŠ¤íŠ¸ ê²½ê³  ë ˆë²¨
    if ctx_score == ctx_thr:
        partial_exit = True
        why_partial.append(f"ì»¨í…ìŠ¤íŠ¸ ê²½ê³  {ctx_score}/{ctx_thr}")

    # ë§¤ìˆ˜ë¹„ ì•½í•˜ê³  í‹±ì€ ë§ì€ ê²½ìš°
    if buy < 0.55 and n >= 6:
        partial_exit = True
        why_partial.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    # ğŸš€ ê±°ë˜ë‘”í™” ì‹œ ìë™ ë¶€ë¶„ìµì ˆ ê¶Œê³ 
    if ret_pct >= 1.5 and t15["krw_per_sec"] < 15000:
        partial_exit = True
        why_partial.append(f"ê±°ë˜ì†ë„ ë‘”í™” {t15['krw_per_sec']:.0f} KRW/s")

    # VWAP/EMA ë‘˜ ë‹¤ í•˜ë°©ì¼ ë•Œ
    if not vwap_ok and not ema_ok:
        partial_exit = True
        why_partial.append("VWAPÂ·EMA5 í•˜ë°©")

    if partial_exit:
        action = "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ "
        rationale = " Â· ".join(why_partial) if why_partial else "ë¶ˆí™•ì‹¤ êµ¬ê°„"
        return action, rationale

    # -----------------------------
    # 3) ìœ ì§€ ê¶Œê³  (ì¶”ì„¸ ìœ ì§€)
    # -----------------------------
    why_keep = [f"ìˆ˜ìµ {ret_pct:+.2f}%"]
    if vwap_ok:
        why_keep.append("VWAP ìƒë°©")
    if ema_ok:
        why_keep.append("EMA5 ìƒë°©")
    if buy >= 0.60 and n >= 4:
        why_keep.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    rationale = " Â· ".join(why_keep)
    return "ìœ ì§€ ê¶Œê³ ", rationale


# =========================
# ëª¨ë‹ˆí„°ë§(ìµœì¢…í˜•)
# =========================
def monitor_position(m,
                     entry_price,
                     pre,
                     tight_mode=False,
                     horizon=None,
                     reentry=False):
    c1 = get_minutes_candles(1, m, 20)
    base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(entry_price, c1)

    # horizonì´ ì•ˆ ë“¤ì–´ì˜¤ë©´ ìë™ ê²°ì •, ë“¤ì–´ì˜¤ë©´ ê·¸ ê°’ ì‚¬ìš©
    if horizon is None:
        horizon = decide_monitor_secs(pre, tight_mode=tight_mode)
    start_ts = time.time()
    MAX_RUNTIME = horizon * 1.5  # ìµœëŒ€ í—ˆìš© ì‹¤í–‰ì‹œê°„ (ì •ìƒì‹œê°„ì˜ 1.5ë°°)


    # ë””ë°”ìš´ìŠ¤/íŠ¸ë ˆì¼ ìƒíƒœ
    # ì†ì ˆ ë””ë°”ìš´ìŠ¤ìš©
    stop_first_seen_ts = 0.0
    stop_hits = 0
    # ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ë””ë°”ìš´ìŠ¤ìš©
    ctx_first_seen_ts = 0.0
    ctx_hits = 0

    trail_armed = False
    trail_stop = 0.0

    # ìŠ¤íŒŒì´í¬/ê·¸ë ˆì´ìŠ¤ ê¸°ì¡´ ë¡œì§ ì¬í™œìš©
    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 10
    grace_used = False
    spike_recovery_used = False

    ob = pre.get("ob")
    ob_depth_default = ob.get("depth_krw", 10_000_000) if ob else 10_000_000

    last_price = entry_price
    best = entry_price
    worst = entry_price

    # ì‹¤ì œ ë³´ìœ  ìˆ˜ëŸ‰ í™•ë³´ (ìµì ˆ ì‹œ ë§¤ë„ìš©)
    with _POSITION_LOCK:
        entry_volume = OPEN_POSITIONS.get(m, {}).get("volume", 0.0)

    verdict = None
    outcome_extra = ""

    # === ğŸ¯ ì–‡ì€ ìˆ˜ìµ ì²´í¬í¬ì¸íŠ¸ ìƒíƒœ ===
    checkpoint_reached = False   # ì–‡ì€ ìˆ˜ìµ(0.3%) ë„ë‹¬ ì—¬ë¶€
    strong_mode = False          # ê°•ì„¸ í™•ì¸ í›„ íŠ¸ë ˆì¼ë§ ëª¨ë“œ
    strong_peak = entry_price    # ê°•ì„¸ ëª¨ë“œ ì§„ì… í›„ ê³ ì  ì¶”ì 

    # === ğŸ”¥ Plateau ê°ì§€ìš© ìƒíƒœ ===
    last_peak_ts = time.time()   # ë§ˆì§€ë§‰ ê³ ì  ê°±ì‹  ì‹œê°„
    plateau_partial_done = False # Plateau ë¶€ë¶„ìµì ˆ ì™„ë£Œ ì—¬ë¶€

    # === ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¯¸ë‹ˆíŠ¸ë ˆì¼ ìƒíƒœ ===
    sideways_peak = 0.0          # 60ì´ˆ ì´í›„ ê³ ì  ì¶”ì 

    # === í¬ì§€ì…˜ ëª¨ë“œ (probe / confirm) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m, {})
    entry_mode = pos.get("entry_mode", "confirm")

    try:
        while time.time() - start_ts <= horizon:
            time.sleep(RECHECK_SEC)

            ticks = get_recent_ticks(m, 100)
            if not ticks or len(ticks) < 3:
                consecutive_failures += 1
                if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                    time.sleep(3)
                    ticks = get_recent_ticks(m, 100)
                    if not ticks:
                        verdict = "ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨"
                        break
                    consecutive_failures = 0
                continue
            consecutive_failures = 0

            # í˜„ì¬ê°€
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            if not cur_js or len(cur_js) == 0:
                continue
            curp = cur_js[0].get("trade_price", last_price)
            last_price = curp
            # âœ… íŠ¸ë ˆì¼ë§ ë˜ì¹« ë²„ê·¸ ìˆ˜ì •: ì‹ ê³ ì  íŒì • ë¨¼ì €
            new_high = curp > best
            if new_high:
                last_peak_ts = time.time()  # ğŸ”¥ Plateau ê°ì§€ìš© ê³ ì  ì‹œê°„ ê°±ì‹ 
            best = max(best, curp)
            worst = min(worst, curp)

            # === 1) ATR ê¸°ë°˜ ë™ì  ì†ì ˆ (ì›œì—… ì œê±°, ì²´ê²° ì§í›„ë¶€í„° ì ìš©) ===
            alive_sec = time.time() - start_ts
            dd_now = (curp / best - 1.0)
            cur_gain = (curp / entry_price - 1.0)

            # ğŸ”§ ì›œì—… ì œê±°: ì²´ê²° ì§í›„ë¶€í„° ATR ì†ì ˆ ì ìš©
            if cur_gain <= -eff_sl_pct:
                tg_send(f"âš ï¸ [{m}] ATRì†ì ˆ íŠ¸ë¦¬ê±° | {cur_gain*100:.2f}%")  # DEBUG
                close_auto_position(m, f"ATRì†ì ˆ | í˜„ì¬ -{abs(cur_gain)*100:.2f}% < ì†ì ˆì„  -{eff_sl_pct*100:.2f}% ({atr_info})")
                verdict = "ATRì†ì ˆ"
                outcome_extra = f"({cur_gain*100:.2f}%, SL-{eff_sl_pct*100:.2f}%)"
                break

            # === ğŸ”§ íš¡ë³´ íƒˆì¶œ ë¡œì§ (ë¯¸ë‹ˆíŠ¸ë ˆì¼ë§) ===
            # 60ì´ˆ ì´í›„ + trail_armed=False â†’ ê³ ì  ì¶”ì , ê³ ì -0.03% í•˜ë½ ì‹œ ì²­ì‚°
            if alive_sec >= SIDEWAYS_TIMEOUT and not trail_armed:
                # ê³ ì  ê°±ì‹ 
                sideways_peak = max(sideways_peak, cur_gain)

                # ì²­ì‚° ì¡°ê±´: ê³ ì ì—ì„œ 0.03% í•˜ë½
                SIDEWAYS_TRAIL_DROP = 0.0003  # 0.03%
                if cur_gain < sideways_peak - SIDEWAYS_TRAIL_DROP:
                    tg_send(f"âš ï¸ [{m}] íš¡ë³´íƒˆì¶œ íŠ¸ë¦¬ê±° | {alive_sec:.0f}ì´ˆ")  # DEBUG
                    close_auto_position(m, f"íš¡ë³´íƒˆì¶œ | {alive_sec:.0f}ì´ˆ ê³ ì {sideways_peak*100:.2f}%â†’í˜„ì¬{cur_gain*100:.2f}%")
                    verdict = "íš¡ë³´íƒˆì¶œ"
                    outcome_extra = f"(ê³ ì {sideways_peak*100:.2f}%â†’{cur_gain*100:.2f}%, {alive_sec:.0f}ì´ˆ)"
                    break

            # === 2) íŠ¸ë ˆì¼ë§ ì†ì ˆ: ì´ìµì´ ë‚˜ì•¼ë§Œ ë¬´ì¥
            gain_from_entry = (curp / entry_price - 1.0)
            
            # === PROBE â†’ CONFIRM ì „í™˜ ë¡œì§ ===
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m, {})

            if pos.get("entry_mode") == "probe":
                # ì „í™˜ ì¡°ê±´: ì¼ì • ìˆ˜ìµ ì´ìƒ + ê±°ë˜ì†ë„ ì •ìƒ + ë§¤ìˆ˜ì„¸ ìœ ì§€
                t15_now = micro_tape_stats_from_ticks(ticks, 15)
                # ğŸ”§ FIX: Decimal ì œê±° (floatì™€ ë¹„êµ ì‹œ TypeError ë°œìƒ)
                gain_now = (curp / entry_price - 1.0)

                strong_flow = (
                    t15_now["buy_ratio"] >= 0.58
                    and t15_now["krw_per_sec"] >= 18000
                    and uptick_streak_from_ticks(ticks, need=2)
                )

                if gain_now >= 0.012 and strong_flow:
                    add_reason = f"ìƒìŠ¹í™•ì • (ìˆ˜ìµ+{gain_now*100:.1f}% ë§¤ìˆ˜ë¹„{t15_now['buy_ratio']:.0%} ì´ˆë‹¹{t15_now['krw_per_sec']/1000:.0f}K)"
                    ok_add, new_entry = add_auto_position(m, curp, add_reason)
                    if ok_add and new_entry:
                        # ì§„ì…ëª¨ë“œ ìŠ¹ê²©
                        with _POSITION_LOCK:
                            pos["entry_mode"] = "confirm"
                            pos["entry_price"] = new_entry
                            pos["added"] = True
                            pos["last_add_ts"] = time.time()
                            OPEN_POSITIONS[m] = pos

                        tg_send_mid(
                            f"ğŸ”¥ {m} ìƒìŠ¹ í™•ì • â†’ probe âœ confirm ì „í™˜\n"
                            f"ì¶”ë§¤ í›„ í‰ë‹¨: {fmt6(new_entry)}ì›"
                        )

                        # ë™ì  ì†ì ˆ ì¬ê³„ì‚°
                        c1_for_sl = get_minutes_candles(1, m, 20)
                        base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(new_entry, c1_for_sl)
                        trail_armed = False  # ìƒˆ ê¸°ì¤€ìœ¼ë¡œ íŠ¸ë ˆì¼ë§ ë¦¬ì…‹

            if (not trail_armed) and gain_from_entry >= PROFIT_CHECKPOINT:
                trail_armed = True
                # ğŸ”§ ë‹¨ê³„ë³„ íƒ€ì´íŠ¸ íŠ¸ë ˆì¼ë§ ì ìš© (ì‹¤ì „ë¶„ì„ ê¸°ë°˜)
                tiered_dist = get_tiered_trail_dist(gain_from_entry)
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(tiered_dist,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = tiered_dist
                trail_stop = curp * (1.0 - trail_dist)

            # === 2-1) í”¼ë¼ë¯¸ë”©(ì¶”ë§¤): ì™„í™”í˜• ë¡œì§ (ë¶€ë¶„ì²­ì‚° í›„ ì¬ìƒìŠ¹ ëŒ€ì‘) ===
            if USE_PYRAMIDING and AUTO_TRADE:
                t15_now = micro_tape_stats_from_ticks(ticks, 15)

                # ğŸ’¡ ì¡°ê±´ ì™„í™” â€” ì•½ìƒìŠ¹ì—ì„œë„ ë°˜ì‘í•˜ë„ë¡
                add_cond_price = gain_from_entry >= max(0.005, PYRAMID_ADD_MIN_GAIN * 0.8)
                add_cond_flow = (
                    t15_now["buy_ratio"] >= 0.55 and
                    t15_now["krw_per_sec"] >= PYRAMID_ADD_FLOW_MIN_KRWPSEC * 0.8 and
                    last_two_ticks_fresh(ticks)
                )

                # ğŸ“Š ë‹¨ê¸° EMA ê¸°ì¤€ìœ¼ë¡œ ë‹¨ê¸° ìƒìŠ¹ ì „í™˜ ê°ì§€ (1ë¶„ë´‰)
                c1m = get_minutes_candles(1, m, 20)
                ema3 = ema_last([c["trade_price"] for c in c1m], 3)
                ema8 = ema_last([c["trade_price"] for c in c1m], 8)
                short_term_up = ema3 > ema8

                if add_cond_price and add_cond_flow and short_term_up:
                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        already_added = pos.get("added") if pos else True
                        last_add_ts = pos.get("last_add_ts", 0.0) if pos else 0.0

                    # ì¿¨ë‹¤ìš´ì„ 40% ë‹¨ì¶•í•´ ì¬ì§„ì…ì„± í–¥ìƒ
                    cooldown_ok = (time.time() - last_add_ts) >= (PYRAMID_ADD_COOLDOWN_SEC * 0.6)

                    if pos and (not already_added) and cooldown_ok:
                        add_reason = f"ì¬ìƒìŠ¹EMA (ìˆ˜ìµ+{gain_from_entry*100:.1f}% ë§¤ìˆ˜ë¹„{t15_now['buy_ratio']:.0%} EMA3>EMA8)"
                        ok_add, new_entry = add_auto_position(m, curp, add_reason)
                        if ok_add and new_entry:
                            entry_price = new_entry
                            c1_for_sl = get_minutes_candles(1, m, 20)
                            base_stop, eff_sl_pct, atr_info = dynamic_stop_loss(entry_price, c1_for_sl)

            # ğŸ”§ FIX: íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸ - new_high ì‚¬ìš© (curp > bestëŠ” best ê°±ì‹  í›„ë¼ í•­ìƒ False)
            if trail_armed and new_high:
                # ğŸ”§ ë‹¨ê³„ë³„ íƒ€ì´íŠ¸ íŠ¸ë ˆì¼ë§ ì ìš© (ìˆ˜ìµ êµ¬ê°„ë³„ ê°„ê²© ì¡°ì •)
                tiered_dist = get_tiered_trail_dist(gain_from_entry)
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(tiered_dist,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = tiered_dist
                trail_stop = max(trail_stop, curp * (1.0 - trail_dist))

            # ğŸ”§ [ì‹ ê·œ] íŠ¸ë ˆì¼ë§ ì†ì ˆ ì‹¤ì œ ì²­ì‚° íŠ¸ë¦¬ê±°
            if trail_armed and curp < trail_stop:
                trail_gain = (curp / entry_price - 1.0)
                peak_gain = (best / entry_price - 1.0)
                drop_pct = (best - curp) / best * 100
                tg_send(f"âš ï¸ [{m}] íŠ¸ë ˆì¼ë§ì†ì ˆ íŠ¸ë¦¬ê±° | {trail_gain*100:+.2f}%")  # DEBUG
                close_auto_position(m, f"íŠ¸ë ˆì¼ë§ì†ì ˆ +{trail_gain*100:.2f}% (ê³ ì +{peak_gain*100:.2f}%ì—ì„œ -{drop_pct:.2f}% í•˜ë½)")
                verdict = "TRAIL_STOP"
                break

            # ğŸ”§ [ì œê±°ë¨] ë¸Œë ˆì´í¬ì´ë¸ â†’ íŠ¸ë ˆì¼ë§ 0.4% ë°œë™ìœ¼ë¡œ ëŒ€ì²´
            # íŠ¸ë ˆì¼ë§ì´ +0.4%ì—ì„œ ë°œë™ë˜ë©´ íŠ¸ë ˆì¼ìŠ¤íƒ‘ì´ ìë™ìœ¼ë¡œ ë³¸ì ˆ ì´ìƒì´ ë¨
            in_breakeven_box = abs(gain_from_entry) <= BREAKEVEN_BOX  # Â±0.15% ë°•ìŠ¤ ë‚´ (ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©)

            # === ğŸ”¥ ì‹¬í”Œ ì²´í¬í¬ì¸íŠ¸ ë§¤ë„ ë¡œì§ ===
            cur_gain = (curp / entry_price - 1.0)
            ob_now = pre.get("ob", {})

            # === ğŸ¯ ATR ê¸°ë°˜ ë™ì  ì†ì ˆ (í‹±ìŠ¤íƒ‘ ì œê±°ë¨) ===
            # ì´ë¯¸ line 4876ì—ì„œ ì›œì—… ì—†ì´ ì¦‰ì‹œ ATR ì†ì ˆ ì ìš© ì¤‘
            # ì—¬ê¸°ëŠ” íŠ¸ë ˆì¼ë§ ì†ì ˆ ì´í›„ ì¶”ê°€ ì†ì ˆ íŒì •ìš©

            # â‘¡ ì²´í¬í¬ì¸íŠ¸ ë„ë‹¬ ì‹œ ê°•ì„¸/ì•½ì„¸ íŒë‹¨
            # ğŸ”§ FIX: ì²´í¬í¬ì¸íŠ¸ ì¬í‰ê°€ - ê°€ê²©ì´ 30% ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ ë¦¬ì…‹
            if checkpoint_reached and cur_gain < (PROFIT_CHECKPOINT * 0.3):
                checkpoint_reached = False  # ì²´í¬í¬ì¸íŠ¸ ì•„ë˜ë¡œ ë–¨ì–´ì§ â†’ ì¬í‰ê°€ í—ˆìš©

            # ğŸ”§ ì†Œí”„íŠ¸ ê°€ë“œ: ì´ˆê¸° 30ì´ˆê°„ ì²­ì‚° ì¡°ê±´ ê°•í™”
            in_soft_guard = alive_sec < SOFT_GUARD_SEC

            if not checkpoint_reached and cur_gain >= PROFIT_CHECKPOINT:
                checkpoint_reached = True
                # ğŸ”§ [ë³€ê²½] ê°•ì„¸/ì•½ì„¸ íŒë‹¨ â†’ ì•½ì„¸ë§Œ 25% ë¶€ë¶„ìµì ˆ, ê°•ì„¸ëŠ” íŠ¸ë ˆì¼ë§ì— ë§¡ê¹€
                if is_strong_momentum(ticks, ob_now):
                    # ê°•ì„¸ â†’ íŠ¸ë ˆì¼ë§ì´ ì•Œì•„ì„œ ì²˜ë¦¬ (ê°•ì„¸ëª¨ë“œ ë™ì íŠ¸ë ˆì¼ ì œê±°ë¨)
                    tg_send_mid(f"ğŸ’ª {m} +{cur_gain*100:.2f}% ê°•ì„¸ â†’ íŠ¸ë ˆì¼ë§ ìœ ì§€")
                else:
                    # ì•½ì„¸ íŒì •ì´ì§€ë§Œ ì†Œí”„íŠ¸ ê°€ë“œ + ë°•ìŠ¤ ë‚´ë©´ í™€ë”©
                    if in_soft_guard and in_breakeven_box:
                        # ì´ˆê¸° 30ì´ˆ + Â±0.15% ë°•ìŠ¤ â†’ í™€ë”© (íœ©ì˜ ë°©ì§€)
                        tg_send_mid(f"â³ {m} ì•½ì„¸ íŒì •ì´ë‚˜ ì†Œí”„íŠ¸ê°€ë“œ êµ¬ê°„ â†’ ê´€ì°° ìœ ì§€")
                    else:
                        # ì•½ì„¸ â†’ 25% ë¶€ë¶„ìµì ˆ (ë‚˜ë¨¸ì§€ 75%ëŠ” íŠ¸ë ˆì¼ë§/ATRì†ì ˆ)
                        ok, msg, sold = safe_partial_sell(m, 0.25, f"ì–‡ì€ìˆ˜ìµ ìŠ¤ìº˜í•‘ +{cur_gain*100:.2f}% ì•½ì„¸íŒì •")
                        if ok:
                            tg_send_mid(f"ğŸ’° {m} +{cur_gain*100:.2f}% ì•½ì„¸ â†’ 25% ìŠ¤ìº˜í•‘ ì™„ë£Œ")

            # ğŸ”§ [ì œê±°ë¨] ê°•ì„¸ëª¨ë“œ ë™ì  íŠ¸ë ˆì¼ë§ â†’ ì¼ë°˜ íŠ¸ë ˆì¼ë§(0.2% ê°„ê²©)ìœ¼ë¡œ ëŒ€ì²´

            # ğŸ”§ [ì œê±°ë¨] Giveback Cap / Peak Giveback â†’ íŠ¸ë ˆì¼ë§ìœ¼ë¡œ ëŒ€ì²´
            # íŠ¸ë ˆì¼ë§ ê°„ê²© 0.25%ë¡œ íƒ€ì´íŠ¸í™”í•˜ì—¬ ë™ì¼ íš¨ê³¼ ë‹¬ì„±
            max_gain = (best / entry_price - 1.0)  # MFE ìˆ˜ìµë¥  (ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©)
            cur_gain_now = (curp / entry_price - 1.0)  # í˜„ì¬ ìˆ˜ìµë¥ 

            # === ğŸ”¥ (B) Plateau + ëª¨ë©˜í…€ ì•½í™” â†’ ë¶€ë¶„ìµì ˆ + ë³¸ì ˆìƒí–¥ ===
            # ì¡°ê±´: ê³ ì  ê°±ì‹  20ì´ˆ ì—†ìŒ + buy_decay + ìˆ˜ìµ ì¤‘ + ì•„ì§ ë¶€ë¶„ìµì ˆ ì•ˆí•¨
            PLATEAU_SEC = 20  # ê³ ì  ê°±ì‹  ì—†ì´ ë²„í‹´ ì‹œê°„
            # ğŸ”§ [í†µí•©ë¨] PLATEAU_MIN_GAIN â†’ PROFIT_CHECKPOINT (ìƒë‹¨ ì •ì˜)
            BE_OFFSET = FEE_RATE + 0.0005  # ë³¸ì ˆ = ìˆ˜ìˆ˜ë£Œ(0.1%) + ì—¬ìœ (0.05%) = 0.15%

            time_since_peak = time.time() - last_peak_ts
            if (not plateau_partial_done
                and cur_gain_now >= PROFIT_CHECKPOINT
                and time_since_peak >= PLATEAU_SEC):

                decay_flag, decay_info = buy_decay_flag(ticks)
                if decay_flag:
                    # ë¶€ë¶„ìµì ˆ ì‹¤í–‰ (50%)
                    ok, msg, sold = safe_partial_sell(m, 0.5, f"Plateauë¶€ë¶„ìµì ˆ +{cur_gain_now*100:.2f}% (ê³ ì í›„ {time_since_peak:.0f}ì´ˆ íš¡ë³´+ë§¤ìˆ˜ì•½í™”)")
                    if ok:
                        plateau_partial_done = True
                        # ğŸ”¥ ë³¸ì ˆ ìƒí–¥: ë‚¨ì€ 50%ëŠ” ìµœì†Œí•œ ì†í•´ ì•ˆ ë³´ê²Œ
                        be_stop = entry_price * (1.0 + BE_OFFSET)
                        base_stop = max(base_stop, be_stop)
                        tg_send_mid(f"ğŸ“‰ {m} Plateau ë¶€ë¶„ìµì ˆ 50% | +{cur_gain_now*100:.2f}% | ì†ì ˆì„ â†’ë³¸ì ˆ({BE_OFFSET*100:.2f}%) ìƒí–¥")

            # â‘£ ëˆŒë¦¼ í›„ ì¬ìƒìŠ¹ ê°ì§€ â†’ íŠ¸ë ˆì¼ ê°•í™” (ì¬ì§„ì… ëŒ€ì‹ )
            drop_from_high = (best - curp) / best if best > 0 else 0
            if drop_from_high >= 0.005 and uptick_streak_from_ticks(ticks, need=3):
                if trail_armed:
                    # ì¬ì§„ì… ëŒ€ì‹  íŠ¸ë ˆì¼ ê°„ê²© íƒ€ì´íŠ¸í•˜ê²Œ ê°•í™”
                    trail_stop = max(trail_stop, curp * (1.0 - max(TRAIL_DISTANCE_MIN * 0.8, 0.0025)))
                    tg_send_mid(f"ğŸ”§ {m} ì¬ìƒìŠ¹ ê°ì§€ â†’ íŠ¸ë ˆì¼ ê°•í™”")
        
        if verdict is None:
            verdict = "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)"

    except Exception as _mon_ex:
        # ğŸ”§ DEBUG: ëª¨ë‹ˆí„°ë§ ë£¨í”„ ë‚´ ì˜ˆì™¸ ë°œìƒ ì‹œ í…”ë ˆê·¸ë¨ ì•ŒëŒ
        print(f"[MON_LOOP_ERR] {m}: {_mon_ex}")
        import traceback
        traceback.print_exc()
        tg_send(f"âŒ [{m}] ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜ˆì™¸\n{str(_mon_ex)[:100]}")
        verdict = f"ì˜ˆì™¸ë°œìƒ: {str(_mon_ex)[:50]}"

    finally:
        # ================================
        # 1) ìµœì‹  ìƒíƒœ / ìˆ˜ìµë¥  ê³„ì‚°
        # ================================
        ticks = get_recent_ticks(m, 100)
        t15 = micro_tape_stats_from_ticks(ticks, 15) if ticks else {
            "buy_ratio": 0,
            "krw": 0,
            "n": 0,
            "krw_per_sec": 0
        }

        ob = pre.get("ob") or {}
        ob_depth_krw = ob.get("depth_krw", 10_000_000)

        try:
            ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
        except:
            ret_pct = 0.0

        maxrun = (best / entry_price - 1.0) * 100.0
        maxdd = (worst / entry_price - 1.0) * 100.0

        # ================================
        # 2) ëì•ŒëŒ ë¬¸êµ¬ ìƒì„±
        # ================================
        action, rationale = _end_reco(entry_price,
                                      last_price,
                                      c1,
                                      ticks,
                                      ob_depth_krw,
                                      ctx_thr=CTX_EXIT_THRESHOLD)

        # ===========================================
        # ëì•ŒëŒ / ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™”
        #  (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ê³¼ë‹¤ ë°©ì§€)
        # ===========================================
        if not reentry:
            pass  # ëì•ŒëŒ ë¹„í™œì„±í™”
        else:
            pass  # ì¬ëª¨ë‹ˆí„°ë§ ìš”ì•½ ë¹„í™œì„±í™”

        # ===========================================
        # ì¬ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
        #  - ìµœì´ˆ ëª¨ë‹ˆí„°ë§ì—ì„œë§Œ í˜¸ì¶œ
        #  - remonitor_until_close()ì—ì„œ ì¬í˜¸ì¶œëœ ê²½ìš°(reentry=True)ëŠ” ë‹¤ì‹œ ì•ˆ ë“¤ì–´ê°
        # ===========================================
        # âœ… ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™” (ë¶ˆí•„ìš”í•œ ë°˜ë³µ ë©”ì‹œì§€ ë°©ì§€)
        # (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ, ì•Œë¦¼ ë°œì†¡ë§Œ ì°¨ë‹¨)
        if AUTO_TRADE and m in OPEN_POSITIONS and not reentry:
            remonitor_until_close(m, entry_price, pre, tight_mode)

        # ===========================================
        # 3) probe ì†ì ˆ í›„ ë¹ ë¥¸ ì¬ì§„ì… í—ˆìš© ë¡œì§
        # ===========================================
        if AUTO_TRADE and verdict and "ì†ì ˆ" in verdict:
            # ğŸ”§ FIX: ë½ ë°–ì—ì„œ ì¬ì§„ì… ì—¬ë¶€ íŒë‹¨ í›„ sleep/remonitor ìˆ˜í–‰
            should_remonitor = False
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m)
                if pos and pos.get("entry_mode") == "probe":
                    # ìµœê·¼ ì¢…ë£Œ ì‹œê° ê¸°ë¡
                    pos["last_exit_ts"] = time.time()
                    OPEN_POSITIONS[m] = pos
                    should_remonitor = True

            # ğŸ”§ ë½ ë°–ì—ì„œ sleep ë° remonitor (ë½ 2ë¶„ ì ìœ  ë°©ì§€)
            if should_remonitor:
                REMONITOR_QUICK_COOLDOWN_SEC = 120  # 2ë¶„ ì¿¨ë‹¤ìš´
                time.sleep(REMONITOR_QUICK_COOLDOWN_SEC)
                remonitor_until_close(m, entry_price, pre, tight_mode)

        # ğŸ‘‡ ì´ return ì€ if ë°”ê¹¥ì—ì„œ í•­ìƒ ì‹¤í–‰ë˜ê²Œ
        return (
            verdict,
            action,
            rationale,
            ret_pct,
            last_price,
            maxrun,
            maxdd,
        )


# =========================
# ì•Œë¦¼
# =========================
def tg_send(t, retry=1):
    # TG_TOKEN ì—†ê±°ë‚˜ CHAT_IDSê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì½˜ì†”ì—ë§Œ ì¶œë ¥
    if not TG_TOKEN or not CHAT_IDS:
        print(t)
        return True

    ok_any = False
    for cid in CHAT_IDS:
        payload = {
            "chat_id": cid,
            "text": t,
            "parse_mode": "HTML",
            "disable_web_page_preview": True,
        }
        for _ in range(retry + 1):
            try:
                r = SESSION.post(
                    f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                    json=payload,
                    timeout=4,
                )
                if r.status_code == 200:
                    js = r.json()
                    if js.get("ok") is True:
                        ok_any = True
                        break
                else:
                    # ë””ë²„ê¹…ìš©
                    print(f"[TG][{cid}] status={r.status_code} body={r.text}")
            except Exception as e:
                print(f"[TG][{cid}] exception: {e}")
            time.sleep(0.25 + rnd() * 0.25)
    return ok_any


# =========================
# ë©”ì¸ ë£¨í”„ ì¤€ë¹„
# =========================
last_signal_at = {}
recent_alerts = {}
last_price_at_alert = {}
last_reason = {}
last_trade_was_loss = {}  # ğŸ”§ ì†ì‹¤ í›„ ì¿¨ë‹¤ìš´ 2ë°°ìš©
ALERT_TTL = 1800

# =========================
# ì‹œê°„ëŒ€ë³„ ì¿¨ë‹¤ìš´ ì„¤ì •
# =========================
def get_cooldown_sec(market: str) -> int:
    """
    ê°™ì€ ì¢…ëª© ì¬ì§„ì… ëŒ€ê¸° ì‹œê°„(ì´ˆ)
    - 09ì‹œëŒ€: 3ë¶„
    - 10~14ì‹œ: 5ë¶„
    - ê·¸ ì™¸: ê¸°ë³¸ COOLDOWN(8ë¶„)
    - ğŸ”§ ì†ì‹¤ í›„: ì¿¨ë‹¤ìš´ 2ë°°
    """
    h = now_kst().hour

    if h == 9:
        base = 180  # 3ë¶„
    elif 10 <= h <= 14:
        base = 300  # 5ë¶„
    else:
        base = COOLDOWN  # ì „ì—­ ê¸°ë³¸ê°’(480)

    # ğŸ”§ ì†ì‹¤ í›„ ë™ì¼ ì¢…ëª© ì¬ì§„ì… ì¿¨ë‹¤ìš´ 2ë°°
    if last_trade_was_loss.get(market, False):
        return base * 2

    return base

def cooldown_ok(market, price=None, reason=None):
    now = time.time()
    last = last_signal_at.get(market, 0)

    # âœ… ì‹œê°„ëŒ€ë³„ ë™ì  ì¿¨ë‹¤ìš´ ì ìš©
    cooldown = get_cooldown_sec(market)

    # ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì¡°ê±´
    if (now - last) >= cooldown:
        return True

    # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(ì¬ëŒíŒŒ/ë˜ëŒë¦¼ ì¬ì§„ì… í—ˆìš©)ëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
    if (now - last) >= REARM_MIN_SEC:
        lp = last_price_at_alert.get(market)
        rebreak = (price and lp and (price >= lp * (1.0 + REARM_PRICE_GAP)))
        reason_changed = (last_reason.get(market) != reason)
        rebreak_small = (price and lp
                         and (price >= lp * (1.0 + REARM_REBREAK_MIN))
                         and not reason_changed)
        pullback = (price and lp
                    and (price <= lp * (1.0 - REARM_PULLBACK_MAX)))
        if rebreak or rebreak_small or (pullback and reason_changed):
            return True
    return False

def cleanup_expired(dic, ttl):
    now = time.time()
    drop = [k for k, v in dic.items() if now - v >= ttl]
    for k in drop:
        dic.pop(k, None)


# =========================
# ì„¤ì • ê²€ì¦
# =========================
def validate_config():
    errors = []
    warnings = []
    if TOP_N > 200: errors.append(f"TOP_N={TOP_N} ë„ˆë¬´ í¼ (â‰¤200 ê¶Œì¥)")
    if STOP_LOSS_PCT >= 0.05:
        warnings.append(f"STOP_LOSS_PCT={STOP_LOSS_PCT*100:.1f}% í¼ (<5%)")
    if PARALLEL_WORKERS > 30:
        warnings.append(f"PARALLEL_WORKERS={PARALLEL_WORKERS} ê³¼ë‹¤")
    if MIN_TURNOVER <= 0 or MIN_TURNOVER >= 1:
        errors.append(f"MIN_TURNOVER={MIN_TURNOVER} ë²”ìœ„ ì˜¤ë¥˜ (0~1)")
    if TICKS_BUY_RATIO < 0.5 or TICKS_BUY_RATIO > 1:
        errors.append(f"TICKS_BUY_RATIO={TICKS_BUY_RATIO} ë²”ìœ„ ì˜¤ë¥˜ (0.5~1)")
    if not TG_TOKEN or not CHAT_IDS: warnings.append("í…”ë ˆê·¸ë¨ ë¯¸ì„¤ì • - ì½˜ì†” ì¶œë ¥ë§Œ ì‚¬ìš©")
    if _BUCKET.get("rate", 0) <= 0: warnings.append("í† í°ë²„í‚· rate<=0 â†’ 0.1ë¡œ í´ë¨í”„")
    if _BUCKET.get("cap", 0) <= 0: warnings.append("í† í°ë²„í‚· cap<=0 â†’ 1.0ë¡œ í´ë¨í”„")
    if warnings:
        print("[CONFIG_WARNING]")
        for w in warnings:
            print("  âš ï¸", w)
    if errors:
        print("[CONFIG_ERROR]")
        for e in errors:
            print("  âŒ", e)
        sys.exit(1)
    print("âœ… ì„¤ì • ê²€ì¦ ì™„ë£Œ")


# =========================
# í—¬ìŠ¤ì²´í¬ ì„œë²„(ì˜µì…˜)
# =========================
from http.server import HTTPServer, BaseHTTPRequestHandler

bot_start_time = 0


class HealthHandler(BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        if self.path == "/health":
            status = {
                "status":
                "running",
                "version":
                "3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry",
                "uptime_sec":
                int(time.time() - bot_start_time),
                "uptime_str":
                str(timedelta(seconds=int(time.time() - bot_start_time))),
                "last_scan":
                now_kst_str(),
                "req_stats":
                REQ_STATS,
                "alerts_count":
                len(last_signal_at),
                "cache_size":
                len(_TICKS_CACHE.cache)
                if hasattr(_TICKS_CACHE, 'cache') else 0,
                "config": {
                    "top_n": TOP_N,
                    "scan_interval": SCAN_INTERVAL,
                    "stop_loss_pct": STOP_LOSS_PCT
                }
            }
            self.send_response(200)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(
                json.dumps(status, ensure_ascii=False).encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_health_server(port=8080):
    for p in range(port, port + 5):
        try:
            server = HTTPServer(("0.0.0.0", p), HealthHandler)
            thread = threading.Thread(target=server.serve_forever, daemon=True)
            thread.start()
            print(f"ğŸ¥ Health check server: http://localhost:{p}/health")
            return
        except OSError:
            continue
    print("[HEALTH_ERR] í¬íŠ¸ ì‚¬ìš© ë¶ˆê°€ (8080~8084)")


def start_watchdogs():
    """ì›Œì¹˜ë… ìŠ¤ë ˆë“œë“¤ ì‹œì‘: í—¬ìŠ¤ë¹„íŠ¸, ì„¸ì…˜ ë¦¬í”„ë ˆì‹œ, ë½ ì²­ì†Œ"""

    def heartbeat():
        """5ë¶„ë§ˆë‹¤ ìƒíƒœ ë¡œê¹… (ì¡°ìš©íˆ ì£½ì—ˆëŠ”ì§€ í™•ì¸ìš©)"""
        while True:
            try:
                time.sleep(300)  # 5ë¶„
                req_summary()     # 429/5xx/ì—ëŸ¬ ì¹´ìš´íŠ¸
                cut_summary()     # í•„í„° ì»· ì¹´ìš´íŠ¸ ìš”ì•½
                print(f"[HB] {now_kst_str()} open={len(OPEN_POSITIONS)} "
                      f"rate={_BUCKET.get('rate', 0):.2f} cap={_BUCKET.get('cap', 0):.2f}")
            except Exception as e:
                print(f"[HB_ERR] {e}")

    def session_refresher():
        """10ë¶„ë§ˆë‹¤ ì„¸ì…˜ ë¦¬í”„ë ˆì‹œ (ì»¤ë„¥ì…˜ í’€ ì •ë¦¬)"""
        while True:
            time.sleep(600)  # 10ë¶„
            try:
                _refresh_session()
            except Exception as e:
                print(f"[SESSION_REFRESH_ERR] {e}")

    def lock_cleaner():
        """10ë¶„ë§ˆë‹¤ ì˜¤ë˜ëœ ë½íŒŒì¼ ì •ë¦¬"""
        while True:
            time.sleep(600)  # 10ë¶„
            try:
                cleanup_stale_entry_locks(300)  # 5ë¶„ ì´ìƒ ëœ ë½ ì‚­ì œ
            except Exception as e:
                print(f"[LOCK_CLEANER_ERR] {e}")

    threading.Thread(target=heartbeat, daemon=True, name="Heartbeat").start()
    threading.Thread(target=session_refresher, daemon=True, name="SessionRefresh").start()
    threading.Thread(target=lock_cleaner, daemon=True, name="LockCleaner").start()
    print("ğŸ• ì›Œì¹˜ë… ì‹œì‘ë¨ (í—¬ìŠ¤ë¹„íŠ¸ 5ë¶„, ì„¸ì…˜ë¦¬í”„ë ˆì‹œ 10ë¶„, ë½ì²­ì†Œ 10ë¶„)")


# ===== ì˜¤ë”ë¶ ìºì‹œ =====
def fetch_orderbook_cache(mkts):
    cache = {}
    for i in range(0, len(mkts), 15):
        js = safe_upbit_get("https://api.upbit.com/v1/orderbook",
            {"markets": ",".join(mkts[i:i + 15])},
            timeout=6)
        if not js: continue
        for ob in js:
            try:
                units = ob["orderbook_units"][:3]
                ask, bid = units[0]["ask_price"], units[0]["bid_price"]
                spread = (ask - bid) / max((ask + bid) / 2, 1) * 100
                askv = sum(u["ask_price"] * u["ask_size"] for u in units)
                bidv = sum(u["bid_price"] * u["bid_size"] for u in units)
                cache[ob["market"]] = {
                    "spread": spread,
                    "depth_krw": askv + bidv,
                    "raw": ob
                }
            except:
                pass
    return cache


# =========================
# ë©”ì¸
# =========================
SHARD_SIZE = TOP_N
_cursor = 0
_last_learn_ts = 0  # ë§ˆì§€ë§‰ í•™ìŠµ ì‹œê°


def main():
    global _cursor, _last_learn_ts

    # ğŸ§  ì‹œì‘ ì‹œ í•™ìŠµëœ ê°€ì¤‘ì¹˜ & ë§¤ë„ íŒŒë¼ë¯¸í„° ë¡œë“œ
    if AUTO_LEARN_ENABLED:
        load_learned_weights()
        load_exit_params()

    tg_send(
        f"ğŸš€ ëŒ€ì¥ì´ˆì… í—Œí„° v3.2.7+Score (ìë™í•™ìŠµ+ë™ì ë§¤ë„) ì‹œì‘\n"
        f"ğŸ“Š TOP {TOP_N} | í•™ìŠµ: {AUTO_LEARN_MIN_TRADES}ê±´~ | {now_kst_str()}"
    )

    # ğŸ”§ ì‹œì‘ ì‹œ 1íšŒë§Œ ìœ ë ¹ í¬ì§€ì…˜ ë™ê¸°í™” (ì´ì „ ì„¸ì…˜ì—ì„œ ì²­ì‚° ì•ˆ ëœ ê²ƒë§Œ)
    # ì´í›„ ë´‡ì´ ë§¤ìˆ˜í•˜ëŠ” ê²ƒë“¤ì€ OPEN_POSITIONSì— ë°”ë¡œ ë“±ë¡ë˜ë¯€ë¡œ ìœ ë ¹ ì·¨ê¸‰ ì•ˆ í•¨
    global _LAST_ORPHAN_SYNC
    _LAST_ORPHAN_SYNC = 0  # ê°•ì œ ë¦¬ì…‹
    sync_orphan_positions()

    while True:
        try:
            # ğŸ”§ Health check - watchdogìš© íŒŒì¼ ì—…ë°ì´íŠ¸
            try:
                with open("/home/ubuntu/bot/health.log", "w") as hf:
                    hf.write(f"{time.time()}\n")
            except:
                pass

            # BTC_guard ì œê±° â€” í•­ìƒ ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰
            tight_mode = False

            # ğŸ”§ ì²­ì‚° ì‹¤íŒ¨í•œ í¬ì§€ì…˜ë“¤ ì¬ì‹œë„ (30ì´ˆ ì¿¨íƒ€ì„)
            # â†’ ë´‡ì´ ë§¤ìˆ˜í•œ ê²ƒë“¤ì€ ê±´ë“œë¦¬ì§€ ì•Šê³ , ì²­ì‚° ì‹œë„í–ˆë‹¤ê°€ ì‹¤íŒ¨í•œ ê²ƒë§Œ ì¬ì‹œë„
            retry_pending_closes()

            # ğŸ”§ í•™ìŠµì€ update_trade_resultì—ì„œ ê±´ìˆ˜ ê¸°ë°˜ìœ¼ë¡œ ìë™ íŠ¸ë¦¬ê±°ë¨
            # (10ê±´ë§ˆë‹¤ ë˜ëŠ” ì—°ì† 3íŒ¨ ì‹œ ì¦‰ì‹œ í•™ìŠµ)
            # ë§¤ë„ íŒŒë¼ë¯¸í„°ëŠ” ê³ ì • (ë§¤ìˆ˜ë§Œ í•™ìŠµ)

            for k in list(CUT_COUNTER.keys()):
                CUT_COUNTER[k] = 0

            cleanup_expired(recent_alerts, ALERT_TTL)
            cleanup_expired(last_signal_at, COOLDOWN)
            _TICKS_CACHE.purge_older_than(max_age_sec=2.5)
            _C5_CACHE.purge_older_than(max_age_sec=2.5)

            mkts_all = get_top_krw_by_24h(TOP_N)
            if not mkts_all:
                aligned_sleep(SCAN_INTERVAL)
                continue

            start = _cursor
            end = _cursor + SHARD_SIZE
            shard = mkts_all[start:end]
            if len(shard) < SHARD_SIZE:
                shard += mkts_all[:(SHARD_SIZE - len(shard))]
            # ğŸ”§ FIX: shard ì¤‘ë³µ ì œê±° (wrap-around ì‹œ ì¤‘ë³µ ë°©ì§€)
            shard = list(dict.fromkeys(shard))
            _cursor = (end) % len(mkts_all)

            obc = fetch_orderbook_cache(shard)

            c1_cache = {}
            use_workers = min(PARALLEL_WORKERS, len(shard))
            with ThreadPoolExecutor(max_workers=use_workers) as exe:
                futures = {
                    exe.submit(get_minutes_candles, 1, m, 20): m
                    for m in shard
                }
                for f in as_completed(futures):
                    m = futures[f]
                    try:
                        c1_cache[m] = f.result() or []
                    except:
                        c1_cache[m] = []

            found = 0
            for m in shard:
              try:  # ğŸ”§ ì‹¬ë³¼ë³„ ì˜ˆì™¸ ê²©ë¦¬ (í•œ ì‹¬ë³¼ ì—ëŸ¬ê°€ ì „ì²´ ìŠ¤ìº” ì¤‘ë‹¨ ë°©ì§€)
                c1 = c1_cache.get(m, [])
                if not c1: continue

                pre = detect_leader_stock(m, obc, c1, tight_mode=tight_mode)
                if not pre: continue

                # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… ëª¨ë“œ ì¶”ê°€ (probe/confirm ë¶„ë¦¬) ===
                # ğŸ”§ í‚¬ëŸ¬ ì¡°ê±´: ëª¨ë“  ì¡°ê±´ ì¶©ì¡± ì‹œì—ë§Œ í’€ì§„ì…
                buy_ratio = pre["tape"]["buy_ratio"]
                volume_surge = pre.get("volume_surge", 1.0)
                current_vol = pre.get("current_volume", 0)
                # ğŸ”§ FIX: turn/imbalanceëŠ” tapeì— ì—†ìŒ â†’ ì§ì ‘ ê³„ì‚°
                ob = pre.get("ob", {}) or {}
                turn = pre["tape"]["krw"] / max(ob.get("depth_krw", 1), 1)
                imbalance = calc_orderbook_imbalance(ob)

                # í‚¬ëŸ¬ ì¡°ê±´ ì„ê³„ì¹˜ (í•œ ê³³ì—ì„œ ê´€ë¦¬)
                K_VOL_BASE = 100_000_000   # ê±°ë˜ëŒ€ê¸ˆ 1ì–µ
                K_VOL_SURGE = 2.0          # ì„œì§€ 2ë°°
                K_BUY = 0.70               # ë§¤ìˆ˜ë¹„ 70%
                K_TURN = 0.08              # íšŒì „ìœ¨ 8%
                K_IMB = 0.3                # ì²´ê²°ê°•ë„ 0.3
                K_CONSEC = 8               # ì—°ì†ë§¤ìˆ˜ 8íšŒ

                # í‚¬ëŸ¬ ì¡°ê±´ (ëª¨ë‘ ì¶©ì¡± ì‹œ confirm)
                killer_vol_base = current_vol >= K_VOL_BASE
                killer_vol_surge = volume_surge >= K_VOL_SURGE
                killer_buy = buy_ratio >= K_BUY
                killer_turn = turn >= K_TURN
                killer_imb = imbalance >= K_IMB
                # ì—°ì†ë§¤ìˆ˜ ì¡°ê±´
                ticks_for_killer = pre.get("ticks", [])
                cons_buys = calc_consecutive_buys(ticks_for_killer, 15) if ticks_for_killer else 0
                killer_consec = cons_buys >= K_CONSEC

                all_killer = (killer_vol_base and killer_vol_surge and
                              killer_buy and killer_turn and killer_imb and killer_consec)

                # í‚¬ëŸ¬ ì¡°ê±´ ìƒì„¸ ì €ì¥ (í…”ë ˆê·¸ë¨ìš©) - ê³ ì • í‚¤ ì‚¬ìš©
                pre["killer_details"] = {
                    "vol_base": current_vol,
                    "vol_surge": volume_surge,
                    "buy_ratio": buy_ratio,
                    "turn": turn,
                    "imbalance": imbalance,
                    "consecutive_buys": cons_buys,
                    # ì„ê³„ì¹˜ ì €ì¥ (ì•ŒëŒì—ì„œ ë™ì  í‘œì‹œìš©)
                    "thresholds": {
                        "vol_base": K_VOL_BASE,
                        "vol_surge": K_VOL_SURGE,
                        "buy": K_BUY,
                        "turn": K_TURN,
                        "imb": K_IMB,
                        "consec": K_CONSEC,
                    },
                    # í†µê³¼ ì—¬ë¶€ (ê³ ì • í‚¤)
                    "checks": {
                        "vol_base": killer_vol_base,
                        "vol_surge": killer_vol_surge,
                        "buy": killer_buy,
                        "turn": killer_turn,
                        "imb": killer_imb,
                        "consec": killer_consec,
                    }
                }

                # í‚¬ëŸ¬ ì¡°ê±´ í†µê³¼ê°’ ì „ì²´ í‘œì‹œ (í†µì¼ëœ í˜•ì‹: âœ“/âœ— + ê°’â‰¥ê¸°ì¤€)
                killer_vals = " ".join([
                    f"{'âœ“' if killer_buy else 'âœ—'}ë§¤ìˆ˜{buy_ratio:.0%}â‰¥{K_BUY:.0%}",
                    f"{'âœ“' if killer_turn else 'âœ—'}íšŒì „{turn:.0%}â‰¥{K_TURN:.0%}",
                    f"{'âœ“' if killer_consec else 'âœ—'}ì—°ì†{cons_buys}â‰¥{K_CONSEC}",
                    f"{'âœ“' if killer_vol_base else 'âœ—'}ê±°ë˜ëŒ€ê¸ˆ{current_vol/1e8:.1f}ì–µâ‰¥{K_VOL_BASE/1e8:.0f}",
                    f"{'âœ“' if killer_vol_surge else 'âœ—'}ì„œì§€{volume_surge:.1f}xâ‰¥{K_VOL_SURGE:.0f}",
                    f"{'âœ“' if killer_imb else 'âœ—'}ì²´ê²°{imbalance:.2f}â‰¥{K_IMB}",
                ])

                if all_killer:
                    pre["entry_mode"] = "confirm"
                    print(f"[CONFIRM] {m} {pre.get('signal_tag', '?')} | {killer_vals}")
                else:
                    pre["entry_mode"] = "probe"
                    fail_cnt = sum([not killer_buy, not killer_turn, not killer_consec,
                                    not killer_vol_base, not killer_vol_surge, not killer_imb])
                    print(f"[PROBE] {m} {pre.get('signal_tag', '?')} | {killer_vals} ({fail_cnt}ê°œ íƒˆë½ìœ¼ë¡œ confirm ì‹¤íŒ¨)")

                payload = final_check_leader(m, pre, tight_mode=tight_mode)
                if not payload: continue

                # ğŸ”§ FIX: score/filter_typeì„ preì— ë³µì‚¬ (ìë™ë§¤ìˆ˜ ì•ŒëŒì—ì„œ ì‚¬ìš©)
                pre["score"] = payload.get("score", 0)
                pre["filter_type"] = payload.get("filter_type", "ê¸°ë³¸í†µê³¼")

                # â˜…â˜…â˜… í”„ë¦¬ì‹œì „ í¬ì¼“: ê°•ì§„ì… ëª¨ë“œ ìŠ¹ê²© â˜…â˜…â˜…
                # ì¡°ê±´: ì„ë°¸ >= 0.6 AND ë§¤ìˆ˜ë¹„ >= 63.5% (ì •ë°€ë„ ~82%)
                if payload.get("is_precision_pocket"):
                    pre["entry_mode"] = "confirm"  # probe â†’ confirm ìŠ¹ê²©

                # ğŸ”§ FIX: postcheck ì „ ì¤‘ë³µ ì²´í¬ + ì¦‰ì‹œ ë§ˆí‚¹ (6ì´ˆ ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ìº” ì°¨ë‹¨)
                with _POSITION_LOCK:
                    if m in OPEN_POSITIONS:
                        continue
                    # ğŸ”§ FIX: recent_alertsë„ ë½ ì•ˆì—ì„œ ì²´í¬ (10ì´ˆ ì´ë‚´ë§Œ ì°¨ë‹¨ - postcheck ë™ì•ˆë§Œ)
                    if m in recent_alerts and time.time() - recent_alerts[m] < 10:
                        continue
                    # ğŸ”§ FIX: postcheck ì „ì— ë¯¸ë¦¬ ë§ˆí‚¹ (ë‹¤ë¥¸ ìŠ¤ìº” ì°¨ë‹¨)
                    recent_alerts[m] = time.time()

                # === 6ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ ===
                ok_post, post_reason = postcheck_6s(m, pre)
                if not ok_post:
                    cut("POSTCHECK_DROP", f"{m} postcheck fail: {post_reason}")
                    # ğŸ”§ FIX: postcheck ì‹¤íŒ¨ ì‹œ recent_alerts ì œê±° (ë‹¤ìŒ ìŠ¤ìº”ì—ì„œ ì¬ì‹œë„ ê°€ëŠ¥)
                    with _POSITION_LOCK:
                        recent_alerts.pop(m, None)
                    continue

                # ğŸ”§ FIX: postcheck í›„ ì¬í™•ì¸ ì œê±° (ì´ë¯¸ ìœ„ì—ì„œ ë§ˆí‚¹ë¨)

                reason = "ign" if pre.get("ign_ok") else (
                    "early" if pre.get("early_ok") else
                    ("mega" if pre.get("mega_ok") else "normal"))
                if not cooldown_ok(m, pre['price'], reason=reason):
                    continue

                # ğŸ”§ FIX: ì´ˆì… ì‹ í˜¸ ë°œì†¡ ì „ ì¤‘ë³µ ì§„ì… ì°¨ë‹¨ (race condition ë°©ì§€)
                # ğŸ” íŒŒì¼ë½ íšë“ ì‹œë„ (í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ )
                if not _try_acquire_entry_lock(m):
                    print(f"[LOCK] {m} already locked â†’ skip")
                    continue

                # ğŸ”§ FIX: íŒŒì¼ë½ íšë“ í›„ OPEN_POSITIONSë§Œ ì¬í™•ì¸ (recent_alertsëŠ” ì´ë¯¸ ìœ„ì—ì„œ ë§ˆí‚¹ë¨)
                with _POSITION_LOCK:
                    if m in OPEN_POSITIONS:
                        print(f"[SCAN] {m} ì´ë¯¸ í¬ì§€ì…˜/pending ì¡´ì¬ â†’ ìŠ¤í‚µ")
                        _release_entry_lock(m)
                        continue
                    # ë¯¸ë¦¬ pending ë§ˆí‚¹ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œ ì°¨ë‹¨)
                    OPEN_POSITIONS[m] = {"state": "pending", "pre_signal": True}
                    # recent_alertsëŠ” postcheck ì „ì— ì´ë¯¸ ì„¤ì •ë¨ (line 5684)
                    last_signal_at[m] = time.time()
                    last_price_at_alert[m] = pre['price']
                    last_reason[m] = reason

                # ë™ì  ì†ì ˆê°€
                dyn_stop, eff_sl_pct, _ = dynamic_stop_loss(pre['price'], c1)

                # ìŠ¤ì½”ì–´/ì„ë°¸ëŸ°ìŠ¤ í‘œì‹œ
                score_str = f"ìŠ¤ì½”ì–´ {payload.get('score', 0)}" if USE_RISK_SCORE else ""
                imb_str = f"ì„ë°¸ {payload.get('imbalance', 0):.2f}"
                pocket_mark = "ğŸ¯" if payload.get("is_precision_pocket") else ""

                # ğŸ”¥ ê²½ë¡œ í‘œì‹œ: signal_tag í•˜ë‚˜ë¡œ ê°„ì†Œí™”
                filter_type = pre.get("filter_type", "stage1_gate")
                if filter_type == "prebreak":
                    path_str = "ğŸš€ì„ í–‰ì§„ì…"
                else:
                    path_str = pre.get("signal_tag", "ê¸°ë³¸")

                # ğŸ”¥ ìƒˆ ì§€í‘œ ê³„ì‚°: ì²´ê²°ê°•ë„, í‹±ë‹¹ê¸ˆì•¡, ê°€ì†ë„
                ticks_for_metrics = pre.get("ticks", [])
                t15_for_avg = micro_tape_stats_from_ticks(ticks_for_metrics, 15)
                cons_buys = calc_consecutive_buys(ticks_for_metrics, 15)
                avg_krw = calc_avg_krw_per_tick(t15_for_avg)
                flow_accel = calc_flow_acceleration(ticks_for_metrics)

                # ê°€ì†ë„ ì´ëª¨ì§€
                accel_emoji = "ğŸš€" if flow_accel >= 1.5 else ("ğŸ“‰" if flow_accel <= 0.7 else "â¡ï¸")

                # ğŸ”¥ GATE í•µì‹¬ ì§€í‘œ
                overheat = flow_accel * float(payload.get("volume_surge", 1.0))
                fresh_age = 0.0
                if ticks_for_metrics:
                    now_ms = int(time.time() * 1000)
                    last_tick_ts = ticks_for_metrics[0].get("timestamp", now_ms)
                    fresh_age = (now_ms - last_tick_ts) / 1000.0

                # ğŸš€ ì´ˆë‹¨ê¸° ë¯¸ì„¸í•„í„° ì§€í‘œ ê³„ì‚°
                ia_stats = inter_arrival_stats(ticks_for_metrics, 30) if ticks_for_metrics else {"cv": 0.0}
                cv_val = ia_stats.get("cv", 0.0)
                pstd_val = price_band_std(ticks_for_metrics, sec=10) if ticks_for_metrics else 0.0
                prebreak_band_val = dynamic_prebreak_band(ticks_for_metrics) if ticks_for_metrics else PREBREAK_HIGH_PCT
                is_prebreak = pre.get("filter_type") == "prebreak"
                # ë² ìŠ¤íŠ¸í˜¸ê°€ ê¹Šì´
                try:
                    u0 = pre.get("ob", {}).get("raw", {}).get("orderbook_units", [])[0]
                    best_ask_krw = float(u0["ask_price"]) * float(u0["ask_size"])
                except Exception:
                    best_ask_krw = 0.0

                # CV ì´ëª¨ì§€ (ë´‡/ì‚¬ëŒ íŒë‹¨)
                cv_emoji = "ğŸ¤–" if cv_val <= 0.45 else ("âš”ï¸" if cv_val >= 1.2 else "")

                txt = (
                    f"âš¡ <b>ì´ˆì… ì‹ í˜¸</b> {m} <code>#{reason}</code>{pocket_mark}\n"
                    f"ğŸ’µ í˜„ì¬ê°€ {fmt6(pre['price'])}ì›\n"
                    f"ğŸ“Š ë“±ë½ {payload['chg']}% | ê±°ë˜ì¦ê°€ {payload['volume_surge']}ë°° | íšŒì „ {payload['turn']}%\n"
                    f"ğŸ”¸ë§¤ìˆ˜ {payload['buy']}% | í‹± {payload['n']} | ìŠ¤í”„ë ˆë“œ {payload['spread']}% | {imb_str}\n"
                    f"ğŸ”¥ ì—°ì†ë§¤ìˆ˜ {cons_buys}íšŒ | í‹±ë‹¹ {avg_krw/1000:.0f}K | ê°€ì† {flow_accel:.1f}x {accel_emoji}\n"
                    f"ğŸŒ¡ï¸ ê³¼ì—´ {overheat:.1f} | í‹±ë‚˜ì´ {fresh_age:.1f}ì´ˆ\n"
                    f"ğŸ“ˆ CV {cv_val:.2f}{cv_emoji} | pstd {pstd_val*100:.3f}% | í˜¸ê°€ {best_ask_krw/1000:.0f}K\n"
                    f"ğŸ§¯ ì†ì ˆê°€: {fmt6(dyn_stop)} (ë™ì SL {eff_sl_pct*100:.2f}%)\n"
                    f"ğŸ” ê²½ë¡œ: {path_str}\n"
                    f"{link_for(m)}")

                sent = tg_send(txt, retry=2)

                if sent:
                    found += 1
                    # --- ë¡œê·¸ CSV ê¸°ë¡ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ) ---
                    try:
                        c5 = get_minutes_candles(5, m, 2) or []
                        c15 = get_minutes_candles(15, m, 2) or []
                        chg_1m = (c1[-1]["trade_price"] /
                                  max(c1[-2]["trade_price"], 1) -
                                  1) if len(c1) >= 2 else 0.0
                        chg_5m = (c5[-1]["trade_price"] /
                                  max(c5[-2]["trade_price"], 1) -
                                  1) if len(c5) >= 2 else ""
                        chg_15m = (c15[-1]["trade_price"] /
                                   max(c15[-2]["trade_price"], 1) -
                                   1) if len(c15) >= 2 else ""

                        cbtc1 = get_minutes_candles(1, "KRW-BTC", 2) or []
                        btc1m = (cbtc1[-1]["trade_price"] /
                                 max(cbtc1[-2]["trade_price"], 1) -
                                 1) if len(cbtc1) >= 2 else 0.0
                        cbtc5 = get_minutes_candles(5, "KRW-BTC", 2) or []
                        btc5m = (cbtc5[-1]["trade_price"] /
                                 max(cbtc5[-2]["trade_price"], 1) -
                                 1) if len(cbtc5) >= 2 else 0.0

                        t15_now = micro_tape_stats_from_ticks(pre["ticks"], 15)
                        ob = pre["ob"]
                        flags = {
                            "chg_1m":
                            chg_1m,
                            "chg_5m":
                            chg_5m,
                            "chg_15m":
                            chg_15m,
                            "zscore":
                            zscore_krw_1m(c1, 30),
                            "vwap_gap": (c1[-1]["trade_price"] /
                                         max(vwap_from_candles_1m(c1, 20), 1) -
                                         1) if len(c1) >= 1 else 0.0,
                            "turn":
                            round((t15_now["krw"] / max(ob["depth_krw"], 1)) *
                                  100, 2),
                            "two_green_break":
                            pre.get("two_green_break", False),
                            "ignition_ok":
                            pre.get("ign_ok", False),
                            "early_ok":
                            pre.get("early_ok", False),
                            "uptick_ok":
                            True
                        }
                        row = snapshot_row(m, pre["price"], payload, pre, c1,
                                           ob, t15_now, btc1m, btc5m, flags)
                        append_csv(row)
                    except Exception as e:
                        print("[LOG_ERR]", e)

                    # --- ğŸ”¥ ìë™ë§¤ìˆ˜ ì§„ì… ---
                    # ğŸ”§ FIX: ìŠ¤ìº” ë£¨í”„ì—ì„œ íšë“í•œ íŒŒì¼ë½ í•´ì œ (open_auto_positionì—ì„œ ë‹¤ì‹œ íšë“)
                    _release_entry_lock(m)
                    try:
                        open_auto_position(m, pre, dyn_stop, eff_sl_pct)
                    except Exception as e:
                        print("[AUTO_OPEN_ERR]", e)
                        # ğŸ”§ FIX: ìë™ë§¤ìˆ˜ ì‹¤íŒ¨ ì‹œ pre_signal pending ì •ë¦¬ + ë½ í•´ì œ
                        with _POSITION_LOCK:
                            pos = OPEN_POSITIONS.get(m)
                            if pos and pos.get("pre_signal"):
                                OPEN_POSITIONS.pop(m, None)
                        _release_entry_lock(m)

                    # --- í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ì²­ì‚°ê¹Œì§€ ì´ì–´ì§) ---
                    # ğŸ”§ FIX: ì‹ í˜¸ê°€ê°€ ì•„ë‹Œ ì‹¤ì œ ì²´ê²°ê°€ ì‚¬ìš©
                    with _POSITION_LOCK:
                        actual_entry = OPEN_POSITIONS.get(m, {}).get("entry_price", pre["price"])

                    # ğŸ”§ FIX: ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ëª¨ë‹ˆí„°ë§ ì‹¤í–‰ (ë©”ì¸ ìŠ¤ìº” ë£¨í”„ ë¸”ë¡œí‚¹ ë°©ì§€)
                    pre_copy = dict(pre)  # í´ë¡œì € ë¬¸ì œ ë°©ì§€
                    def _run_monitor(market, entry, pre_data, tight):
                        try:
                            monitor_position(market, entry, pre_data, tight_mode=tight)
                        except Exception as e:
                            # ğŸ”§ DEBUG: ëª¨ë‹ˆí„°ë§ ì˜ˆì™¸ ì‹œ í…”ë ˆê·¸ë¨ ì•ŒëŒ ì¶”ê°€
                            print(f"[MON_ERR] {market}: {e}")
                            import traceback
                            traceback.print_exc()
                            tg_send(f"âŒ [{market}] ëª¨ë‹ˆí„°ë§ ì˜ˆì™¸ ë°œìƒ\n{str(e)[:100]}")
                        finally:
                            _release_entry_lock(market)

                    threading.Thread(
                        target=_run_monitor,
                        args=(m, actual_entry, pre_copy, tight_mode),
                        daemon=True
                    ).start()
                else:
                    # ğŸ”§ FIX: ì‹ í˜¸ ë°œì†¡ ì‹¤íŒ¨ ì‹œ pre_signal pending ì •ë¦¬ + ë½ í•´ì œ
                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        if pos and pos.get("pre_signal"):
                            OPEN_POSITIONS.pop(m, None)
                    _release_entry_lock(m)

              except Exception as e:
                # ğŸ”§ ì‹¬ë³¼ë³„ ì˜ˆì™¸ ì²˜ë¦¬: ë½/íœë”© ì •ë¦¬ í›„ ë‹¤ìŒ ì‹¬ë³¼ ì§„í–‰
                print(f"[SYMBOL_ERR][{m}] {e}")
                traceback.print_exc()
                _release_entry_lock(m)
                with _POSITION_LOCK:
                    if OPEN_POSITIONS.get(m, {}).get("state") == "pending":
                        OPEN_POSITIONS.pop(m, None)

            cut_summary()
            if found == 0:
                req_summary()
            # ì‹œê°„ëŒ€ë³„ ë™ì  ìŠ¤ìº” ê°„ê²© ì ìš©
            aligned_sleep(get_scan_interval())

        except KeyboardInterrupt:
            print("Stopped by user.")
            break
        except Exception as e:
            print("[MAIN_ERR]", e)
            traceback.print_exc()
            print("[MAIN] 5ì´ˆ í›„ ì¬ì‹œì‘...")
            time.sleep(5)
            continue  # ğŸ’¡ ë‹¤ì‹œ ë£¨í”„ ì‹œì‘

if __name__ == "__main__":
    validate_config()
    bot_start_time = time.time()
    start_health_server()
    start_watchdogs()  # ğŸ• ì›Œì¹˜ë… ì‹œì‘ (í—¬ìŠ¤ë¹„íŠ¸/ì„¸ì…˜ë¦¬í”„ë ˆì‹œ/ë½ì²­ì†Œ)
    main()
