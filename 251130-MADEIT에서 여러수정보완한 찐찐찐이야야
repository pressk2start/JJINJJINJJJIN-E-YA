# -*- coding: utf-8 -*-
import os, time, math, requests, statistics, traceback, threading, csv, sys, json, random
from datetime import datetime, timedelta, timezone
from collections import deque, OrderedDict
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlencode
from decimal import Decimal, getcontext

import uuid
import hashlib
import hmac
import jwt

# Decimal ì •ë°€ë„ ì„¤ì •
getcontext().prec = 10


def rnd():
    return random.random()

def fmt6(x):
    """
    ìˆ«ìë¥¼ ë³´ê¸° ì¢‹ê²Œ í‘œì‹œ:
    - ì •ìˆ˜ëŠ” ì†Œìˆ˜ì  ì—†ì´
    - ì†Œìˆ˜ì ì´ ìˆëŠ” ê²½ìš° ìµœëŒ€ 6ìë¦¬ê¹Œì§€ í‘œì‹œ
    """
    if isinstance(x, (int, float)):
        if abs(x - int(x)) < 1e-6:
            return f"{int(x):,}"
        else:
            s = f"{x:,.6f}".rstrip('0').rstrip('.')
            return s
    return str(x)


def fmt_price(x):
    """
    ê°€ê²©ì„ ìµœëŒ€í•œ ì •ë°€í•˜ê²Œ í‘œì‹œ (ì†Œìˆ˜ì  ìµœëŒ€ 8ìë¦¬, trailing zero ì œê±°)
    - ì—…ë¹„íŠ¸ ì²´ê²°ê°€/í˜¸ê°€ ë“± ëª¨ë“  ê°€ê²©ì— ì‚¬ìš©
    - ì˜ë¯¸ìˆëŠ” ì†Œìˆ˜ì ê¹Œì§€ë§Œ í‘œì‹œ
    """
    if isinstance(x, (int, float)):
        s = f"{x:,.8f}".rstrip('0')
        if s.endswith('.'):
            s += '0'  # ìµœì†Œ ì†Œìˆ˜ì  1ìë¦¬ëŠ” í‘œì‹œ
        return s
    return str(x)

# =========================
# ì„¤ì • (24ì‹œê°„ ë‹¨íƒ€ ìµœì í™” + Bot-aware, 3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry)
# =========================
TOP_N = 120  # ìˆ˜ì§ ëŸ¬ë„ˆ í¬ì°© ìœ„í•´ í™•ì¥ (60â†’120)
SCAN_INTERVAL = 6
COOLDOWN = 480
PARALLEL_WORKERS = 12

# ==== Exit Control (anti-whipsaw) ====
WARMUP_SEC = 5  # ì§„ì… í›„ ì´ˆê¸° ë…¸ì´ì¦ˆ í—ˆìš© êµ¬ê°„
HARD_STOP_DD = 0.015  # -1.5% ê¸‰ë½ ì‹œ ì¦‰ì‹œ ì»· (strict ê¸°ì¤€)
EXIT_DEBOUNCE_SEC = 8  # ì²­ì‚° ì‹ í˜¸ ì§€ì† í™•ì¸ ì‹œê°„
EXIT_DEBOUNCE_N = 4  # ì—°ì† NíšŒ ì¡°ê±´ ì¶©ì¡± í•„ìš”

# íŠ¸ë ˆì¼ë§ ì†ì ˆ (ì´ìµë°œìƒ í›„ ê¼­ëŒ€ê¸° í¬ì°©)
TRAIL_ARM_GAIN = 0.003  # +0.3% ì´ìµ ì‹œ íŠ¸ë ˆì¼ë§ í™œì„±í™” (0.8â†’0.3%, ê³ ì  ì¡°ê¸° í¬ì°©)
TRAIL_ATR_MULT = 1.15  # ATR ê¸°ë°˜ ì—¬ìœ í­
TRAIL_DISTANCE_MIN = 0.005  # ìµœì†Œ íŠ¸ë ˆì¼ ê°„ê²© (0.5%, 1.0â†’0.5%, ë” íƒ€ì´íŠ¸í•˜ê²Œ)

# === ìˆ˜ìˆ˜ë£Œ ì„¤ì • (ì™•ë³µ 0.1% ë°˜ì˜) ===
FEE_RATE = 0.001  # 0.05% ë§¤ìˆ˜ + 0.05% ë§¤ë„

# === í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ ì „ì—­ ì„¤ì • ===
USE_5M_CONTEXT = False        # 5ë¶„ ì»¨í…ìŠ¤íŠ¸ ë¹„í™œì„±í™”
POSTCHECK_ENABLED = True      # ì´ˆì… ë‹¨ê³„ í¬ìŠ¤íŠ¸ì²´í¬ í™œì„±í™” (ì»¨íŒë§Œ ì ìš©)
EARLY_FLOW_MIN_KRWPSEC = 20_000  # ì´ˆê¸° ê±°ë˜ì†ë„ í•˜í•œ (í”„ë¡œë¸Œ ë¹ˆë„ ì¡°ì ˆ, 16k â†’ 20k ìƒí–¥)

# --- í™˜ê²½ë³€ìˆ˜(.env ì§€ì›) ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

# ==== Exit Profile (gentle/ balanced / strict) ====
EXIT_PROFILE = os.getenv("EXIT_PROFILE", "strict").lower()


def _apply_exit_profile():
    """
    í”„ë¡œíŒŒì¼ë³„ ì²­ì‚° ë¯¼ê°ë„ ì„¸íŒ…
    - gentle  : ëŠìŠ¨(íœ©ì˜ ë‚´ì„±â†‘, ìˆ˜ìµ ìµœëŒ€í™” ì§€í–¥)
    - balanced: ê¸°ë³¸ê°’(í˜„ì¬ ë„¤ ì„¸íŒ… ê¸°ì¤€)
    - strict  : ì—„ê²©(ë³´ìˆ˜ì , ì†ì‹¤ì¶•ì†Œ ì§€í–¥)
    """
    global WARMUP_SEC, HARD_STOP_DD, EXIT_DEBOUNCE_SEC, EXIT_DEBOUNCE_N
    global TRAIL_ARM_GAIN, TRAIL_ATR_MULT, TRAIL_DISTANCE_MIN
    global SPIKE_RECOVERY_WINDOW, SPIKE_RECOVERY_MIN_BUY
    global CTX_EXIT_THRESHOLD

    prof = EXIT_PROFILE

    if prof == "gentle":
        WARMUP_SEC = 14
        HARD_STOP_DD = 0.024
        EXIT_DEBOUNCE_SEC = 10
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.007
        TRAIL_ATR_MULT = 1.20
        TRAIL_DISTANCE_MIN = 0.010
        SPIKE_RECOVERY_WINDOW = 4
        SPIKE_RECOVERY_MIN_BUY = 0.56
        CTX_EXIT_THRESHOLD = 4

    elif prof == "strict":
        WARMUP_SEC = 5
        HARD_STOP_DD = 0.015
        EXIT_DEBOUNCE_SEC = 6
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.012
        TRAIL_ATR_MULT = 1.10
        TRAIL_DISTANCE_MIN = 0.015
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.60
        CTX_EXIT_THRESHOLD = 3  # ì»¨í…ìŠ¤íŠ¸ ì—­ì „ ë¯¼ê°

    else:  # balanced (í˜„ì¬ ê°’ì— ê·¼ì ‘)
        WARMUP_SEC = 12
        HARD_STOP_DD = 0.022
        EXIT_DEBOUNCE_SEC = 8
        EXIT_DEBOUNCE_N = 2
        TRAIL_ARM_GAIN = 0.006
        TRAIL_ATR_MULT = 1.15
        TRAIL_DISTANCE_MIN = 0.009
        SPIKE_RECOVERY_WINDOW = 3
        SPIKE_RECOVERY_MIN_BUY = 0.58
        CTX_EXIT_THRESHOLD = 3


_apply_exit_profile()

TG_TOKEN = os.getenv("TELEGRAM_TOKEN") or os.getenv("TG_TOKEN") or ""

# ğŸ“Œ ì—¬ëŸ¬ ëª…ì—ê²Œ ë³´ë‚´ê¸°ìš© chat_id ëª©ë¡
_raw_chats = (
    os.getenv("TG_CHATS")  # ìƒˆë¡œ ì“¸ ì¶”ì²œ í‚¤: "id1,id2,-100xxx"
    or os.getenv("TELEGRAM_CHAT_ID")  # ì˜ˆì „ ë‹¨ì¼ í‚¤ë„ í˜¸í™˜
    or os.getenv("TG_CHAT") or "")

CHAT_IDS = []
for part in _raw_chats.split(","):
    part = part.strip()
    if not part:
        continue
    try:
        CHAT_IDS.append(int(part))
    except Exception:
        print(f"[WARN] ì˜ëª»ëœ chat_id ê°’ ë¬´ì‹œë¨: {part}")

print("[DEBUG] CHAT_IDS =", CHAT_IDS)  # ì‹¤í–‰ ì‹œ í•œ ë²ˆ ì°í˜€ì„œ í™•ì¸ìš©

# =========================
# ğŸ”¥ ì—…ë¹„íŠ¸ Private API (ì£¼ë¬¸/ì”ê³ /í¬ì§€ì…˜ ê´€ë¦¬)
# =========================
# uuid, hashlib, jwt, urlencodeëŠ” ìƒë‹¨ì—ì„œ ì´ë¯¸ importë¨

# í‚¤ ëì— ê³µë°±/ê°œí–‰ ë¶™ì–´ 401 ë‚˜ëŠ” ì¼€ì´ìŠ¤ ë°©ì§€
UPBIT_ACCESS_KEY = (os.getenv("UPBIT_ACCESS_KEY", "") or "").strip()
UPBIT_SECRET_KEY = (os.getenv("UPBIT_SECRET_KEY", "") or "").strip()

print("[UPBIT_KEYS] access_len=", len(UPBIT_ACCESS_KEY),
      "secret_len=", len(UPBIT_SECRET_KEY))

# AUTO_TRADE = 1 ì´ë©´ ì‹¤ì œ ì£¼ë¬¸, 0ì´ë©´ ì•Œë¦¼ + ëª¨ë‹ˆí„°ë§ë§Œ
AUTO_TRADE = os.getenv("AUTO_TRADE", "0") == "1"
RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.003"))  # ê³„ì¢Œì˜ 0.3% ë¦¬ìŠ¤í¬

# âœ… í‚¤ í˜•íƒœê°€ ë¹„ì •ìƒì´ë©´ ê°•ì œë¡œ ë“œë¼ì´ëŸ° ëª¨ë“œë¡œ ì „í™˜
if AUTO_TRADE and (len(UPBIT_ACCESS_KEY) < 10 or len(UPBIT_SECRET_KEY) < 10):
    print("[SECURITY] Invalid API keys â€” forcing AUTO_TRADE=0")
    AUTO_TRADE = False

print(f"[BOT_MODE] AUTO_TRADE={AUTO_TRADE}, RISK_PER_TRADE={RISK_PER_TRADE}")

# === ê³µê²© ëª¨ë“œ / í”¼ë¼ë¯¸ë”© ì„¤ì • ===
AGGRESSIVE_MODE = os.getenv("AGGRESSIVE_MODE", "1") == "1"

# ì†Œì•¡ ì„ ì§„ì… + ì¶”ë§¤ êµ¬ì¡°
USE_PYRAMIDING = os.getenv("USE_PYRAMIDING", "1") == "1"

# === ì—¼íƒ(probe) ê¸ˆì•¡/íƒ€ì„ì•„ì›ƒ/ì¶”ë§¤ íšŸìˆ˜ ===
PROBE_KRW = int(os.getenv("PROBE_KRW", "7000"))              # í”„ë¡œë¸Œ ì´ˆê¸° ì§„ì… ê¸ˆì•¡ (ì†Œì•¡ í…ŒìŠ¤íŠ¸)
PROBE_TIMEOUT_SEC = int(os.getenv("PROBE_TIMEOUT_SEC", "240")) # í”„ë¡œë¸Œ ê´€ì°° ì‹œê°„ (120ì´ˆ â†’ 240ì´ˆ, ì¼ì° ì²­ì‚° ë°©ì§€)
PROBE_BREAKEVEN_EXIT = float(os.getenv("PROBE_BREAKEVEN_EXIT", "-0.005"))  # í”„ë¡œë¸Œ ì†ì ˆì„  (-0.5%, íŠ¸ë ˆì¼ë§ ìš°ì„ )
MAX_ADDS = int(os.getenv("MAX_ADDS", "5"))                    # ì¶”ë§¤ ìµœëŒ€ íšŒìˆ˜ (3íšŒ â†’ 5íšŒ, ì ê·¹ì  ì¶”ë§¤)

# RISK_PER_TRADEë¥¼ ìª¼ê°œì„œ ì‚¬ìš© (seed + add)
# í”„ë¡œë¸Œ í™•ì¸ í›„ ì¶”ë§¤ëŠ” ì •ìƒ ê¸ˆì•¡ìœ¼ë¡œ (í™•ì‹  ìˆëŠ” ì§„ì…)
SEED_RISK_FRACTION = float(os.getenv("SEED_RISK_FRACTION", "0.55"))
ADD_RISK_FRACTION = float(os.getenv("ADD_RISK_FRACTION", "1.0"))  # ì¶”ë§¤ëŠ” ì •ìƒ ê¸ˆì•¡ (0.55 â†’ 1.0)

# ì¶”ë§¤ íŠ¸ë¦¬ê±° ì¡°ê±´ (ì˜¤ë¦„ì¶”ì„¸ ê°ì§€ ì‹œ ì ê·¹ì  ì¶”ë§¤)
PYRAMID_ADD_MIN_GAIN = float(os.getenv("PYRAMID_ADD_MIN_GAIN", "0.000"))  # UNUSED (íë¦„ ê¸°ë°˜ ì¶”ë§¤ë¡œ ì „í™˜)
PYRAMID_ADD_FLOW_MIN_BUY = float(os.getenv("PYRAMID_ADD_FLOW_MIN_BUY", "0.55"))  # ë§¤ìˆ˜ë¹„ ì™„í™” (0.60 â†’ 0.55)
PYRAMID_ADD_FLOW_MIN_KRWPSEC = float(os.getenv("PYRAMID_ADD_FLOW_MIN_KRWPSEC", "18000"))  # ê±°ë˜ì†ë„ ì™„í™” (22000 â†’ 18000)
PYRAMID_ADD_COOLDOWN_SEC = int(os.getenv("PYRAMID_ADD_COOLDOWN_SEC", "15"))  # ì¶”ë§¤ ê°„ê²© ì ì ˆíˆ ìœ ì§€ (10 â†’ 15ì´ˆ)

# === ì´ˆì… ë¹ˆë„ ì¦ê°€ ì„¤ì • ===
ALWAYS_PROBE_FIRST = os.getenv("ALWAYS_PROBE_FIRST", "1") == "1"  # ì²« ì§„ì… ë¬´ì¡°ê±´ probe (7000ì›)
PROBE_LITE_ON = os.getenv("PROBE_LITE_ON", "1") == "1"  # ê°€ë²¼ìš´ ì¡°ê±´ probe ì‹ í˜¸ ì¶”ê°€
PROBE_LITE_MIN_BUY = float(os.getenv("PROBE_LITE_MIN_BUY", "0.55"))  # probe-lite ìµœì†Œ ë§¤ìˆ˜ë¹„ (ë³´ìˆ˜ì  ì¡°ì •: 0.50 â†’ 0.55)
PROBE_LITE_MIN_KRWPSEC = int(os.getenv("PROBE_LITE_MIN_KRWPSEC", "12000"))  # probe-lite ìµœì†Œ ê±°ë˜ì†ë„ (ë³´ìˆ˜ì  ì¡°ì •: 8000 â†’ 12000)
PROBE_LITE_MAX_VWAP_GAP = float(os.getenv("PROBE_LITE_MAX_VWAP_GAP", "0.012"))  # VWAP ê´´ë¦¬ ìƒí•œ (ë³´ìˆ˜ì  ì¡°ì •: 0.017 â†’ 0.012)
PROBE_LITE_MAX_SPREAD = float(os.getenv("PROBE_LITE_MAX_SPREAD", "1.20"))  # ìŠ¤í”„ë ˆë“œ ìƒí•œ (ë³´ìˆ˜ì  ì¡°ì •: 2.00 â†’ 1.20)

# === ìŠ¤ìº˜í”„/ì¶”ì„¸ ë¶„ê¸° ì„¤ì • ===
TREND_THRESHOLD = float(os.getenv("TREND_THRESHOLD", "0.03"))  # 3% ì´ìƒ: í° ì¶”ì„¸, ë¯¸ë§Œ: ìŠ¤ìº˜í”„
SCALP_MICRO_MARGIN = float(os.getenv("SCALP_MICRO_MARGIN", "0.0010"))  # ìˆ˜ìˆ˜ë£Œ ìœ„ ì¶”ê°€ ë§ˆì§„ (0.1%)
SCALP_MICRO_LOCK = float(os.getenv("SCALP_MICRO_LOCK", "0.0002"))  # ë¯¸ì„¸ìµì ˆ lock ë§ˆì§„ (0.02%)


# í˜„ì¬ ì—´ë¦° í¬ì§€ì…˜ ê¸°ë¡ìš©
# ì˜ˆ: { "KRW-BTC": {"entry_price":..., "volume":..., "stop":..., "sl_pct":..., "state":"open"} }
OPEN_POSITIONS = {}
_POSITION_LOCK = threading.Lock()  # í¬ì§€ì…˜ ì ‘ê·¼ ë½
_FUNDS_LOCK = threading.Lock()  # â˜… ì”ê³  ì‚¬ìš© ì „ì—­ ë½ (ì¶”ë§¤ ë™ì‹œì„± ê²½í•© ë°©ì§€)

# ì²­ì‚° ì‹œê° ê¸°ë¡ (ì¬íƒì§€ ë°©ì§€ìš©)
LAST_EXIT_AT = {}

# === ğŸ¯ Patch #5: ìˆ˜ìµ ì²­ì‚° í›„ ì¬ì§„ì… ì¿¨ë‹¤ìš´ ë‹¨ì¶• ===
# ì²­ì‚° ì‚¬ìœ  ê¸°ë¡ (profit vs loss)
LAST_EXIT_CAUSE = {}

# ì²­ì‚° ì‹œë„(ë¯¸ì²´ê²° í¬í•¨) íƒ€ì„ìŠ¤íƒ¬í”„
LAST_EXIT_ATTEMPT = {}

# ğŸ”” ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ì¿¨íƒ€ì„ (ë¹„ë§¤ë§¤ ì•Œë¦¼ìš©)
REMONITOR_COOLDOWN_SEC = 300  # 5ë¶„
REMONITOR_LAST_ALERT = {}

# =========================
# ğŸš€ í”„ë¡œë¸Œ 2.0 ì‹œìŠ¤í…œ
# =========================
PROBE_V2_ENABLED = os.getenv("PROBE_V2_ENABLED", "1") == "1"  # í”„ë¡œë¸Œ 2.0 í™œì„±í™”

# í”„ë¡œë¸Œ ìƒíƒœ ì¶”ì : {market: {"score": 0, "entry_time": ts, "trigger_type": "A/B/C", "last_update": ts, ...}}
PROBE_V2_STATES = {}
_PROBE_V2_LOCK = threading.Lock()

# í”„ë¡œë¸Œ 2.0 íŒŒë¼ë¯¸í„°
PROBE_V2_MAX_CONCURRENT = int(os.getenv("PROBE_V2_MAX_CONCURRENT", "5"))  # ìµœëŒ€ ë™ì‹œ í”„ë¡œë¸Œ ìˆ˜
PROBE_V2_TIMEOUT_BARS = int(os.getenv("PROBE_V2_TIMEOUT_BARS", "12"))  # íƒ€ì„ì•„ì›ƒ (12ë¶„ë´‰)
PROBE_V2_UPGRADE_SCORE = int(os.getenv("PROBE_V2_UPGRADE_SCORE", "5"))  # 1ì°¨ ì¶”ë§¤ ìŠ¹ê²© ì ìˆ˜
PROBE_V2_SIZE_PROBE = float(os.getenv("PROBE_V2_SIZE_PROBE", "0.20"))  # í”„ë¡œë¸Œ í¬ê¸° (20%)
PROBE_V2_SIZE_ADD1 = float(os.getenv("PROBE_V2_SIZE_ADD1", "0.30"))  # 1ì°¨ ì¶”ë§¤ í¬ê¸° (30%)
PROBE_V2_SIZE_ADD2 = float(os.getenv("PROBE_V2_SIZE_ADD2", "0.25"))  # 2ì°¨ ì¶”ë§¤ í¬ê¸° (25%)

# ê³µí†µ ì„ í•„í„° íŒŒë¼ë¯¸í„°
PROBE_V2_PREFILTER_RVOL = float(os.getenv("PROBE_V2_PREFILTER_RVOL", "1.5"))  # ìµœì†Œ RVOL
PROBE_V2_PREFILTER_SPREAD = float(os.getenv("PROBE_V2_PREFILTER_SPREAD", "0.002"))  # ìµœëŒ€ ìŠ¤í”„ë ˆë“œ (0.2%)
PROBE_V2_PREFILTER_EMA_UP = int(os.getenv("PROBE_V2_PREFILTER_EMA_UP", "2"))  # ìµœì†Œ EMA ìƒìŠ¹ ê°œìˆ˜ (5,10,20 ì¤‘)

# =========================
# ğŸ“ˆ ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë¦¬ìŠ¤í¬ íŠœë‹
# =========================
from collections import deque as _deque_for_risk  # ê¸°ì¡´ dequeì™€ ë³„ë„ alias

TRADE_HISTORY = _deque_for_risk(maxlen=30)  # ìµœê·¼ 30ê°œ ê±°ë˜ ê¸°ë¡


def record_trade(market: str, pnl_pct: float):
    """
    ê±°ë˜ ê²°ê³¼ ê¸°ë¡
    - pnl_pct: % ë‹¨ìœ„ ìˆ˜ìµë¥  (ì˜ˆ: +2.3, -1.5)
    """
    TRADE_HISTORY.append({
        "market": market,
        "pnl": pnl_pct,
        "win": pnl_pct > 0,
        "time": time.time(),
    })


def get_adaptive_risk() -> float:
    """
    ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ RISK_PER_TRADE ê°€ë³€ ì¡°ì •
    - íˆìŠ¤í† ë¦¬ 10ê±´ ë¯¸ë§Œ: ê¸°ë³¸ê°’
    - winrate < 30% : ë¦¬ìŠ¤í¬ 0.5ë°°
    - winrate >= 50%: ë¦¬ìŠ¤í¬ 1.2ë°°
    """
    if len(TRADE_HISTORY) < 10:
        return RISK_PER_TRADE

    wins = sum(1 for t in TRADE_HISTORY if t.get("win"))
    win_rate = wins / len(TRADE_HISTORY)

    if win_rate < 0.30:
        return RISK_PER_TRADE * 0.5
    elif win_rate >= 0.50:
        return RISK_PER_TRADE * 1.2
    else:
        return RISK_PER_TRADE

def _make_auth_headers(params=None):
    """
    ì—…ë¹„íŠ¸ Private API ì¸ì¦ í—¤ë” ìƒì„±
    - params: list[tuple] ë˜ëŠ” dict (ìˆœì„œ ë³´ì¡´, ì •ë ¬ ê¸ˆì§€!)
    """
    payload = {"access_key": UPBIT_ACCESS_KEY, "nonce": str(uuid.uuid4())}

    if params:
        # paramsë¥¼ list[tuple] í˜•íƒœë¡œ í†µì¼ (ìˆœì„œ ë³´ì¡´)
        if isinstance(params, list):
            items = params
        elif isinstance(params, dict):
            items = list(params.items())  # dict ì‚½ì… ìˆœì„œ ìœ ì§€ (Python 3.7+)
        else:
            raise TypeError("params must be list[tuple] or dict")

        qs = urlencode(items, doseq=True)
        payload["query_hash"] = hashlib.sha512(qs.encode()).hexdigest()
        payload["query_hash_alg"] = "SHA512"

    token = jwt.encode(payload, UPBIT_SECRET_KEY, algorithm="HS256")
    if isinstance(token, bytes):
        token = token.decode()
    return {"Authorization": f"Bearer {token}"}

def upbit_private_get(path, params=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    items = list(params.items()) if isinstance(params, dict) else (params or [])
    for attempt in range(3):
        headers = _make_auth_headers(items)  # â— ë§¤ì‹œë„ë§ˆë‹¤ ìƒˆ nonce/JWT
        try:
            _throttle()
            with _session_lock:
                r = SESSION.get(url, headers=headers, params=items, timeout=timeout)
            if r.status_code in (429, 500, 502, 503, 504):
                time.sleep(0.25 * (2 ** attempt))
                continue
            r.raise_for_status()
            return r.json()

        except requests.HTTPError as e:
            status = getattr(e.response, "status_code", None)
            body_txt = getattr(e.response, "text", "")
            print(f"[UPBIT_GET_HTTPERROR] {path} {e} body={body_txt}")
            if status == 401:
                tg_send(f"âŒ Upbit 401(GET) {path}\n{body_txt[:800]}")
            if attempt == 2:
                raise
            time.sleep(0.25 * (2 ** attempt))

        except requests.RequestException as e:
            print(f"[UPBIT_GET_REQERR] {path} {e}")
            if attempt == 2:
                raise
            time.sleep(0.25 * (2 ** attempt))

def upbit_private_post(path, body=None, timeout=7):
    url = f"https://api.upbit.com{path}"
    body = body or {}
    # ìˆœì„œ ë³´ì¡´: dictë©´ itemsë¡œ, listë©´ ê·¸ëŒ€ë¡œ
    if isinstance(body, dict):
        items = list(body.items())
    elif isinstance(body, list):
        items = body[:]
    else:
        raise TypeError("body must be dict or list[tuple]")

    for attempt in range(3):
        headers = _make_auth_headers(items)  # â— ë§¤ì‹œë„ë§ˆë‹¤ ìƒˆ nonce/JWT
        try:
            _throttle()
            with _session_lock:
                # UpbitëŠ” query string ê¸°ì¤€ìœ¼ë¡œ query_hash ê²€ì¦
                r = SESSION.post(url, headers=headers, params=items, timeout=timeout)
            if r.status_code in (429, 500, 502, 503, 504):
                time.sleep(0.25 * (2 ** attempt))
                continue
            r.raise_for_status()
            return r.json()

        except requests.HTTPError as e:
            status = getattr(e.response, "status_code", None)
            body_txt = getattr(e.response, "text", "")
            print(f"[UPBIT_POST_HTTPERROR] {path} {e} body={body_txt}")
            if status == 401:
                tg_send(f"âŒ Upbit 401(POST) {path}\n{body_txt[:800]}")
            if attempt == 2:
                raise
            time.sleep(0.25 * (2 ** attempt))

        except requests.RequestException as e:
            print(f"[UPBIT_POST_REQERR] {path} {e}")
            if attempt == 2:
                raise
            time.sleep(0.25 * (2 ** attempt))


def get_order_result(uuid_str, timeout_sec=10.0):
    """
    ì£¼ë¬¸ uuid ë¡œ ìµœì¢… ì²´ê²° ê²°ê³¼ ì¡°íšŒ (ì§€ì—° ë‚´ì„± ê°•í™”)
    - done / cancel ìƒíƒœê°€ ë˜ê±°ë‚˜ timeout ë  ë•Œê¹Œì§€ polling
    - íƒ€ì„ì•„ì›ƒ ì„ë°• ì‹œ 1íšŒ ì¶”ê°€ ì§€ì—° í›„ ì¬ì¡°íšŒ
    """
    if not uuid_str:
        return None
    deadline = time.time() + timeout_sec
    last = None
    while time.time() < deadline:
        try:
            od = upbit_private_get("/v1/order", {"uuid": uuid_str})
            last = od
            state = od.get("state")
            if state in ("done", "cancel"):
                break
        except requests.HTTPError as e:
            if getattr(e, "response", None) and e.response.status_code == 404:
                break
        except Exception:
            last = None
        time.sleep(0.3)

    # ìƒíƒœ ë°˜ì˜ ì§€ì—° ëŒ€ë¹„: ë§ˆì§€ë§‰ìœ¼ë¡œ í•œ ë²ˆ ë”
    if last and last.get("state") not in ("done", "cancel"):
        time.sleep(0.8)
        try:
            last = upbit_private_get("/v1/order", {"uuid": uuid_str})
        except Exception:
            pass
    return last

def get_account_info():
    """ì—…ë¹„íŠ¸ ê³„ì¢Œ(ì”ê³ ) ì¡°íšŒ"""
    try:
        return upbit_private_get("/v1/accounts")
    except Exception as e:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨:", e)
        return []


def get_krw_balance():
    """KRW ì”ê³  ì¡°íšŒ"""
    accounts = get_account_info()
    for a in accounts or []:
        if a.get("currency") == "KRW":
            return float(a.get("balance", "0"))
    return 0.0


def startup_selfcheck():
    """
    ì—…ë¹„íŠ¸ Private ì¸ì¦ ì¦‰ì‹œ ì ê²€.
    - /v1/accounts í˜¸ì¶œ ì„±ê³µ â†’ True
    - 401/ê¶Œí•œ/í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸/í‚¤ì˜¤ë¥˜ ë“± â†’ TGë¡œ ë³¸ë¬¸ê¹Œì§€ ì „ì†¡í•˜ê³  False
    """
    try:
        js = upbit_private_get("/v1/accounts")
        if isinstance(js, list):
            print("âœ… Upbit private OK (accounts ì¡°íšŒ ì„±ê³µ)")
            return True
        print("âš ï¸ accounts ì‘ë‹µ ë¹„ì •ìƒ:", js)
        tg_send(f"âš ï¸ Upbit accounts ì‘ë‹µ ë¹„ì •ìƒ\n{js}")
        return False
    except requests.HTTPError as e:
        body = getattr(e.response, "text", "")
        print("âŒ Upbit auth ì‹¤íŒ¨:", e, "| body=", body)
        tg_send(f"âŒ Upbit ì¸ì¦ ì‹¤íŒ¨\n{e}\n{body[:800]}")
        return False
    except Exception as e:
        print("âŒ Upbit selfcheck ì˜ˆì™¸:", e)
        tg_send(f"âŒ Upbit selfcheck ì˜ˆì™¸\n{e}")
        return False


def calc_position_size(entry_price, stop_price, total_equity, risk_pct):
    """
    ì†ì ˆê°€ ê¸°ì¤€ìœ¼ë¡œ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    - total_equity * risk_pct ë§Œí¼ë§Œ ìµœëŒ€ ì†ì‹¤ í—ˆìš©
    - ì†ì ˆí­ì´ 0.05% ë¯¸ë§Œì´ë©´ 0 ë°˜í™˜ (ê³¼ëŒ€ë§¤ìˆ˜ ë°©ì§€)
    """
    # â˜… ì•ˆì „ê°€ë“œ: ë¹„ì •ìƒ ê°€ê²©/ì†ì ˆ ì‹œ ì§„ì… ê¸ˆì§€
    if entry_price <= 0 or stop_price <= 0:
        return 0.0

    per_unit_loss = entry_price - stop_price

    # â˜… ì†ì ˆí­ì´ 0.05% ë¯¸ë§Œì´ë©´ ì§„ì… ìŠ¤í‚µ (ê³¼ëŒ€ë§¤ìˆ˜ ë°©ì§€)
    if per_unit_loss <= entry_price * 0.0005:
        return 0.0

    risk_krw = total_equity * max(risk_pct, 0)
    qty = risk_krw / per_unit_loss
    return max(qty, 0.0)


def place_market_buy(market, krw_amount):
    """KRW ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ìˆ˜ (ord_type=price)"""
    body = [
        ("market", market),
        ("side", "bid"),
        ("ord_type", "price"),
        ("price", str(int(krw_amount))),
    ]
    return upbit_private_post("/v1/orders", body)


def place_market_sell(market, volume):
    """ìˆ˜ëŸ‰ ê¸°ì¤€ ì‹œì¥ê°€ ë§¤ë„"""
    body = [
        ("market", market),
        ("side", "ask"),
        ("ord_type", "market"),
        ("volume", str(volume)),
    ]
    return upbit_private_post("/v1/orders", body)

def final_price_guard(m, initial_price, max_drift=0.018):
    """
    ì£¼ë¬¸ ì§ì „ ê°€ê²© ì¬í™•ì¸
    - initial_price: ì‹ í˜¸ ë°œìƒ ì‹œ ê¸°ì¤€ ê°€ê²© (pre['price'])
    - max_drift: ì‹ í˜¸ê°€ ëŒ€ë¹„ í—ˆìš© ìƒìŠ¹ë¥  (ê¸°ë³¸ 1.8%)
    - AGGRESSIVE_MODE=True ì¸ ê²½ìš°, max_drift~max_drift+1.5% êµ¬ê°„ì€
      'ì¶”ê²© ì§„ì…'ìœ¼ë¡œ ì†Œì•¡/í”¼ë¼ë¯¸ë”© ê¸°ë°˜ ì§„ì… í—ˆìš©
    """
    # â˜… ê°€ê²© 0/None ë°©ì–´ (ë¹„ì •ìƒ ì‹ í˜¸ ì°¨ë‹¨)
    if not initial_price or initial_price <= 0:
        print(f"[GUARD] {m} initial_price ë¹„ì •ìƒ({initial_price}) â†’ ì§„ì… ì·¨ì†Œ")
        return False, 0

    try:
        js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        if not js:
            print(f"[GUARD] {m} í‹°ì»¤ ì¡°íšŒ ì‹¤íŒ¨ â†’ ê°€ë“œ ìŠ¤í‚µ")
            return True, initial_price

        current_price = js[0].get("trade_price", initial_price)
        drift = (current_price / initial_price - 1.0)

        if drift > max_drift:
            # í‰ì†Œë¼ë©´ ê³ ì  ì¶”ê²©ìœ¼ë¡œ ì»·
            # í•˜ì§€ë§Œ ê³µê²© ëª¨ë“œë©´ ì¼ì • êµ¬ê°„ê¹Œì§€ëŠ” í—ˆìš©
            if AGGRESSIVE_MODE and drift <= (max_drift + 0.015):
                print(
                    f"[GUARD][AGGR] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% "
                    f"â†’ ê³µê²© ëª¨ë“œ: ì¶”ê²© ì§„ì… í—ˆìš© (ì†Œì•¡/í”¼ë¼ë¯¸ë”© ì „ì œ)"
                )
                return True, current_price

            # ì´ ì´ìƒì€ ì§„ì§œ ë„ˆë¬´ íŠ„ ê±°ë¼ ì»·
            print(f"[GUARD] {m} ê°€ê²© ê¸‰ë“± {drift*100:.2f}% â†’ ì§„ì… ì·¨ì†Œ")
            return False, current_price

        return True, current_price

    except Exception as e:
        print(f"[GUARD_ERR] {m}: {e}")
        return True, initial_price

# =========================
# ğŸ”¥ ìë™ ë§¤ìˆ˜ ì§„ì…
# =========================
def open_auto_position(m, pre, dyn_stop, eff_sl_pct, *, override_krw=None):
    """
    ì´ˆì…Â·ê³µê²©ëª¨ë“œ ëŒ€ì‘ ìë™ ë§¤ìˆ˜ ì§„ì…
    Args:
        override_krw: í”„ë¡œë¸Œ ê¸ˆì•¡ ì˜¤ë²„ë¼ì´ë“œ (ê¸€ë¡œë²Œ ë³€ê²½ ë°©ì§€)
    """
    if not AUTO_TRADE:
        return

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        print("[AUTO] API í‚¤ ë¯¸ì„¤ì • â†’ ìë™ë§¤ìˆ˜ ìŠ¤í‚µ")
        return

    # ì´ë¯¸ í¬ì§€ì…˜ ìˆìœ¼ë©´ ìŠ¤í‚µ
    with _POSITION_LOCK:
        if m in OPEN_POSITIONS:
            print(f"[AUTO] ì´ë¯¸ {m} í¬ì§€ì…˜ ë³´ìœ ì¤‘ â†’ ì‹ ê·œ ì§„ì… ìŠ¤í‚µ")
            return

    # ë³´ìœ  ì¢…ëª© ìƒí•œ
    with _POSITION_LOCK:
        open_cnt = sum(1 for v in OPEN_POSITIONS.values() if v.get("volume", 0) > 0)
    if open_cnt >= MAX_OPEN_POSITIONS:
        msg = f"[AUTO] ë³´ìœ  ìƒí•œ {MAX_OPEN_POSITIONS}ê°œ ë„ë‹¬ â†’ {m} ì‹ ê·œ ì§„ì… ìŠ¤í‚µ"
        print(msg)
        tg_send_mid(msg)
        return

    signal_price = pre.get("price")
    # â˜… ê°€ê²© 0/None ë°©ì–´ (ë¹„ì •ìƒ ì‹ í˜¸ ì°¨ë‹¨)
    if not signal_price or signal_price <= 0:
        print(f"[AUTO] {m} pre['price'] ë¹„ì •ìƒ({signal_price}) â†’ ì§„ì… ìŠ¤í‚µ")
        return

    # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì…ëª¨ë“œ ë°˜ì˜ ===
    entry_mode = pre.get("entry_mode", "confirm")

    # âœ… ALWAYS_PROBE_FIRST: ì²« ì§„ì…ì€ ë¬´ì¡°ê±´ probe (7000ì›)
    if ALWAYS_PROBE_FIRST:
        entry_mode = "probe"

    if entry_mode == "probe":
        entry_fraction = 0.1   # (ì°¸ê³ ) ê³„ì‚°ì€ í•˜ë˜, ì‹¤ì œ ì£¼ë¬¸ê¸ˆì•¡ì€ PROBE_KRWë¡œ ê°•ì œ
        mode_emoji = "ğŸ§­"
    elif entry_mode == "confirm":
        entry_fraction = 1.0
        mode_emoji = "ğŸ”¥"
    else:
        entry_fraction = 1.0
        mode_emoji = "ğŸ¤–"

    # â˜… ê°€ê²© ê°€ë“œ: probe/confirm ë¶„ë¦¬ (ê³ ì  ì¶”ê²© ë°©ì§€ ê°•í™”)
    if entry_mode == "probe":
        max_drift = 0.020 if AGGRESSIVE_MODE else 0.012  # 2.0% / 1.2% (ì¶•ì†Œ)
    else:
        max_drift = 0.015 if AGGRESSIVE_MODE else 0.008  # 1.5% / 0.8% (ì¶•ì†Œ)

    ok_guard, current_price = final_price_guard(m, signal_price, max_drift=max_drift)
    if not ok_guard:
        tg_send(
            f"âš ï¸ <b>ì§„ì… ì·¨ì†Œ</b> {m}\n"
            f"â€¢ ì‹ í˜¸ê°€: {fmt_price(signal_price)}ì›\n"
            f"â€¢ í˜„ì¬ê°€: {fmt_price(current_price)}ì›\n"
            f"â€¢ ìƒìŠ¹ë¥ : {((current_price / signal_price - 1) * 100):.2f}%\n"
            f"â€¢ ì‚¬ìœ : ê°€ê²© ê¸‰ë“± (ì´ˆì… ì¶”ê²© ìœ„í—˜)"
        )
        return

    # === ê³¼ì—´ ì¶”ê²© ë°©ì§€: VWAP/EMA5/BB ê³¼ì—´ì´ë©´ ì°¨ë‹¨ ë˜ëŠ” ê°•ë“± ===
    try:
        c1m = get_minutes_candles(1, m, 20)
        vwap20 = vwap_from_candles_1m(c1m, 20)
        ema5_now = ema_last([c["trade_price"] for c in c1m], 5)
        vgap = (current_price / max(vwap20, 1) - 1.0) if vwap20 else 0.0
        egap = (current_price / max(ema5_now, 1) - 1.0) if ema5_now else 0.0

        # â˜… ë³¼ë¦°ì € ë°´ë“œ ìƒë‹¨ ì²´í¬ (í™•ì¥ ë ì¶”ê²© ì°¨ë‹¨)
        bb = bollinger_bands(c1m, period=20, std_mult=2.0)
        bb_upper = bb["upper"] if bb else current_price * 1.02
        bb_exceed = (current_price > bb_upper * 1.001)  # ìƒë‹¨ 0.1% ì´ˆê³¼

        # â˜… ê±°ë˜ëŸ‰ ì¶”ì„¸ ì²´í¬ (ë‘”í™” ì‹œ ì§„ì… ê¸ˆì§€)
        if len(c1m) >= 4:
            vol_recent = sum(c["candle_acc_trade_volume"] for c in c1m[-2:]) / 2  # ìµœê·¼ 2ë´‰ í‰ê· 
            vol_prev = sum(c["candle_acc_trade_volume"] for c in c1m[-4:-2]) / 2  # ì§ì „ 2ë´‰ í‰ê· 
            vol_declining = (vol_recent < vol_prev * 0.7)  # 30% ì´ìƒ ê°ì†Œ
        else:
            vol_declining = False
    except Exception:
        vgap = egap = 0.0
        bb_exceed = False
        vol_declining = False

    # â˜… BB ìƒë‹¨ ì´ˆê³¼ or ê±°ë˜ëŸ‰ ë‘”í™” â†’ ì»¨íŒ ì°¨ë‹¨, í”„ë¡œë¸ŒëŠ” ê°•ë“±/ì¶•ì†Œ
    if bb_exceed or vol_declining:
        reason = "BBìƒë‹¨ì´ˆê³¼" if bb_exceed else "ê±°ë˜ëŸ‰ë‘”í™”"
        if entry_mode == "confirm":
            # ì»¨íŒì€ ì°¨ë‹¨í•˜ë˜ í”„ë¡œë¸Œë¡œ ê°•ë“±í•´ ì†Œì•¡ íƒìƒ‰ í—ˆìš©
            entry_mode = "probe"
            entry_fraction = 0.10
            mode_emoji = "ğŸ§­"
            override_krw = min(PROBE_KRW, 7000)
            print(f"[EXPANSION_END] {m} {reason} â†’ confirmâ†’probe ê°•ë“± (ì†Œì•¡ íƒìƒ‰)")
        else:
            # ì´ë¯¸ probeë©´ ì§„ì…ì€ í—ˆìš©í•˜ë˜ ê¸ˆì•¡ ì¶•ì†Œ
            override_krw = min(PROBE_KRW, 7000)
            print(f"[EXPANSION_END] {m} {reason} â†’ probe ê¸ˆì•¡ ì¶•ì†Œ ì§„ì…")

    # VWAP/EMA5 ê³¼ì—´ â†’ confirmâ†’probe ê°•ë“±
    if entry_mode == "confirm" and (vgap >= 0.018 or egap >= 0.022):
        entry_mode = "probe"
        entry_fraction = 0.10
        mode_emoji = "ğŸ§­"
        print(f"[OVERHEAT] {m} ê³¼ì—´ ì¶”ê²© ë°©ì§€: confirmâ†’probe ê°•ë“± (vgap={vgap:.3f}, egap={egap:.3f})")

    # === ê³„ì¢Œ & ì£¼ë¬¸ê¸ˆì•¡ ê³„ì‚° ===
    accounts = get_account_info()
    if not accounts:
        print("[AUTO] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
        return

    krw_bal = 0.0
    for a in accounts:
        if a.get("currency") == "KRW":
            krw_bal = float(a.get("balance", "0"))
            break

    if krw_bal < 6000:
        print(f"[AUTO] KRW ë¶€ì¡± ({krw_bal:,.0f}) â†’ ìŠ¤í‚µ")
        return

    entry_price = current_price
    stop_price = dyn_stop

    # âœ… ìµœê·¼ ìŠ¹ë¥  ê¸°ë°˜ ë™ì  ë¦¬ìŠ¤í¬
    adaptive_risk = get_adaptive_risk()

    # === í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… êµ¬ì¡° ===
    risk_to_use = adaptive_risk * SEED_RISK_FRACTION if USE_PYRAMIDING else adaptive_risk
    risk_to_use *= entry_fraction  # probeëŠ” ë¦¬ìŠ¤í¬ ì¶•ì†Œ ë°˜ì˜

    base_qty = calc_position_size(
        entry_price,
        stop_price,
        krw_bal,
        risk_to_use,
    )

    # â˜… ì•ˆì „ê°€ë“œ: í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ 0ì´ë©´ ì§„ì… ìŠ¤í‚µ (ë¹„ì •ìƒ ì†ì ˆê°€ ë“±)
    if base_qty <= 0 and entry_mode != "probe":
        print(f"[AUTO] {m} í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ 0 (ì†ì ˆí­ ë¶€ì¡±) â†’ ì§„ì… ìŠ¤í‚µ")
        return

    if entry_mode == "probe":
        # âœ… ì—¼íƒì€ í•­ìƒ ê³ ì • ìµœì†Œê¸ˆì•¡ìœ¼ë¡œë§Œ
        # override_krwê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš© (ê¸€ë¡œë²Œ ë³€ê²½ ë°©ì§€)
        probe_krw = override_krw if override_krw is not None else PROBE_KRW
        krw_to_use = min(krw_bal, max(5000, probe_krw))
    else:
        krw_to_use = min(krw_bal, int(base_qty * entry_price))  # â˜… ì”ê³  ì´ˆê³¼ ë°©ì§€

    if krw_to_use < 5000:
        print(f"[AUTO] ì£¼ë¬¸ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ")
        return

    krw_to_use = int(krw_to_use)

    # === ë§¤ìˆ˜ ===
    try:
        res = place_market_buy(m, krw_to_use)
        print("[AUTO_BUY_RES]", json.dumps(res, ensure_ascii=False))  # â˜…ì¶”ê°€
        oid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(oid, timeout_sec=6) if oid else None
        print("[AUTO_BUY_ORDER]", json.dumps(od, ensure_ascii=False))  # â˜…ì¶”ê°€

        if od:
            volume_filled = float(od.get("executed_volume") or "0")
        else:
            volume_filled = 0.0

        if volume_filled <= 0:
            msg = f"[AUTO] {m} ìë™ë§¤ìˆ˜ ì²´ê²° 0 â†’ í¬ì§€ì…˜ ìƒì„± ì•ˆ í•¨"
            print(msg)
            tg_send(f"âš ï¸ {msg}")
            return

        # í‰ê· ê°€ ê³„ì‚°
        trades = od.get("trades") or []
        if trades:
            total_krw = sum(float(tr["price"]) * float(tr["volume"]) for tr in trades)
            total_vol = sum(float(tr["volume"]) for tr in trades)
            avg_price = total_krw / total_vol if total_vol > 0 else entry_price
        else:
            avg_price = float(entry_price)  # ëª…ì‹œì  float

    except requests.HTTPError as e:
        body = getattr(e.response, "text", "")
        print("[AUTO BUY ERR]", e, body)
        tg_send(f"âš ï¸ ë§¤ìˆ˜ ì‹¤íŒ¨ {m}\n{e}\n{body}")
        return
    except Exception as e:
        print("[AUTO BUY ERR]", e)
        tg_send(f"âš ï¸ ë§¤ìˆ˜ ì‹¤íŒ¨ {m}\n{e}")
        return

    # === í¬ì§€ì…˜ ì €ì¥ ===
    with _POSITION_LOCK:
        OPEN_POSITIONS[m] = {
            "entry_price": avg_price,
            "volume": volume_filled,
            "stop": stop_price,
            "sl_pct": eff_sl_pct,
            "state": "open",
            "last_add_ts": 0.0,
            "entry_mode": entry_mode,
            "adds": 0,                 # âœ… ì¶”ë§¤ íšŸìˆ˜ ì¹´ìš´í„°
        }


    slip_pct = (avg_price / signal_price - 1.0) if signal_price else 0.0

    tg_send(
        f"{mode_emoji} <b>ìë™ë§¤ìˆ˜ ì²´ê²° ({entry_mode})</b> {m}\n"
        f"â€¢ ì‹ í˜¸ê°€: {fmt_price(signal_price)}ì›\n"
        f"â€¢ ì²´ê²°ê°€: {fmt_price(avg_price)}ì›\n"
        f"â€¢ ìŠ¬ë¦¬í”¼ì§€: {slip_pct*100:+.3f}%\n"
        f"â€¢ ì£¼ë¬¸ê¸ˆì•¡: {krw_to_use:,.0f}ì› ({entry_fraction*100:.0f}% ë¹„ì¤‘)\n"
        f"â€¢ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
        f"â€¢ ì†ì ˆê°€: {fmt_price(stop_price)}ì›\n"
        f"{link_for(m)}"
    )

def add_auto_position(m, cur_price, override_krw=None):
    """
    ì´ë¯¸ seed í¬ì§€ì…˜ì´ ìˆì„ ë•Œ, ê°•í•œ ì¶”ì„¸ì—ì„œ 1íšŒ ì¶”ë§¤(add) ìˆ˜í–‰
    - ADD_RISK_FRACTION ë¹„ìœ¨ë§Œí¼ RISK_PER_TRADEë¥¼ ë‹¤ì‹œ ì‚¬ìš©
    - í‰ê· ë‹¨ê°€ ì¬ê³„ì‚°

    Args:
        override_krw: ì¶”ë§¤ ê¸ˆì•¡ ê°•ì œ ì§€ì • (í”„ë¡œë¸Œ 2.0 ë“±ì—ì„œ ì‚¬ìš©)
    """
    if not AUTO_TRADE:
        return False, None

    if not UPBIT_ACCESS_KEY or not UPBIT_SECRET_KEY:
        return False, None

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            return False, None
        if pos.get("adds", 0) >= MAX_ADDS:
            # ì¶”ë§¤ ìµœëŒ€ íšŸìˆ˜ ë„ë‹¬
            return False, None
        last_add_ts = pos.get("last_add_ts", 0.0)
        adds_count = pos.get("adds", 0)  # â˜… ì¶”ë§¤ íšŸìˆ˜ (ì°¨ë“± ë¹„ìœ¨ìš©)

    now = time.time()
    if (now - last_add_ts) < PYRAMID_ADD_COOLDOWN_SEC:
        return False, None

    # â˜… ì”ê³  ì‚¬ìš© ì „ì—­ ë½ (ë™ì‹œì„± ê²½í•© ë°©ì§€)
    with _FUNDS_LOCK:
        accounts = get_account_info()
        if not accounts:
            print("[AUTO_ADD] ê³„ì¢Œ ì¡°íšŒ ì‹¤íŒ¨")
            return False, None

        krw_bal = 0.0
        for a in accounts:
            if a.get("currency") == "KRW":
                krw_bal = float(a.get("balance", "0"))
                break

        # â˜… í—¤ë“œë£¸ ì ìš©: ìˆ˜ìˆ˜ë£Œ+ì—¬ìœ  0.7% ì°¨ê°
        SAFE_HEADROOM = 0.007
        usable_krw = max(0, int(krw_bal * (1 - SAFE_HEADROOM)))

        if usable_krw < 6000:
            print(f"[AUTO_ADD] ê°€ìš© KRW ë¶€ì¡±({usable_krw:,.0f}) â†’ ì¶”ë§¤ ìŠ¤í‚µ")
            return False, None

        entry_price_old = pos["entry_price"]
        stop_price = pos["stop"]

        # â˜… override_krwê°€ ì§€ì •ë˜ë©´ ê·¸ ê¸ˆì•¡ ì‚¬ìš©, ì•„ë‹ˆë©´ ë¦¬ìŠ¤í¬ ê¸°ë°˜ ê³„ì‚°
        if override_krw is not None:
            want_krw = int(override_krw)
            qty_theoretical = None  # override ëª¨ë“œì—ì„œëŠ” ì´ë¡ ìˆ˜ëŸ‰ ê³„ì‚° ì•ˆ í•¨
        else:
            # â˜…â˜…â˜… ì¶”ë§¤ ì°¨ë“± ë¹„ìœ¨: 1ì°¨(í™•ì‹ ) í¬ê²Œ â†’ ì ì  ì‘ê²Œ (ê³ ì  ë¬¼ë¦¼ ë°©ì§€)
            if adds_count == 0:  # 1ì°¨ ì¶”ë§¤ (probeâ†’confirm ì „í™˜)
                add_risk_pct = 0.01  # 1.0% (ê°€ì¥ í¬ê²Œ, í™•ì‹  ì§„ì…)
            elif adds_count == 1:  # 2ì°¨ ì¶”ë§¤
                add_risk_pct = 0.006  # 0.6%
            elif adds_count == 2:  # 3ì°¨ ì¶”ë§¤
                add_risk_pct = 0.004  # 0.4%
            else:  # 4ì°¨+ ì¶”ë§¤
                add_risk_pct = 0.003  # 0.3%

            qty_theoretical = calc_position_size(cur_price, stop_price, krw_bal, add_risk_pct)
            want_krw = int(qty_theoretical * cur_price) if qty_theoretical else 0

        krw_to_use = min(usable_krw, want_krw)

        # â˜… ìµœì†Œ ê¸ˆì•¡ 5100ì› (ìˆ˜ìˆ˜ë£Œ í—¤ë“œë£¸ í¬í•¨)
        if krw_to_use < 5100:
            print(f"[AUTO_ADD] ì£¼ë¬¸ ê¸ˆì•¡ {krw_to_use:,.0f}ì› < 5,100ì› â†’ ìŠ¤í‚µ")
            return False, None

        krw_to_use = int(krw_to_use)

        # â˜… NameError ë°©ì§€: override ëª¨ë“œì—ì„œëŠ” ì´ë¡ ìˆ˜ëŸ‰ ì¶œë ¥ ìƒëµ
        if qty_theoretical is not None:
            print(f"[AUTO_ADD] {m} ì¶”ë§¤ ì‹œë„: {krw_to_use:,.0f} KRW (ì´ë¡ ìˆ˜ëŸ‰â‰ˆ{qty_theoretical:.6f}, í˜„ì¬ê°€ {cur_price:,.0f})")
        else:
            print(f"[AUTO_ADD] {m} ì¶”ë§¤ ì‹œë„: {krw_to_use:,.0f} KRW (ê³ ì •ê¸ˆì•¡, í˜„ì¬ê°€ {cur_price:,.0f})")

        volume_filled = 0.0
        avg_price_add = cur_price

        try:
            res = place_market_buy(m, krw_to_use)
            order_uuid = res.get("uuid") if isinstance(res, dict) else None
            od = get_order_result(order_uuid, timeout_sec=15.0) if order_uuid else None  # â˜… 6â†’15ì´ˆ ì—°ì¥

            if od:
                try:
                    volume_filled = float(od.get("executed_volume") or "0")
                except Exception:
                    volume_filled = 0.0

                trades = od.get("trades") or []
                if trades and volume_filled > 0:
                    total_krw = 0.0
                    total_vol = 0.0
                    for tr in trades:
                        p = float(tr.get("price", "0"))
                        v = float(tr.get("volume", "0"))
                        total_krw += p * v
                        total_vol += v
                    if total_vol > 0:
                        avg_price_add = total_krw / total_vol
                else:
                    if volume_filled > 0:
                        avg_price_add = krw_to_use / volume_filled

            if volume_filled <= 0:
                msg = f"[AUTO_ADD] {m} ì¶”ë§¤ ì²´ê²° 0 â†’ ë¬´ì‹œ"
                print(msg)
                tg_send(f"âš ï¸ {msg}")
                return False, None

        except requests.HTTPError as e:
            # â˜… HTTP 400 ìƒì„¸ ì‚¬ìœ  ë¡œê¹…
            status = getattr(e.response, "status_code", None)
            body = ""
            try:
                body = e.response.text
            except Exception:
                pass
            reason = body[:300] if body else str(e)
            print(f"[AUTO_ADD HTTP {status}]", reason)
            tg_send(f"âš ï¸ <b>ì¶”ë§¤ ì‹¤íŒ¨ (HTTP {status})</b> {m}\n{reason}")
            return False, None
        except Exception as e:
            print("[AUTO_ADD ERR]", e)
            tg_send(f"âš ï¸ <b>ì¶”ë§¤ ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")
            return False, None

    # í‰ê· ë‹¨ê°€ ê°±ì‹ 
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos:
            return False, None
        old_vol = pos.get("volume", 0.0)
        new_vol = old_vol + volume_filled
        if new_vol <= 0:
            return False, None
        new_entry_price = (entry_price_old * old_vol + avg_price_add * volume_filled) / new_vol

        pos["entry_price"] = new_entry_price
        pos["volume"] = new_vol
        pos["adds"] = pos.get("adds", 0) + 1     # âœ… ëˆ„ì  ì¶”ë§¤íšŒìˆ˜
        pos["last_add_ts"] = time.time()
        pos["last_add_price"] = avg_price_add   # â˜… ì¶”ë§¤ ê²€ì¦ìš©
        pos["last_add_volume"] = volume_filled  # â˜… ì¶”ë§¤ ë¡¤ë°±ìš©
        pos["entry_mode"] = "confirm"
        pos["added"] = True                      # (í•˜ìœ„í˜¸í™˜ìš©, ë‹¤ë¥¸ ê³³ì—ì„œ ì°¸ì¡°í•  ìˆ˜ë„ ìˆìœ¼ë‹ˆ ìœ ì§€)

    # ì¶”ë§¤ ê¸ˆì•¡ ê³„ì‚° ë° ì°¨ìˆ˜ í‘œì‹œ
    add_krw_amount = avg_price_add * volume_filled
    current_adds = pos.get("adds", 0)  # ë°©ê¸ˆ ì—…ë°ì´íŠ¸ëœ ê°’ (1, 2, 3, ...)

    # ë¹„ìœ¨ ë§¤í•‘ (í‘œì‹œìš©)
    risk_pct_map = {1: "1.0%", 2: "0.6%", 3: "0.4%"}
    risk_label = risk_pct_map.get(current_adds, "0.3%")

    tg_send(
        f"ğŸ“ˆ <b>ì¶”ë§¤ ì²´ê²° ({current_adds}ì°¨ - {risk_label})</b> {m}\n"
        f"â€¢ ì¶”ê°€ ì²´ê²°ê°€: {fmt_price(avg_price_add)}ì›\n"
        f"â€¢ ì¶”ê°€ ìˆ˜ëŸ‰: {volume_filled:.6f}\n"
        f"â€¢ ì¶”ê°€ ê¸ˆì•¡: {add_krw_amount:,.0f}ì›\n"
        f"â€¢ ì´ ìˆ˜ëŸ‰: {new_vol:.6f}\n"
        f"â€¢ ìƒˆë¡œìš´ í‰ë‹¨: {fmt_price(new_entry_price)}ì›\n"
        f"{link_for(m)}"
    )

    return True, new_entry_price

# =========================
# ğŸ”¥ ìë™ ì²­ì‚°
# =========================
def close_auto_position(m, reason=""):
    """
    ì†ì ˆ/ì²­ì‚° ì‹œ ìë™ ë§¤ë„
    - ì‹¤ì œ ì²´ê²°ëœ ê²½ìš°ì—ë§Œ í¬ì§€ì…˜ ì œê±°
    - ë¶€ë¶„ì²´ê²°ì´ë©´ ì”ëŸ‰ ìœ ì§€(volume ì—…ë°ì´íŠ¸)
    """
    if not AUTO_TRADE:
        print(f"[AUTO] AUTO_TRADE=0 â†’ ì²­ì‚° ìŠ¤í‚µ ({m}, reason={reason})")
        return

    # â˜… ì²­ì‚° ì‹¤íŒ¨ ì¿¨ë‹¤ìš´ ì²´í¬ (ìŠ¤íŒ¸ ì£¼ë¬¸ ë°©ì§€)
    last_attempt = LAST_EXIT_ATTEMPT.get(m, 0)
    if time.time() - last_attempt < 10:  # 10ì´ˆ ì¿¨ë‹¤ìš´
        print(f"[AUTO] {m} ì²­ì‚° ì¬ì‹œë„ ì¿¨ë‹¤ìš´ ì¤‘ (ë§ˆì§€ë§‰ ì‹œë„ {time.time()-last_attempt:.1f}ì´ˆ ì „)")
        # â˜… êµì°© ë°©ì§€: closing í”Œë˜ê·¸ í•´ì œ (ì¿¨ë‹¤ìš´ ì¤‘ì—ëŠ” ì¬ì‹œë„ ê°€ëŠ¥í•˜ê²Œ)
        with _POSITION_LOCK:
            pos = OPEN_POSITIONS.get(m)
            if pos:
                pos["closing"] = False
        return

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)

    if not pos:
        print(f"[AUTO] OPEN_POSITIONSì— {m} í¬ì§€ì…˜ ì—†ìŒ â†’ ì²­ì‚° ìŠ¤í‚µ (reason={reason})")
        tg_send_mid(f"âš ï¸ {m} ì²­ì‚° ì‹œë„í–ˆëŠ”ë° OPEN_POSITIONSì— í¬ì§€ì…˜ ì—†ìŒ")
        return

    tg_send_mid(f"ğŸ’£ {m} ìë™ì²­ì‚° ì‹œë„ (reason={reason}, vol={pos.get('volume',0):.6f})")

    vol = pos.get("volume", 0.0)
    if vol <= 0:
        print(f"[AUTO] {m} volume<=0 ({vol}) â†’ í¬ì§€ì…˜ ì œê±°ë§Œ ìˆ˜í–‰")
        with _POSITION_LOCK:
            OPEN_POSITIONS.pop(m, None)
        return

    entry_price = float(pos.get("entry_price", 0.0)) or 0.0

    # í˜„ì¬ê°€(ì²­ì‚° ì „ ê¸°ì¤€) ì¡°íšŒ - ê³µìš© ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš© (ì„œëª… ì˜¤ë²„í—¤ë“œ ì œê±°)
    try:
        cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        cur_price = float(cur_js[0].get("trade_price", entry_price)) if cur_js else entry_price
    except Exception:
        cur_price = entry_price

    # ì„  ê³„ì‚°(ëŒ€ëµ)
    ret_pct = ((cur_price / entry_price - 1.0) * 100.0) if entry_price > 0 else 0.0
    est_entry_value = entry_price * vol
    est_exit_value = cur_price * vol
    pl_value = est_exit_value - est_entry_value

    print(f"[AUTO] {m} ì²­ì‚° ì‹œë„: volume={vol}, reason={reason}, PnL(ì„ ê³„ì‚°)={ret_pct:+.2f}%")

    # â˜… ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ (5,000ì› ë¯¸ë§Œ ì‹œ ê±°ì ˆ ë°©ì§€)
    estimated_order_krw = cur_price * vol
    if estimated_order_krw < 5000:
        print(f"[AUTO] {m} ì²­ì‚° ì˜ˆìƒê¸ˆì•¡ {estimated_order_krw:,.0f}ì› < 5,000ì› â†’ ì£¼ë¬¸ ìŠ¤í‚µ")
        tg_send_mid(f"âš ï¸ {m} ì²­ì‚° ë¶ˆê°€: ì˜ˆìƒê¸ˆì•¡ {estimated_order_krw:,.0f}ì› < 5,000ì› (ìµœì†Œì£¼ë¬¸ê¸ˆì•¡)")
        # closing í”Œë˜ê·¸ í•´ì œ
        with _POSITION_LOCK:
            pos = OPEN_POSITIONS.get(m)
            if pos:
                pos["closing"] = False
        return

    exit_price_used = cur_price  # ì‹¤ì œ ì²´ê²°ê°€ ì„±ê³µ ì‹œ êµì²´
    executed_vol = 0.0           # ì‹¤ì œ ì²´ê²° ìˆ˜ëŸ‰
    sell_ok = False

    try:
        res = place_market_sell(m, vol)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid, timeout_sec=6.0) if order_uuid else None

        # ì‹¤ì œ ì²´ê²°ê°€/ì²´ê²°ìˆ˜ëŸ‰ ê³„ì‚°
        if od:
            trades = od.get("trades") or []
            total_krw = 0.0
            total_vol = 0.0
            for tr in trades:
                try:
                    p = float(tr.get("price", "0") or 0)
                    v = float(tr.get("volume", "0") or 0)
                except Exception:
                    continue
                total_krw += p * v
                total_vol += v
            if total_vol > 0:
                exit_price_used = total_krw / total_vol
                executed_vol = total_vol
            else:
                # ë°±ì—…: ìƒìœ„ í•„ë“œì— executed_volume ì œê³µë  ìˆ˜ ìˆìŒ
                try:
                    executed_vol = float(od.get("executed_volume") or 0.0)
                except Exception:
                    executed_vol = 0.0

        sell_ok = executed_vol > 0.0

        # ì‹¤ì œ ì²´ê²° ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°(ë¶€ë¶„ì²´ê²° í¬í•¨)
        if sell_ok:
            est_exit_value = exit_price_used * executed_vol
            est_entry_value = entry_price * executed_vol
            pl_value = est_exit_value - est_entry_value
            ret_pct = ((exit_price_used / entry_price - 1.0) * 100.0) if entry_price > 0 else 0.0
            ret_pct_after_fee = ret_pct - (FEE_RATE * 100.0)  # â˜… ì™•ë³µ ìˆ˜ìˆ˜ë£Œ ë°˜ì˜ (ì¼ê´€ì„±)

            # âŒ ì—¬ê¸°ì„œ record_trade() í˜¸ì¶œì€ ì œê±° (ì™„ì „ì¢…ë£Œì—ì„œë§Œ ê¸°ë¡)


        if sell_ok:
            tg_send(
                f"ğŸ’¥ <b>ìë™ì²­ì‚°</b> {m}\n"
                f"â€¢ ì‚¬ìœ : {reason}\n"
                f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {vol:.6f}\n"
                f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: {executed_vol:.6f}\n"
                f"â€¢ ë§¤ìˆ˜í‰ë‹¨: {fmt_price(entry_price)}ì›\n"
                f"â€¢ ì‹¤ë§¤ë„ê°€(í‰ê· ): {fmt_price(exit_price_used)}ì›\n"
                f"â€¢ ë§¤ìˆ˜ê¸ˆì•¡(ì²´ê²°ë¶„): {est_entry_value:,.0f}ì›\n"
                f"â€¢ ì²­ì‚°ê¸ˆì•¡(ì²´ê²°ë¶„): {est_exit_value:,.0f}ì›\n"
                f"â€¢ ìˆ˜ìµë¥ (ìˆ˜ìˆ˜ë£Œí›„): {ret_pct_after_fee:+.2f}%\n"
                f"{link_for(m)}"
            )
        else:
            tg_send_mid(
                f"âš ï¸ <b>ìë™ì²­ì‚° ì£¼ë¬¸ ë¯¸ì²´ê²°/ì‹¤íŒ¨</b> {m}\n"
                f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {vol:.6f}\n"
                f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: 0\n"
                f"â†’ ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± / ìœ ë™ì„± ë¶€ì¡± / ì£¼ë¬¸ ê±°ì ˆ ê°€ëŠ¥ì„± ì ê²€"
            )

    except Exception as e:
        print("[AUTO SELL ERR]", e)
        tg_send(f"âš ï¸ <b>ìë™ì²­ì‚° ì‹¤íŒ¨</b> {m}\nì‚¬ìœ : {e}")
        # ğŸ”’ ì‹¤íŒ¨ ì‹œ closing í•´ì œ (ì¬ì‹œë„ ê°€ëŠ¥í•˜ê²Œ)
        with _POSITION_LOCK:
            pos = OPEN_POSITIONS.get(m)
            if pos:
                pos["closing"] = False

    finally:
        # ğŸ”’ í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ë° í†µê³„ ê¸°ë¡ì€ 'ì™„ì „ ì¢…ë£Œ'ì—ì„œë§Œ
        if sell_ok:
            remaining = max(vol - executed_vol, 0.0)
            if remaining <= 1e-12:
                # âœ… ì™„ì „ ì¢…ë£Œ: í†µê³„/ì¿¨ë‹¤ìš´ ê¸°ë¡ + íŠ¸ë ˆì´ë“œ ê¸°ë¡
                ret_pct_after_fee = ret_pct - (FEE_RATE * 100.0)
                try:
                    record_trade(m, ret_pct_after_fee)
                except Exception as _e:
                    print("[TRADE_RECORD_ERR]", _e)

                profit_keywords = ["PROFIT", "TRAIL", "DROP_FROM_HIGH", "LOCK", "ìµì ˆ", "ìˆ˜ìµ"]
                is_profit = any(kw in (reason or "").upper() for kw in profit_keywords)

                with _POSITION_LOCK:
                    LAST_EXIT_AT[m] = time.time()
                    LAST_EXIT_CAUSE[m] = "profit" if is_profit else "loss"
                    OPEN_POSITIONS.pop(m, None)
                    # â˜… ì™„ì „ì²­ì‚° ì„±ê³µ ì‹œ ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”
                    LAST_EXIT_ATTEMPT.pop(m, None)
            else:
                # âœ… ë¶€ë¶„ì²­ì‚°: ì”ëŸ‰ ìœ ì§€, closing í•´ì œ, ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”
                with _POSITION_LOCK:
                    pos = OPEN_POSITIONS.get(m, {})
                    if pos:
                        pos["volume"] = remaining
                        pos["closing"] = False
                        OPEN_POSITIONS[m] = pos
                    # â˜… ë¶€ë¶„ì²­ì‚° ì„±ê³µ ì‹œ ì¿¨ë‹¤ìš´ ì´ˆê¸°í™” (ì´ì „ ì‹¤íŒ¨ ê¸°ë¡ ì œê±°)
                    LAST_EXIT_ATTEMPT.pop(m, None)
                tg_send_mid(f"â„¹ï¸ {m} ë¶€ë¶„ ì²­ì‚°: ì²´ê²° {executed_vol:.6f}, ì”ì—¬ {remaining:.6f} (í¬ì§€ì…˜ ìœ ì§€)")
        else:
            # âœ… ì‹¤íŒ¨/ë¯¸ì²´ê²°: ì‹œë„ë§Œ ê¸°ë¡ + closing í•´ì œ
            with _POSITION_LOCK:
                LAST_EXIT_ATTEMPT[m] = time.time()
                pos = OPEN_POSITIONS.get(m)
                if pos:
                    pos["closing"] = False

        # â˜… ìµœì¢… ì•ˆì „ë§: ëª¨ë“  ê²½ë¡œì—ì„œ closing í”Œë˜ê·¸ í™•ì‹¤íˆ í•´ì œ (ì™„ì „ì¢…ë£Œ ì œì™¸)
        with _POSITION_LOCK:
            if m in OPEN_POSITIONS:  # í¬ì§€ì…˜ì´ ì•„ì§ ë‚¨ì•„ìˆìœ¼ë©´
                pos = OPEN_POSITIONS.get(m)
                if pos and pos.get("closing") is not False:
                    pos["closing"] = False
                    print(f"[CLOSING_GUARD] {m} closing í”Œë˜ê·¸ ê°•ì œ í•´ì œ (ì•ˆì „ë§)")

def safe_partial_sell(m, sell_ratio=0.5, reason=""):
    """
    ë¶€ë¶„ ì²­ì‚° ê³µìš© í•¨ìˆ˜
    - sell_ratio: 0.5 â†’ 50%, 0.3 â†’ 30% ë“±
    - partial_done í”Œë˜ê·¸ë¡œ 1íšŒë§Œ ë¶€ë¶„ì²­ì‚°/ë¶€ë¶„ìµì ˆ í—ˆìš©
    ë°˜í™˜: (ì„±ê³µì—¬ë¶€:bool, ë©”ì‹œì§€:str, ì²´ê²°ëŸ‰:float)
    """
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)
        if not pos or pos.get("volume", 0) <= 0:
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: í¬ì§€ì…˜ ì—†ìŒ/ìˆ˜ëŸ‰ 0"
            print(msg)
            return False, msg, 0.0
        if pos.get("partial_done"):
            msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì´ë¯¸ ìˆ˜í–‰ë¨ â†’ ìŠ¤í‚µ"
            print(msg)
            return False, msg, 0.0
        current_volume = pos["volume"]

    sell_volume = current_volume * sell_ratio
    if sell_volume <= 0:
        msg = f"[REMONITOR] {m} ë¶€ë¶„ì²­ì‚° ì‹¤íŒ¨: sell_volume<=0"
        print(msg)
        return False, msg, 0.0

    # â˜… ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ì²´í¬ (5,000ì› ì´ìƒ)
    try:
        ticker_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
        current_price = float(ticker_js[0].get("trade_price", 0)) if ticker_js else 0
        if current_price > 0:
            order_krw = sell_volume * current_price
            if order_krw < 5000:
                msg = f"[PARTIAL_SELL_SKIP] {m} ì£¼ë¬¸ê¸ˆì•¡ {order_krw:.0f}ì› < 5,000ì› â†’ ìŠ¤í‚µ"
                print(msg)
                return False, msg, 0.0
    except Exception as e:
        print(f"[PARTIAL_SELL_CHECK_ERR] {m} ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨: {e}")
        # ì¡°íšŒ ì‹¤íŒ¨ ì‹œì—ë„ ì§„í–‰ (ë³´ìˆ˜ì )

    try:
        res = place_market_sell(m, sell_volume)
        order_uuid = res.get("uuid") if isinstance(res, dict) else None
        od = get_order_result(order_uuid, timeout_sec=6.0) if order_uuid else None

        executed = 0.0
        avg_sell_price = 0.0
        if od:
            try:
                executed = float(od.get("executed_volume") or "0")
            except Exception:
                executed = 0.0

            # í‰ê·  ì²´ê²°ê°€ ê³„ì‚°
            trades = od.get("trades") or []
            if trades and executed > 0:
                total_krw = sum(float(tr.get("price", 0)) * float(tr.get("volume", 0)) for tr in trades)
                avg_sell_price = total_krw / executed if executed > 0 else 0.0
            elif executed > 0 and current_price > 0:
                avg_sell_price = current_price  # fallback

        if executed <= 0:
            msg = f"[PARTIAL_SELL_ERR] {m}: executed_volume=0 (ìš”ì²­ {sell_volume:.6f})"
            print(msg)
            tg_send_mid(f"âš ï¸ <b>ë¶€ë¶„ì²­ì‚° ì£¼ë¬¸ ì‹¤íŒ¨</b> {m}\n"
                        f"â€¢ ìš”ì²­ ë¹„ìœ¨: {sell_ratio*100:.0f}%\n"
                        f"â€¢ ìš”ì²­ ìˆ˜ëŸ‰: {sell_volume:.6f}\n"
                        f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: 0 (ì‹¤íŒ¨)\n"
                        f"â†’ ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡ ë¶€ì¡± / ì£¼ë¬¸ê±°ì ˆ ê°€ëŠ¥ì„±")
            return False, msg, 0.0

        remaining_volume = max(current_volume - executed, 0.0)

        if remaining_volume <= 0:
            with _POSITION_LOCK:                                 # âœ… ì™„ì „ ì¢…ë£Œ
                LAST_EXIT_AT[m] = time.time()
                OPEN_POSITIONS.pop(m, None)
                LAST_EXIT_ATTEMPT.pop(m, None)  # â˜… ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”
        else:
            with _POSITION_LOCK:                                 # âœ… ë¶€ë¶„ì²­ì‚° í”Œë˜ê·¸
                pos2 = OPEN_POSITIONS.get(m)
                if pos2:
                    pos2["volume"] = remaining_volume
                    pos2["partial_done"] = True
                LAST_EXIT_ATTEMPT.pop(m, None)  # â˜… ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”

        msg = (f"[REMONITOR] {m} ë¶€ë¶„ ì²­ì‚° ì‹¤í–‰ {sell_ratio*100:.0f}% "
               f"(ì²´ê²° {executed:.6f}) ì”ì—¬ {remaining_volume:.6f}")
        print(msg)

        # ë¶€ë¶„ì²­ì‚° ê¸ˆì•¡ ê³„ì‚°
        partial_sell_krw = avg_sell_price * executed if avg_sell_price > 0 else 0.0

        tg_send(
            f"ğŸ¯ <b>ë¶€ë¶„ ì²­ì‚°</b> {m}\n"
            f"â€¢ ì‚¬ìœ : {reason or 'ë¶€ë¶„ì²­ì‚°'}\n"
            f"â€¢ ì²´ê²° ìˆ˜ëŸ‰: {executed:.6f}\n"
            f"â€¢ ì²´ê²° ê¸ˆì•¡: {partial_sell_krw:,.0f}ì›\n"
            f"â€¢ ì”ì—¬ ìˆ˜ëŸ‰: {remaining_volume:.6f}\n"
        )

        return True, msg, executed

    except Exception as e:
        msg = f"[PARTIAL_SELL_ERR] {m}: {e}"
        print(msg)
        return False, msg, 0.0

def remonitor_until_close(m, entry_price, pre, tight_mode=False):
    """
    ëì•ŒëŒ ì´í›„ ìë™ì²­ì‚° ì‹ í˜¸ê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ ëª¨ë‹ˆí„°ë§
    - ë¬´í•œ ë£¨í”„ ë°©ì§€: ë²½ì‹œê³„ ìƒí•œ + ì ì§„ ë°±ì˜¤í”„
    """
    CYCLE_SEC = 300
    MAX_WALL = 1800  # 30ë¶„ ìƒí•œ
    start_wall = time.time()
    backoff = 30
    cycle = 0

    while time.time() - start_wall < MAX_WALL:
        cycle += 1
        print(f"[REMONITOR] {m} {cycle}íšŒì°¨ ì¬ëª¨ë‹ˆí„°ë§ ì‹œì‘")

        verdict, action, rationale, ret_pct, last_price, maxrun, maxdd = \
            monitor_position(
                m, entry_price, pre,
                tight_mode=tight_mode,
                horizon=CYCLE_SEC,
                reentry=True
            )

        should_close = False
        reason = verdict or action or "ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ"

        if verdict and ("ê¸‰ë½" in verdict or "ì†ì ˆ" in verdict):
            should_close = True
        elif action and "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ " in action:
            should_close = True
        elif ret_pct is not None and ret_pct >= 2.5:
            should_close = True
            reason = f"ìˆ˜ìµì‹¤í˜„ {ret_pct:.2f}%"
        elif ret_pct is not None and ret_pct >= 1.5:
            ok, msg, executed = safe_partial_sell(
                m, sell_ratio=0.3, reason=f"ë¶€ë¶„ ìˆ˜ìµì‹¤í˜„ {ret_pct:.2f}%")
            if ok and executed > 0:
                print(msg)
            time.sleep(backoff)
            backoff = min(backoff + 30, 120)
            continue
        elif verdict and verdict.startswith("ì²­ì‚° ê¶Œê³ ("):
            time.sleep(backoff)
            backoff = min(backoff + 30, 120)
            continue
        elif action in ("ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ ", "ë¶€ë¶„ ì²­ì‚°(ë³¸ì ˆ)"):
            ok, msg, executed = safe_partial_sell(m, sell_ratio=0.5, reason="ëì•ŒëŒ ë¶€ë¶„ì²­ì‚° 50%")
            if ok and executed > 0:
                print(msg)
            time.sleep(backoff)
            backoff = min(backoff + 30, 120)
            continue
        elif action == "ìœ ì§€ ê¶Œê³ ":
            time.sleep(backoff)
            backoff = min(backoff + 30, 120)
            continue
        elif verdict == "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)":
            time.sleep(backoff)
            backoff = min(backoff + 30, 120)
            continue

        if should_close:
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m)
                if not pos or pos.get("closing"):
                    return False  # ì´ë¯¸ ì²­ì‚° ì¤‘/ì—†ìŒ
                pos["closing"] = True
                OPEN_POSITIONS[m] = pos

            print(f"[REMONITOR] {m} ìë™ì²­ì‚° ì¡°ê±´ ì¶©ì¡± â†’ ì²­ì‚° ({reason})")
            close_auto_position(m, reason)
            return True

        time.sleep(backoff)
        backoff = min(backoff + 30, 120)

    print(f"[REMONITOR] {m} íƒ€ì„ì•„ì›ƒ ì¢…ë£Œ (MAX_WALL={MAX_WALL}s)")
    return False

# =========================
# ì–¼ëŸ¿ ì •ì±…
# =========================
SILENT_MIDDLE_ALERTS = True


def tg_send_mid(t):
    if not SILENT_MIDDLE_ALERTS:
        return tg_send(t)
    else:
        print("[SILENT]", t)
        return True

def send_remonitor_alert(m, text):
    """
    ì¬ëª¨ë‹ˆí„°ë§ / ì»¨í…ìŠ¤íŠ¸ìš© ìš”ì•½ ì•ŒëŒ
    - í…”ë ˆê·¸ë¨ ê³¼ë‹¤ ë°©ì§€: TG ì „ì†¡ì€ ë¹„í™œì„±í™”, ì½˜ì†”ë§Œ ë‚¨ê¹€
    """
    now = time.time()
    last = REMONITOR_LAST_ALERT.get(m, 0)
    elapsed = now - last

    # 5ë¶„ ì´ë‚´ë©´ ì™„ì „íˆ ìŠ¤í‚µ (ì½˜ì†”ì—ë„ ì¶œë ¥í•˜ì§€ ì•ŠìŒ)
    if elapsed < REMONITOR_COOLDOWN_SEC:
        return

    REMONITOR_LAST_ALERT[m] = now
    print(f"[REMONITOR_INFO] {m} {text}")  # ì½˜ì†”ë§Œ ë‚¨ê¹€
    return  # TG ì „ì†¡ ë¹„í™œì„±í™”

# =========================
# í•„í„° íŒŒë¼ë¯¸í„° (Conservative-Balanced)
# =========================
# ê±°ë˜/ê°€ê²© ê¸°ë°˜
MIN_VOLUME_KRW = 450_000  # 400k -> 700k (í—ˆìˆ˜ ì €ê°)
MIN_RELATIVE_KRW_X = 1.08  # 1.18 -> 1.25 (ê³¼ê±°ëŒ€ë¹„ ì¦ê°€ìœ¨)

# í‹±/ì²´ê²° ê¸°ë°˜
TAPE_WINDOW_SEC = 15
MIN_TICKS_COUNT = 5  # 3 â†’ 5 (í—ˆìˆ˜í‹± íŒ¨ìŠ¤)
MIN_TURNOVER = 0.018
TICKS_BUY_RATIO = 0.58  # 0.56 â†’ 0.58 (ì´ˆì… í’ˆì§ˆ í–¥ìƒ)

# ìœ„í—˜ ê´€ë¦¬ (ìŠ¤í”„ë ˆë“œ)
MAX_SPREAD_BASE = 0.70  # ë‹¨ìœ„: %, 0.70 = 0.70% (ì¼ë°˜ ì‹ í˜¸)
MAX_SPREAD_FAST = 1.00  # ë‹¨ìœ„: %, 1.00 = 1.00% (ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ)
MIN_DEPTH_KRW = 12_000_000  # 6M â†’ 12M (ì–•ì€ í˜¸ê°€ ì»· ê°•í™”)

# í—ˆìˆ˜ ë°©ì–´
MIN_SUSTAINED_SECONDS = 120
MIN_REAL_TRADES = 10
MAX_FADE_RATIO = 0.70

# ì†ì ˆ/ëª¨ë‹ˆí„°ë§
STOP_LOSS_PCT = 0.008
RECHECK_SEC = 5
MONITOR_MAX = 180

# Ignition
IGN_BREAK_LOOKBACK = 12
IGN_MIN_BODY = 0.006
IGN_MIN_BUY = 0.60
# USE_5M_CONTEXTëŠ” ìƒë‹¨ ì „ì—­ ì„¤ì •(54ë¼ì¸)ì—ì„œ Falseë¡œ ì„¤ì •ë¨

# Bot-aware
BOT_PINGPONG_MAX_BAND = 0.0015
BOT_PINGPONG_MIN_ALT = 0.90
BOT_WASH_REPEAT_VOL_N = 5
BOT_TWAP_MAX_CV = 0.48
BOT_TWAP_MAX_PSTD = 0.0018
BOT_ACCUM_MIN_BUY = 0.54
BOT_ACCUM_MAX_BUY = 0.68
BOT_ACCUM_MIN_TURN = 0.030

# íŠ¸ë Œë“œ ê°€ë“œ
USE_TREND_GUARD = False

# Early Entry
USE_EARLY_ENTRY = True
EARLY_MIN_VWAP_GAP = 0.0005
EARLY_MIN_BUY = 0.50
EARLY_MIN_TURN = 0.012
EARLY_MIN_TICKS = 2
# EARLY_FLOW_MIN_KRWPSECëŠ” ìƒë‹¨ ì „ì—­ ì„¤ì •(56ë¼ì¸)ì—ì„œ 16,000ìœ¼ë¡œ ì„¤ì •ë¨
EARLY_MAX_VWAP_GAP = 0.018  # 1ë¶„ë´‰ê°€-VWAP ìµœëŒ€ ê´´ë¦¬ (1.8%) í—ˆìš©
EARLY_MAX_EMA5_GAP = 0.022

# í‹± ê¸°ë°˜ ì¡°ê¸° ë¸Œë ˆì´í¬
USE_TICK_BREAK = True
TICK_BREAK_GAP = 0.0020

# ì ì‘ì‹ ë³¼ë¥¨ ì„œì§€
ABS_SURGE_KRW = 2_000_000   # ì ˆëŒ€ ê±°ë˜ëŒ€ê¸ˆ ì„œì§€ ê¸°ì¤€ (2.0M KRW, ì¹œêµ¬ ì œì•ˆ: 2.2M â†’ 2.0M)
RELAXED_X = 1.08            # ê³¼ê±°ëŒ€ë¹„ ê±°ë˜ëŒ€ê¸ˆ ì™„í™” ë°°ìœ¨

# ì¿¨ë‹¤ìš´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤
REARM_MIN_SEC = 20  # 45 â†’ 20 (ì´ˆì™„í™”, ë¹ ë¥¸ ì¬ì‹œë„)
REARM_PRICE_GAP = 0.009
REARM_PULLBACK_MAX = 0.005  # 0.004 â†’ 0.005 (ë˜ëŒë¦¼ í›„ ì¬ì‹œë„ ì—¬ì§€â†‘)
REARM_REBREAK_MIN = 0.0012  # 0.0018 â†’ 0.0012 (ì¬ëŒíŒŒ ì¬ì•Œë¦¼ ë¬¸í„±â†“, ì´ˆì™„í™”)

# í¬ìŠ¤íŠ¸ì²´í¬(í—ˆìˆ˜ 2ì°¨)
# POSTCHECK_ENABLEDëŠ” ìƒë‹¨ ì „ì—­ ì„¤ì •(59ë¼ì¸)ì—ì„œ Trueë¡œ ì„¤ì •ë¨ (ì»¨íŒë§Œ ì ìš©, í”„ë¡œë¸ŒëŠ” íŒ¨ìŠ¤)
POSTCHECK_WINDOW_SEC = 3
POSTCHECK_MIN_BUY = 0.46  # 0.52 -> 0.54
POSTCHECK_MIN_RATE = 0.16  # 0.18 -> 0.26
POSTCHECK_MAX_PSTD = 0.0028  # 0.0028 -> 0.0022
POSTCHECK_MAX_CV = 0.72  # 0.70 -> 0.60
POSTCHECK_MAX_DD = 0.018

# ë™ì  ì†ì ˆ(ATR)
ATR_PERIOD = 14
ATR_EMA_PERIOD = 20
ATR_MULT = 0.85
DYN_SL_MIN = STOP_LOSS_PCT
DYN_SL_MAX = 0.022

# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ (ìš°íšŒ ì—„ê²©í™”)
ULTRA_RELAX_ON_MEGA = True
MEGA_BREAK_MIN_GAP = 0.022  # 1.2% -> 2.0%
MEGA_MIN_1M_CHG = 0.025  # 1.8% -> 2.8%
MEGA_VOL_Z = 2.8  # 2.2 -> 2.8
MEGA_ABS_KRW = 4_000_000  # 2.0M -> 4.0M

# =========================
# ì„¸ì…˜/ìš”ì²­(ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”)
# =========================
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter


def _new_session():
    s = requests.Session()
    retry = Retry(total=3,
                  backoff_factor=0.3,
                  status_forcelist=[429, 500, 502, 503, 504],
                  allowed_methods=frozenset(["GET", "POST"]))
    adapter = HTTPAdapter(pool_connections=256,
                          pool_maxsize=256,
                          max_retries=retry)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({
        "Connection": "keep-alive",
        "User-Agent": "UpbitSniper/3.2.7-hh+...+netRetry"
    })
    return s


SESSION = _new_session()
_session_lock = threading.Lock()   # âœ… ì„¸ì…˜ ì ‘ê·¼ ì „ìš© ë½ ì¶”ê°€
KST = timezone(timedelta(hours=9))

# === ëª¨ë‹ˆí„° ì‹¤í–‰ í’€ & ë™ì‹œì„± ì œí•œ ===
# (ì£¼ì˜) ThreadPoolExecutorëŠ” ì´ë¯¸ import ë˜ì–´ ìˆìŒ: from concurrent.futures import ThreadPoolExecutor, as_completed
MAX_CONCURRENT = int(os.getenv("MAX_CONCURRENT", "4"))          # ë™ì‹œì— ëª‡ ì¢…ëª© ëª¨ë‹ˆí„°ë§ í—ˆìš©
MAX_OPEN_POSITIONS = int(os.getenv("MAX_OPEN_POSITIONS", "7"))  # í”„ë¡œë¸Œ ë™ì‹œ ë³´ìœ  ìƒí•œ (3â†’7, ì–‘ì§ˆ ì‹ í˜¸ ê´€ë¦¬)

MONITOR_POOL = ThreadPoolExecutor(max_workers=MAX_CONCURRENT)   # ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ í’€
ACTIVE_MONITORS = {}    # { market: Future }
ACTIVE_MON_LOCK = threading.Lock()

LAST_PRE = {}           # { market: ë§ˆì§€ë§‰ pre íŒ¨í‚· } (ì›Œì¹˜ë…/ì¬ê¸°ë™ ì‹œ ì‚¬ìš© ì˜ˆì •)

def now_kst():
    return datetime.now(KST)

def now_kst_str():
    return now_kst().strftime("%Y-%m-%d %H:%M:%S KST")

# =========================
# ğŸ”¥ ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ê°„ê²©
# =========================
def get_scan_interval():
    """
    ì‹œê°„ëŒ€ë³„ ìŠ¤ìº” ì£¼ê¸°(ì´ˆ)
    - 09ì‹œëŒ€: 3ì´ˆ (ì´ˆë™ ë³€ë™ì„± ëŒ€ì‘)
    - 10~14ì‹œ: 5ì´ˆ
    - ê·¸ ì™¸: ê¸°ë³¸ 6ì´ˆ
    """
    h = now_kst().hour
    if h == 9:
        return 3
    elif 10 <= h <= 14:
        return 5
    else:
        return SCAN_INTERVAL  # ê¸°ë³¸ê°’(6ì´ˆ)

def link_for(m):
    return f"https://upbit.com/exchange?code=CRIX.UPBIT.{m}"


# í† í°ë²„í‚·
_BUCKET = {"tokens": 6.0, "last": time.time(), "cap": 6.0, "rate": 4.5}
_DEFAULT_BUCKET = {"cap": 6.0, "rate": 4.5}  # âœ… ì„±ê³µì‹œ íšŒë³µ ëª©í‘œì¹˜
_req_lock = threading.Lock()
REQ_STATS = {"ok": 0, "http429": 0, "http5xx": 0, "errors": 0, "conn_err": 0}
_CONSEC_CONN_ERR = 0


def _throttle():
    while True:
        with _req_lock:
            now = time.time()
            delta = now - _BUCKET["last"]
            _BUCKET["last"] = now
            rate = max(float(_BUCKET.get("rate", 0.0)), 0.1)
            cap = max(float(_BUCKET.get("cap", 1.0)), 1.0)
            tokens = min(cap, max(0.0, _BUCKET["tokens"] + delta * rate))
            if tokens >= 1.0:
                _BUCKET["tokens"] = tokens - 1.0
                return
            _BUCKET["tokens"] = tokens
            need = 1.0 - tokens
        base_wait = need / rate
        time.sleep(min(1.2, max(0.05, base_wait)) * (1.0 + 0.2 * rnd()))


def _refresh_session():
    global SESSION, _CONSEC_CONN_ERR
    with _session_lock:                     # âœ… êµì²´ ì¤‘ ë™ì‹œ ì ‘ê·¼ ì°¨ë‹¨
        try:
            SESSION.close()
        except Exception:
            pass
        SESSION = _new_session()
        _CONSEC_CONN_ERR = 0
        print("[NET] session refreshed")


def upbit_get(url, params=None, timeout=7):
    global _CONSEC_CONN_ERR
    for attempt in range(3):
        try:
            _throttle()
            # âœ… ì„¸ì…˜ ì ‘ê·¼ ì ê¸ˆ
            with _session_lock:
                r = SESSION.get(url, params=params, timeout=timeout)

            if r.status_code == 429:
                with _req_lock: REQ_STATS["http429"] += 1          # âœ… í†µê³„ ì ê¸ˆ
                backoff = min(1.2 * (2**attempt), 6.0)
                time.sleep(backoff)
                _BUCKET["rate"] = max(3.0, _BUCKET["rate"] - 0.4)
                _BUCKET["cap"]  = max(4.0, _BUCKET["cap"]  - 0.5)
                continue

            if 500 <= r.status_code < 600:
                with _req_lock: REQ_STATS["http5xx"] += 1          # âœ… í†µê³„ ì ê¸ˆ
                time.sleep(0.35 * (2**attempt))
                continue

            r.raise_for_status()
            with _req_lock: REQ_STATS["ok"] += 1                   # âœ… í†µê³„ ì ê¸ˆ
            _CONSEC_CONN_ERR = 0
            _BUCKET["rate"] = min(_DEFAULT_BUCKET["rate"], _BUCKET["rate"] + 0.05)
            _BUCKET["cap"]  = min(_DEFAULT_BUCKET["cap"],  _BUCKET["cap"]  + 0.10)
            return r.json()

        except requests.exceptions.Timeout:
            if attempt == 2: return None
            time.sleep(0.35 * (2**attempt))

        except requests.exceptions.ConnectionError:
            with _req_lock:
                REQ_STATS["errors"] += 1                           # âœ… í†µê³„ ì ê¸ˆ
                REQ_STATS["conn_err"] += 1
            _CONSEC_CONN_ERR += 1
            if _CONSEC_CONN_ERR >= 3:
                _refresh_session()
                time.sleep(0.6)
            else:
                time.sleep(0.4 * (2**attempt))
            if attempt == 2: return None

        except Exception:
            with _req_lock: REQ_STATS["errors"] += 1               # âœ… í†µê³„ ì ê¸ˆ
            if attempt == 2: return None
            time.sleep(0.2 * (2**attempt))
    return None

# =========================================================
# ğŸ§© ì•ˆì „ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ë˜í¼ (ìë™ ì¬ì‹œë„ + ë°±ì˜¤í”„)
# =========================================================
def safe_upbit_get(url, params=None, timeout=6, retries=3, backoff=1.5):
    """
    ì—…ë¹„íŠ¸ API ìš”ì²­ìš© ì•ˆì „ ë˜í¼
    - ì¼ì‹œì  ì—°ê²° ì‹¤íŒ¨ë‚˜ 429 ì‘ë‹µì—ë„ ìë™ ì¬ì‹œë„
    - 3íšŒê¹Œì§€ ì¬ì‹œë„ (1.5ì´ˆì”© ì¦ê°€í•˜ëŠ” ëŒ€ê¸°)
    """
    for i in range(retries):
        try:
            js = upbit_get(url, params, timeout=timeout)
            if js:
                return js
        except Exception as e:
            print(f"[SAFE_GET] {url.split('/')[-1]} ì‹¤íŒ¨ ({e}) â†’ ì¬ì‹œë„ {i+1}/{retries}")
        time.sleep(backoff * (i + 1))
    print(f"[SAFE_GET_FAIL] {url.split('/')[-1]} ìµœì¢… ì‹¤íŒ¨")
    return None

def req_summary():
    print(
        f"[REQ] ok:{REQ_STATS['ok']}  429:{REQ_STATS['http429']}  5xx:{REQ_STATS['http5xx']}  err:{REQ_STATS['errors']}"
    )


def aligned_sleep(interval):
    t = time.time()
    nxt = math.ceil(t / interval) * interval
    time.sleep(max(0, nxt - t))


# =========================
# ì§€í‘œ ìœ í‹¸
# =========================
def vwap_from_candles_1m(c1, n=20):
    seg = c1[-n:] if len(c1) >= n else c1[:]
    pv = sum(x["trade_price"] * x["candle_acc_trade_volume"] for x in seg)
    vol = sum(x["candle_acc_trade_volume"] for x in seg)
    return pv / max(vol, 1e-12)


def zscore_krw_1m(c1, win=30):
    seg = c1[-win:] if len(c1) >= win else c1[:]
    arr = [x["candle_acc_trade_price"] for x in seg]
    if len(arr) < 3: return 0.0
    m = sum(arr) / len(arr)
    sd = (sum((a - m)**2 for a in arr) / max(len(arr) - 1, 1))**0.5
    return (arr[-1] - m) / max(sd, 1e-9)


def uptick_streak_from_ticks(ticks, need=2):
    t = sorted(ticks[:need + 4], key=lambda x: x.get("timestamp", 0))
    return sum(1 for a, b in zip(t, t[1:])
               if b.get("trade_price", 0) > a.get("trade_price", 0)) >= need


def last_two_ticks_fresh(ticks, max_age=2.0):
    if len(ticks) < 2: return False
    h = now_kst().hour
    if 0 <= h < 6:
        max_age = max_age + 0.8
    now = int(time.time() * 1000)
    return all(
        (now - x.get("timestamp", 0)) / 1000.0 <= max_age for x in ticks[:2])


def body_ratio(c):
    try:
        return max((c["trade_price"] - c["opening_price"]) /
                   max(c["opening_price"], 1), 0)
    except:
        return 0


# ---- 5ë¶„ ì»¨í…ìŠ¤íŠ¸: LRU ìºì‹œ ----
class LRUCache:

    def __init__(self, maxsize=100):
        self.cache = OrderedDict()
        self.maxsize = maxsize
        self.lock = threading.Lock()

    def get(self, key):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
                return self.cache[key]
            return None

    def set(self, key, value):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.maxsize:
                self.cache.popitem(last=False)

    def clear(self):
        with self.lock:
            self.cache.clear()

    def purge_older_than(self, max_age_sec=3.0):
        cutoff = int(time.time() * 1000) - int(max_age_sec * 1000)
        with self.lock:
            drop = [
                k for k, v in self.cache.items()
                if isinstance(v, dict) and v.get("ts", 0) < cutoff
            ]
            for k in drop:
                self.cache.pop(k, None)


_TICKS_CACHE = LRUCache(maxsize=100)
_TICKS_TTL = 4.5
_C5_CACHE = LRUCache(maxsize=300)


def five_min_context_ok(m):
    if not USE_5M_CONTEXT:
        return True
    hit = _C5_CACHE.get(m)
    if hit and (time.time() - hit.get("ts", 0) <= 3.0):
        c5 = hit["c"]
    else:
        c5 = get_minutes_candles(5, m, 6)
        _C5_CACHE.set(m, {"ts": time.time(), "c": c5})
    if len(c5) < 4:
        return True
    try:
        close = [c["trade_price"] for c in c5]
        slope3 = close[-1] - close[-3]
        recent_break = c5[-1]["high_price"] > max(x["high_price"]
                                                  for x in c5[-4:-1])
        return (slope3 > 0) or recent_break
    except:
        return True

def get_dynamic_thresholds():
    h = now_kst().hour
    if 0 <= h < 6:
        return {
            "zscore": 0.90,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0008,
            "uptick": 2,
            "min_change": 0.0004,  # ê¸°ì¡´ 0.0005
            "bidask_min": 1.06
        }
    elif 6 <= h < 12:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0006,  # ê¸°ì¡´ 0.0007
            "bidask_min": 1.07
        }
    elif 12 <= h < 18:
        return {
            "zscore": 0.95,   # ê¸°ì¡´ 1.0
            "vwap_gap": 0.0009,    # ê¸°ì¡´ 0.0010
            "uptick": 2,
            "min_change": 0.0008,  # ê¸°ì¡´ 0.0010
            "bidask_min": 1.075    # ì‚´ì§ ì™„í™”
        }
    else:
        return {
            "zscore": 0.92,   # ê¸°ì¡´ 0.95
            "vwap_gap": 0.0009,
            "uptick": 2,
            "min_change": 0.0007,
            "bidask_min": 1.07
        }

# =========================
# â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
# =========================
def relax_knob():
    """
    0.0 ~ 1.5 ìŠ¤ì¼€ì¼.
    + BTC 5ë¶„ ìˆ˜ìµ > 0.6%ë©´ +1.0, > 0.3%ë©´ +0.5
    + ì•¼ê°„(00~06h)ë©´ +0.5
    """
    try:
        b5 = btc_5m_change()
    except:
        b5 = 0.0
    h = now_kst().hour
    f = 0.0
    if b5 >= 0.006: f += 1.0
    elif b5 >= 0.003: f += 0.5
    if 0 <= h < 6: f += 0.5
    return min(1.5, f)


# =========================
# ë°ì´í„° ìˆ˜ì§‘/ìºì‹œ
# =========================
MKTS_CACHE_TTL = 30  # ìˆ˜ì§ ëŸ¬ë„ˆ ë¹ ë¥¸ í¬ì°© (90â†’30ì´ˆ)
_MKTS_CACHE = {"ts": 0.0, "mkts": []}


def get_top_krw_by_24h(n=TOP_N):
    now = time.time()
    if _MKTS_CACHE["mkts"] and (now - _MKTS_CACHE["ts"] <= MKTS_CACHE_TTL):
        mkts = _MKTS_CACHE["mkts"]
    else:
        allm = [
            d["market"]
            for d in upbit_get("https://api.upbit.com/v1/market/all") or []
            if d["market"].startswith("KRW-")
        ]
        acc = []
        for i in range(0, len(allm), 50):
            info = upbit_get("https://api.upbit.com/v1/ticker",
                             {"markets": ",".join(allm[i:i + 50])})
            if not info: continue
            for t in info:
                v = t.get("acc_trade_price_24h", 0)
                if v > 0: acc.append((t["market"], v))
        acc.sort(key=lambda x: x[1], reverse=True)
        mkts = [m for m, _ in acc]
        _MKTS_CACHE["mkts"] = mkts
        _MKTS_CACHE["ts"] = now
    return mkts[:n]


def get_minutes_candles(u, m, c):
    js = upbit_get(f"https://api.upbit.com/v1/candles/minutes/{u}", {
        "market": m,
        "count": c
    },
                   timeout=6)
    return list(reversed(js)) if js else []

def get_recent_ticks(m, c=100, allow_network=True):
    now_ms = int(time.time() * 1000)
    hit = _TICKS_CACHE.get(m)
    if hit and (now_ms - hit["ts"] <= _TICKS_TTL * 1000):
        return hit["ticks"]
    if not allow_network:
        return hit["ticks"] if hit else []

    # âœ… ì•ˆì „ ë˜í¼ë¡œ ë³€ê²½
    js = safe_upbit_get("https://api.upbit.com/v1/trades/ticks", {
        "market": m,
        "count": c
    },
                        timeout=6)

    if not js or not isinstance(js, list):
        return hit["ticks"] if hit else []
    js_sorted = sorted(js, key=lambda t: t.get("timestamp", 0), reverse=True)
    _TICKS_CACHE.set(m, {"ts": now_ms, "ticks": js_sorted})
    return js_sorted

def micro_tape_stats_from_ticks(ticks, sec):
    if not ticks:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }
    try:
        newest_ts = ticks[0]["timestamp"]
        cutoff = newest_ts - sec * 1000
    except:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    n = 0
    krw = 0.0
    buys = 0
    oldest_ts = newest_ts
    for x in ticks:
        ts = x.get("timestamp", 0)
        if ts < cutoff:
            break
        p = x.get("trade_price", 0.0)
        v = x.get("trade_volume", 0.0)
        krw += p * v
        n += 1
        if x.get("ask_bid") == "BID": buys += 1
        if ts < oldest_ts: oldest_ts = ts

    if n == 0:
        return {
            "krw": 0,
            "n": 0,
            "buy_ratio": 0,
            "age": 999,
            "rate": 0,
            "krw_per_sec": 0
        }

    now_ms = int(time.time() * 1000)
    age = (now_ms - newest_ts) / 1000.0 if newest_ts else 999
    duration = max((newest_ts - (oldest_ts or newest_ts)) / 1000.0, 1.0)
    rate = n / duration
    krw_per_sec = krw / duration
    return {
        "krw": krw,
        "n": n,
        "buy_ratio": buys / n,
        "age": age,
        "rate": rate,
        "krw_per_sec": krw_per_sec
    }


# ===== Bot Heuristics =====
def _pct(a, b):
    try:
        return abs(a / b - 1.0)
    except:
        return 0.0


def inter_arrival_stats(ticks, sec=30):
    if not ticks: return {"cv": 9.9, "count": 0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"cv": 9.9, "count": 0}
    cutoff = newest_ts - sec * 1000
    ts = [x["timestamp"] for x in ticks if x["timestamp"] >= cutoff]
    ts = sorted(ts)
    if len(ts) < 4: return {"cv": 9.9, "count": len(ts)}
    gaps = [(b - a) / 1000.0 for a, b in zip(ts, ts[1:])]
    mu = sum(gaps) / len(gaps)
    if mu <= 0: return {"cv": 9.9, "count": len(ts)}
    var = sum((g - mu)**2 for g in gaps) / len(gaps)
    cv = (var**0.5) / mu
    return {"cv": cv, "count": len(ts)}


def price_band_std(ticks, sec=30):
    if not ticks: return 9.9
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 9.9
    cutoff = newest_ts - sec * 1000
    ps = [x["trade_price"] for x in ticks if x["timestamp"] >= cutoff]
    if len(ps) < 3: return 9.9
    m = sum(ps) / len(ps)
    var = sum((p - m)**2 for p in ps) / len(ps)
    std = (var**0.5) / max(m, 1)
    return std


def bot_pingpong_score(ticks, sec=20, band=BOT_PINGPONG_MAX_BAND):
    if not ticks: return 0.0
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return 0.0
    cutoff = newest_ts - sec * 1000
    win = [x for x in reversed(ticks) if x["timestamp"] >= cutoff]
    if len(win) < 6: return 0.0
    prices = [x["trade_price"] for x in win]
    pr_min, pr_max = min(prices), max(prices)
    if _pct(pr_max, pr_min) > band:
        return 0.0
    alt = sum(1 for a, b in zip(win, win[1:])
              if a["ask_bid"] != b["ask_bid"]) / max(len(win) - 1, 1)
    return alt


def wash_trade_pattern(ticks, sec=30, repeats=BOT_WASH_REPEAT_VOL_N):
    if not ticks: return False
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return False
    cutoff = newest_ts - sec * 1000
    vols = {}
    for x in ticks:
        if x["timestamp"] < cutoff: break
        v = round(x["trade_volume"], 6)
        vols[v] = vols.get(v, 0) + 1
    if not vols: return False
    top = max(vols.values())
    return top >= repeats


def bot_accum_trigger_ok(m, ticks, ob, c1):
    if not ticks or not ob or not c1: return (False, "BOTACC_INIT_FAIL")
    t30 = micro_tape_stats_from_ticks(ticks, 30)
    if not (BOT_ACCUM_MIN_BUY <= t30["buy_ratio"] <= BOT_ACCUM_MAX_BUY):
        return (False, "BOTACC_BUY_RANGE")
    ia = inter_arrival_stats(ticks, 30)
    if ia["cv"] > BOT_TWAP_MAX_CV or ia["count"] < 6:
        return (False, "BOTACC_CV_LOWCOUNT")
    if price_band_std(ticks, 30) > BOT_TWAP_MAX_PSTD:
        return (False, "BOTACC_PSTD")
    if not uptick_streak_from_ticks(ticks, need=2):
        return (False, "BOTACC_NO_UPTICK")
    raw_units = (ob.get("raw") or {}).get("orderbook_units") or []
    if not raw_units:
        return (False, "BOTACC_OB_EMPTY")  # ì˜¤ë”ë¶ ìœ ë‹› ì—†ìŒ â†’ ì¦‰ì‹œ ì»·

    raw = raw_units[:3]
    bid = sum(u.get("bid_price", 0) * u.get("bid_size", 0) for u in raw)
    ask = sum(u.get("ask_price", 0) * u.get("ask_size", 0) for u in raw)
    if bid / max(ask, 1) < 1.10:
        return (False, "BOTACC_BIDASK_WEAK")

    cur = c1[-1]
    if cur["trade_price"] <= cur["opening_price"]:
        return (False, "BOTACC_NOT_GREEN")
    return (True, "BOTACC_OK")


def _win_stats(ticks, start_s, end_s):
    if not ticks:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    try:
        newest_ts = ticks[0]["timestamp"]
    except:
        return {"n": 0, "buy_ratio": 0.0, "rate": 0.0, "krw_per_sec": 0.0}
    lo = newest_ts - end_s * 1000
    hi = newest_ts - start_s * 1000
    win = [x for x in ticks if lo <= x.get("timestamp", 0) <= hi]
    if len(win) < 2:
        return {
            "n": len(win),
            "buy_ratio": 0.0,
            "rate": 0.0,
            "krw_per_sec": 0.0
        }
    win = sorted(win, key=lambda t: t["timestamp"])
    dur = max((win[-1]["timestamp"] - win[0]["timestamp"]) / 1000.0, 1.0)
    buys = sum(1 for x in win if x.get("ask_bid") == "BID")
    krw = sum(x["trade_price"] * x["trade_volume"] for x in win)
    return {
        "n": len(win),
        "buy_ratio": buys / max(len(win), 1),
        "rate": len(win) / dur,
        "krw_per_sec": krw / dur
    }


def buy_decay_flag(ticks):
    early = _win_stats(ticks, start_s=10, end_s=20)
    now = _win_stats(ticks, start_s=0, end_s=5)
    if early["n"] < 4 or now["n"] < 2:
        return False, {"early": early, "now": now}
    drop_buy = early["buy_ratio"] - now["buy_ratio"]
    cond = (drop_buy >= 0.12 and now["rate"] <= early["rate"] * 0.80
            and now["krw_per_sec"] <= early["krw_per_sec"] * 0.70)
    return cond, {"early": early, "now": now, "drop_buy": drop_buy}


# =========================
# ì‹œì¥ í•„í„°
# =========================
def btc_5m_change():
    c = get_minutes_candles(5, "KRW-BTC", 3)
    if len(c) < 2: return 0.0
    return c[-1]["trade_price"] / max(c[-2]["trade_price"], 1) - 1

# =========================
# ë³´ì¡°: ìº”ë“¤/ATR/EMA
# =========================
def wick_body_ratio(c):
    try:
        rng = c["high_price"] - c["low_price"]
        body = abs(c["trade_price"] - c["opening_price"])
        if rng <= 0: return 1.0
        return body / rng
    except:
        return 1.0


def ema_series(vals, period):
    if not vals: return []
    k = 2 / (period + 1)
    out = []
    ema = vals[0]
    for v in vals:
        ema = v * k + ema * (1 - k)
        out.append(ema)
    return out


def ema_last(vals, period):
    if len(vals) == 0: return None
    return ema_series(vals, period)[-1]


def avg_past_volume(candles, n=5, field="candle_acc_trade_volume"):
    """ìµœê·¼ Nê°œ ìº”ë“¤ì˜ í‰ê·  ê±°ë˜ëŸ‰/ê¸ˆì•¡ ê³„ì‚° (í˜„ì¬ ìº”ë“¤ ì œì™¸)
    Args:
        candles: ìº”ë“¤ ë¦¬ìŠ¤íŠ¸
        n: í‰ê·  ê³„ì‚°í•  ìº”ë“¤ ìˆ˜
        field: ì§‘ê³„ í•„ë“œ (candle_acc_trade_volume ë˜ëŠ” candle_acc_trade_price)
    Returns:
        í‰ê· ê°’ ë˜ëŠ” 0
    """
    if not candles or len(candles) < n + 1:
        return 0
    # ìµœê·¼ n+1ê°œ ì¤‘ ë§ˆì§€ë§‰(í˜„ì¬) ì œì™¸í•˜ê³  nê°œë§Œ ì‚¬ìš©
    past = [c.get(field, 0) for c in candles[-(n+1):-1] if c.get(field, 0) > 0]
    return statistics.mean(past) if past else 0


def atr14_from_candles(candles, period=14):
    if len(candles) < period + 1:
        return None
    trs = []
    for i in range(1, len(candles)):
        h = candles[i]["high_price"]
        l = candles[i]["low_price"]
        pc = candles[i - 1]["trade_price"]
        tr = max(h - l, abs(h - pc), abs(l - pc))
        trs.append(tr)
    return sum(trs[-period:]) / period if len(trs) >= period else None


# =========================
# â˜… í”„ë¡œë¸Œ 2.0ìš© ì§€í‘œ í•¨ìˆ˜ë“¤
# =========================
def bollinger_bands(candles, period=20, std_mult=2.0):
    """ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚°
    Returns: (middle, upper, lower, bandwidth) ë˜ëŠ” None
    """
    if len(candles) < period:
        return None
    closes = [c["trade_price"] for c in candles[-period:]]
    middle = sum(closes) / period
    variance = sum((c - middle) ** 2 for c in closes) / period
    std = variance ** 0.5
    upper = middle + std * std_mult
    lower = middle - std * std_mult
    bandwidth = (upper - lower) / middle if middle > 0 else 0
    return {"middle": middle, "upper": upper, "lower": lower, "bandwidth": bandwidth}


def adx_di(candles, period=14):
    """ADX, +DI, -DI ê³„ì‚°
    Returns: {"adx": float, "plus_di": float, "minus_di": float} ë˜ëŠ” None
    """
    if len(candles) < period + 1:
        return None

    plus_dm_list = []
    minus_dm_list = []
    tr_list = []

    for i in range(1, len(candles)):
        h = candles[i]["high_price"]
        l = candles[i]["low_price"]
        ph = candles[i-1]["high_price"]
        pl = candles[i-1]["low_price"]
        pc = candles[i-1]["trade_price"]

        plus_dm = max(h - ph, 0)
        minus_dm = max(pl - l, 0)
        if plus_dm > minus_dm:
            minus_dm = 0
        elif minus_dm > plus_dm:
            plus_dm = 0

        tr = max(h - l, abs(h - pc), abs(l - pc))
        plus_dm_list.append(plus_dm)
        minus_dm_list.append(minus_dm)
        tr_list.append(tr)

    if len(tr_list) < period:
        return None

    # Smoothed averages
    smooth_plus_dm = sum(plus_dm_list[-period:]) / period
    smooth_minus_dm = sum(minus_dm_list[-period:]) / period
    smooth_tr = sum(tr_list[-period:]) / period

    if smooth_tr == 0:
        return None

    plus_di = 100 * smooth_plus_dm / smooth_tr
    minus_di = 100 * smooth_minus_dm / smooth_tr

    dx = 100 * abs(plus_di - minus_di) / max(plus_di + minus_di, 0.01)
    adx = dx  # ê°„ë‹¨í™”: ì‹¤ì œë¡œëŠ” DXì˜ í‰ê· ì´ì§€ë§Œ ì—¬ê¸°ì„œëŠ” ê·¼ì‚¬ê°’ ì‚¬ìš©

    return {"adx": adx, "plus_di": plus_di, "minus_di": minus_di}


def parabolic_sar(candles, af_start=0.02, af_increment=0.02, af_max=0.2):
    """Parabolic SAR ê³„ì‚° (ê°„ë‹¨ ë²„ì „)
    Returns: {"sar": float, "is_uptrend": bool} ë˜ëŠ” None
    """
    if len(candles) < 3:
        return None

    # ê°„ë‹¨ êµ¬í˜„: ìµœê·¼ ì¶”ì„¸ ê¸°ë°˜
    last3 = candles[-3:]
    closes = [c["trade_price"] for c in last3]
    highs = [c["high_price"] for c in last3]
    lows = [c["low_price"] for c in last3]

    is_uptrend = closes[-1] > closes[0]

    if is_uptrend:
        sar = min(lows)
    else:
        sar = max(highs)

    return {"sar": sar, "is_uptrend": is_uptrend}


def obv_from_candles(candles):
    """On-Balance Volume ê³„ì‚°
    Returns: OBV ê°’ ë˜ëŠ” None
    """
    if len(candles) < 2:
        return None

    obv = 0
    for i in range(1, len(candles)):
        vol = candles[i]["candle_acc_trade_volume"]
        close = candles[i]["trade_price"]
        prev_close = candles[i-1]["trade_price"]

        if close > prev_close:
            obv += vol
        elif close < prev_close:
            obv -= vol

    return obv


def macd_histogram(candles, fast=12, slow=26, signal=9):
    """MACD íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
    Returns: {"macd": float, "signal": float, "histogram": float} ë˜ëŠ” None
    """
    if len(candles) < slow + signal:
        return None

    closes = [c["trade_price"] for c in candles]

    ema_fast = ema_last(closes, fast)
    ema_slow = ema_last(closes, slow)

    if ema_fast is None or ema_slow is None:
        return None

    macd = ema_fast - ema_slow

    # Signal line (MACDì˜ EMA)
    # ê°„ë‹¨í™”: ìµœê·¼ signalê°œ MACD ê°’ì˜ í‰ê·  ì‚¬ìš©
    macd_values = []
    for i in range(max(0, len(closes) - signal), len(closes)):
        ef = ema_last(closes[:i+1], fast)
        es = ema_last(closes[:i+1], slow)
        if ef and es:
            macd_values.append(ef - es)

    if not macd_values:
        return None

    signal_line = sum(macd_values) / len(macd_values)
    histogram = macd - signal_line

    return {"macd": macd, "signal": signal_line, "histogram": histogram}


def stochastic_rsi(candles, rsi_period=14, stoch_period=14, smooth_k=3, smooth_d=3):
    """ìŠ¤í† ìºìŠ¤í‹± RSI ê³„ì‚° (RSI ì‹œê³„ì—´ ê¸°ë°˜)
    Returns: {"k": float, "d": float} ë˜ëŠ” None (0~100 ë²”ìœ„)
    """
    closes = [c["trade_price"] for c in candles]
    if len(closes) < rsi_period + stoch_period + smooth_d:
        return None

    # â˜… RSI ì‹œê³„ì—´ ìƒì„± (ë‹¨ì¼ ê°’ì´ ì•„ë‹Œ ì‹œë¦¬ì¦ˆ)
    gains, losses = [0], [0]
    for i in range(1, len(closes)):
        ch = closes[i] - closes[i-1]
        gains.append(max(ch, 0))
        losses.append(max(-ch, 0))

    rsi_vals = []
    avg_g = sum(gains[1:rsi_period+1]) / rsi_period
    avg_l = sum(losses[1:rsi_period+1]) / rsi_period
    rsi_vals.append(100 if avg_l == 0 else 100 - 100/(1 + avg_g/max(avg_l, 1e-12)))

    for i in range(rsi_period+1, len(closes)):
        avg_g = (avg_g*(rsi_period-1) + gains[i]) / rsi_period
        avg_l = (avg_l*(rsi_period-1) + losses[i]) / rsi_period
        rsi_vals.append(100 if avg_l == 0 else 100 - 100/(1 + avg_g/max(avg_l, 1e-12)))

    # â˜… Stochastic on RSI ì‹œê³„ì—´
    stoch_src = rsi_vals[-(stoch_period + smooth_k + smooth_d):]
    if len(stoch_src) < stoch_period + smooth_k + smooth_d:
        return None

    k_raw = []
    for i in range(stoch_period, len(stoch_src)+1):
        win = stoch_src[i-stoch_period:i]
        hi, lo = max(win), min(win)
        k_raw.append(50 if hi == lo else 100*(win[-1]-lo)/max(hi-lo, 1e-12))

    def sma(a, n):
        return [sum(a[i-n:i])/n for i in range(n, len(a)+1)]

    k = sma(k_raw, smooth_k)[-1]
    d = sma(sma(k_raw, smooth_k), smooth_d)[-1]

    return {"k": k, "d": d}


# =========================
# â˜… í”„ë¡œë¸Œ 2.0 í•µì‹¬ ë¡œì§
# =========================
def probe_v2_prefilter(candles, orderbook):
    """ê³µí†µ ì„ í•„í„°: ë„ˆë¬´ ì•ˆ ì¢‹ì€ ê±´ ë°°ì œ
    - RVOL >= 1.5
    - ìŠ¤í”„ë ˆë“œ <= 0.2%
    - EMA 5,10,20 ì¤‘ ìµœì†Œ 2ê°œ ìƒìŠ¹
    """
    if len(candles) < 30 or not orderbook:
        return False

    # 1) RVOL ê³„ì‚° (ìµœê·¼ ê±°ë˜ëŸ‰ / 30ë´‰ í‰ê· )
    volumes = [c["candle_acc_trade_volume"] for c in candles[-30:]]
    avg_volume = sum(volumes) / 30
    current_volume = candles[-1]["candle_acc_trade_volume"]
    rvol = current_volume / max(avg_volume, 1)

    if rvol < PROBE_V2_PREFILTER_RVOL:
        return False

    # 2) ìŠ¤í”„ë ˆë“œ ì²´í¬ (fetch_orderbook_cache êµ¬ì¡°: {'spread', 'depth_krw', 'raw'})
    # spreadëŠ” ì´ë¯¸ %ë¡œ ì €ì¥ë¨
    spread_pct = orderbook.get("spread", 999)
    if spread_pct > (PROBE_V2_PREFILTER_SPREAD * 100):  # 0.002 â†’ 0.2%
        return False

    # bid/ask í™•ì¸ (optional, rawì—ì„œ)
    raw_units = (orderbook.get("raw") or {}).get("orderbook_units") or []
    if not raw_units:
        return False
    bid = raw_units[0].get("bid_price", 0)
    ask = raw_units[0].get("ask_price", 0)
    if not (bid and ask):
        return False

    # 3) EMA ê¸°ìš¸ê¸° (5, 10, 20)
    closes = [c["trade_price"] for c in candles]
    ema5 = ema_series(closes, 5)
    ema10 = ema_series(closes, 10)
    ema20 = ema_series(closes, 20)

    if len(ema5) < 6 or len(ema10) < 6 or len(ema20) < 6:
        return False

    # ê¸°ìš¸ê¸° ì²´í¬ (ìµœê·¼ 3ë´‰ í‰ê·  > ì´ì „ 3ë´‰ í‰ê· )
    ema5_up = sum(ema5[-3:]) / 3 > sum(ema5[-6:-3]) / 3
    ema10_up = sum(ema10[-3:]) / 3 > sum(ema10[-6:-3]) / 3
    ema20_up = sum(ema20[-3:]) / 3 > sum(ema20[-6:-3]) / 3

    ema_up_count = sum([ema5_up, ema10_up, ema20_up])

    if ema_up_count < PROBE_V2_PREFILTER_EMA_UP:
        return False

    return True


def probe_v2_trigger_breakout(candles):
    """A. ëŒíŒŒí˜• íŠ¸ë¦¬ê±° (BB ê¸‰í™•ì¥)
    - BBí­ì´ ì§ì „ 5ë´‰ ëŒ€ë¹„ +40% ì´ìƒ í™•ëŒ€
    - ì¢…ê°€ê°€ Upper BB ìœ„ë¡œ 0.25 ATR ì´ìƒ ëŒíŒŒ
    - ë‹¹ë´‰ ê±°ë˜ëŸ‰ >= 2Ã—(20ë´‰ í‰ê· )
    """
    if len(candles) < 25:
        return False

    # í˜„ì¬ BB
    bb_now = bollinger_bands(candles, period=20)
    if not bb_now:
        return False

    # 5ë´‰ ì „ BB
    bb_prev = bollinger_bands(candles[:-5], period=20)
    if not bb_prev:
        return False

    # BBí­ í™•ëŒ€ ì²´í¬
    bandwidth_expansion = (bb_now["bandwidth"] / max(bb_prev["bandwidth"], 0.001)) - 1
    if bandwidth_expansion < 0.40:  # +40%
        return False

    # ATR ê³„ì‚°
    atr = atr14_from_candles(candles, 14)
    if not atr:
        return False

    # ì¢…ê°€ê°€ Upper BB + 0.25 ATR ì´ìƒ ëŒíŒŒ
    close = candles[-1]["trade_price"]
    upper_bb = bb_now["upper"]
    if close < upper_bb + (0.25 * atr):
        return False

    # ê±°ë˜ëŸ‰ ì²´í¬
    volumes = [c["candle_acc_trade_volume"] for c in candles[-20:]]
    avg_volume = sum(volumes[:-1]) / 19
    current_volume = candles[-1]["candle_acc_trade_volume"]

    if current_volume < 2.0 * avg_volume:
        return False

    return True


def probe_v2_trigger_momentum(candles):
    """B. ëª¨ë©˜í…€ ë²ˆ íŠ¸ë¦¬ê±°
    - %K > %D, ë‘˜ ë‹¤ 80â†‘ (ìŠ¤í† ìºìŠ¤í‹± RSI)
    - PSAR ìƒí–¥ ì „í™˜ (ì ì´ ìº”ë“¤ ì•„ë˜)
    - ì§ì „ ê³ ì  ëŒíŒŒ ë˜ëŠ” ê³ ê°€-ì €ê°€ >= 1.2 ATR
    """
    if len(candles) < 20:
        return False

    # ìŠ¤í† ìºìŠ¤í‹± RSI
    stoch = stochastic_rsi(candles, rsi_period=14, stoch_period=14)
    if not stoch:
        return False

    if not (stoch["k"] > stoch["d"] and stoch["k"] >= 80 and stoch["d"] >= 80):
        return False

    # PSAR
    psar = parabolic_sar(candles)
    if not psar:
        return False

    if not psar["is_uptrend"]:
        return False

    # SARì´ ìº”ë“¤ ì•„ë˜ì— ìˆëŠ”ì§€ í™•ì¸
    current_close = candles[-1]["trade_price"]
    if psar["sar"] >= current_close:
        return False

    # ATR
    atr = atr14_from_candles(candles, 14)
    if not atr:
        return False

    # ì§ì „ ê³ ì  ëŒíŒŒ or ê³ ê°€-ì €ê°€ >= 1.2 ATR
    current_high = candles[-1]["high_price"]
    current_low = candles[-1]["low_price"]
    prev_highs = [c["high_price"] for c in candles[-10:-1]]
    max_prev_high = max(prev_highs) if prev_highs else 0

    condition1 = current_high > max_prev_high
    condition2 = (current_high - current_low) >= 1.2 * atr

    if not (condition1 or condition2):
        return False

    return True


def probe_v2_trigger_trend(candles):
    """C. ì¶”ì„¸ì‹œë™ íŠ¸ë¦¬ê±° (ê·¸ë¼ì¸ë“œ)
    - EMA ì •ë ¬ 5>10>20 & ì„¸ EMA ê¸°ìš¸ê¸° ëª¨ë‘ ì–‘(+)
    - ADX >= 18 & +DI - -DI >= 5
    - OBV 30ë´‰ ì‹ ê³ ì 
    """
    if len(candles) < 30:
        return False

    # EMA ì •ë ¬ ë° ê¸°ìš¸ê¸°
    closes = [c["trade_price"] for c in candles]
    ema5 = ema_series(closes, 5)
    ema10 = ema_series(closes, 10)
    ema20 = ema_series(closes, 20)

    if len(ema5) < 3 or len(ema10) < 3 or len(ema20) < 3:
        return False

    # ì •ë ¬: 5 > 10 > 20
    if not (ema5[-1] > ema10[-1] > ema20[-1]):
        return False

    # ê¸°ìš¸ê¸°: ëª¨ë‘ ì–‘(+)
    ema5_slope = ema5[-1] - ema5[-3]
    ema10_slope = ema10[-1] - ema10[-3]
    ema20_slope = ema20[-1] - ema20[-3]

    if not (ema5_slope > 0 and ema10_slope > 0 and ema20_slope > 0):
        return False

    # ADX & DI
    adx_result = adx_di(candles, period=14)
    if not adx_result:
        return False

    if not (adx_result["adx"] >= 18 and
            (adx_result["plus_di"] - adx_result["minus_di"]) >= 5):
        return False

    # OBV ì‹ ê³ ì 
    obv_current = obv_from_candles(candles[-30:])
    if obv_current is None:
        return False

    # ê°„ë‹¨ ì²´í¬: ìµœê·¼ OBVê°€ ì¦ê°€ ì¶”ì„¸ì¸ì§€
    obv_prev = obv_from_candles(candles[-30:-1])
    if obv_prev is None:
        return False

    if obv_current <= obv_prev:
        return False

    return True


def probe_v2_update_score(market, candles):
    """í”„ë¡œë¸Œ ì ìˆ˜ ì—…ë°ì´íŠ¸ (1ë¶„ë´‰ë§ˆë‹¤ í˜¸ì¶œ)
    +2: ì¢…ê°€ê°€ 5EMA ìœ„ & ì „ê³  ëŒíŒŒ
    +2: ADX ìƒìŠ¹(Î”ADX >= +1.5) & +DI > -DI
    +2: RVOL >= 2.0 ìœ ì§€
    +1: MACD íˆìŠ¤í† ê·¸ë¨ ì¦ê°€
    +1: Upper BB ê±°ë¦¬ ì¦ê°€
    -2: ì¢…ê°€ê°€ 10EMA í•˜íšŒ
    -3: RVOL < 1.0ë¡œ ê¸‰ê°
    -3: ê°•í•œ ìŒë´‰ (ëª¸í†µ >= 0.7ATR) + ìƒë‹¨ ê¼¬ë¦¬
    """
    with _PROBE_V2_LOCK:
        if market not in PROBE_V2_STATES:
            return 0

        state = PROBE_V2_STATES[market]
        score_delta = 0

    if len(candles) < 30:
        return 0

    current = candles[-1]
    prev = candles[-2] if len(candles) >= 2 else current

    closes = [c["trade_price"] for c in candles]
    current_close = current["trade_price"]

    # 1) ì¢…ê°€ê°€ 5EMA ìœ„ & ì „ê³  ëŒíŒŒ
    ema5 = ema_last(closes, 5)
    if ema5:
        highs = [c["high_price"] for c in candles[-10:-1]]
        max_prev_high = max(highs) if highs else 0
        if current_close > ema5 and current["high_price"] > max_prev_high:
            score_delta += 2

    # 2) ADX ìƒìŠ¹ & +DI > -DI
    adx_now = adx_di(candles, period=14)
    adx_prev = adx_di(candles[:-1], period=14) if len(candles) > 15 else None

    if adx_now and adx_prev:
        adx_delta = adx_now["adx"] - adx_prev["adx"]
        if adx_delta >= 1.5 and adx_now["plus_di"] > adx_now["minus_di"]:
            score_delta += 2

    # 3) RVOL >= 2.0 ìœ ì§€
    volumes = [c["candle_acc_trade_volume"] for c in candles[-30:]]
    avg_volume = sum(volumes[:-1]) / 29 if len(volumes) > 1 else 1
    current_volume = current["candle_acc_trade_volume"]
    rvol = current_volume / max(avg_volume, 1)

    if rvol >= 2.0:
        score_delta += 2

    # 4) MACD íˆìŠ¤í† ê·¸ë¨ ì¦ê°€
    macd_now = macd_histogram(candles)
    macd_prev = macd_histogram(candles[:-1]) if len(candles) > 30 else None

    if macd_now and macd_prev:
        if macd_now["histogram"] > macd_prev["histogram"]:
            score_delta += 1

    # 5) Upper BB ê±°ë¦¬ ì¦ê°€
    bb_now = bollinger_bands(candles, period=20)
    bb_prev = bollinger_bands(candles[:-1], period=20) if len(candles) > 20 else None

    if bb_now and bb_prev:
        dist_now = bb_now["upper"] - current_close
        prev_close = prev["trade_price"]
        dist_prev = bb_prev["upper"] - prev_close
        if dist_now > dist_prev:
            score_delta += 1

    # 6) ì¢…ê°€ê°€ 10EMA í•˜íšŒ
    ema10 = ema_last(closes, 10)
    if ema10 and current_close < ema10:
        score_delta -= 2

    # 7) RVOL < 1.0 ê¸‰ê°
    if rvol < 1.0:
        score_delta -= 3

    # 8) ê°•í•œ ìŒë´‰ + ìƒë‹¨ ê¼¬ë¦¬
    atr = atr14_from_candles(candles, 14)
    if atr:
        body = abs(current["trade_price"] - current["opening_price"])
        is_red = current["trade_price"] < current["opening_price"]
        upper_wick = current["high_price"] - max(current["trade_price"], current["opening_price"])

        if is_red and body >= 0.7 * atr and upper_wick > body * 0.3:
            score_delta -= 3

    # ì ìˆ˜ ì—…ë°ì´íŠ¸
    with _PROBE_V2_LOCK:
        if market in PROBE_V2_STATES:
            PROBE_V2_STATES[market]["score"] += score_delta
            PROBE_V2_STATES[market]["last_update"] = time.time()

    return score_delta


def probe_v2_check_upgrade(market, candles):
    """1ì°¨ ì¶”ë§¤ ìŠ¹ê²© ì¡°ê±´ ì²´í¬
    - 10ë¶„ ë‚´ ëˆ„ì  ì ìˆ˜ >= +5
    - ìµœê·¼ 5ë´‰ ì €ì ì´ 10EMA ìœ„ì—ì„œ Higher Low 2íšŒ
    - ì‹ ê·œ ê³ ì  ê°±ì‹  & RVOL >= 1.5
    """
    with _PROBE_V2_LOCK:
        if market not in PROBE_V2_STATES:
            return False
        state = PROBE_V2_STATES[market]
        score = state["score"]
        entry_time = state["entry_time"]

    # 10ë¶„ ì´ë‚´ ì²´í¬
    elapsed = time.time() - entry_time
    if elapsed > 600:  # 10ë¶„
        return False

    # ì ìˆ˜ ì²´í¬
    if score < PROBE_V2_UPGRADE_SCORE:
        return False

    if len(candles) < 10:
        return False

    # Higher Low ì²´í¬
    closes = [c["trade_price"] for c in candles]
    ema10 = ema_last(closes, 10)
    if not ema10:
        return False

    recent5 = candles[-5:]
    lows = [c["low_price"] for c in recent5]

    # ëª¨ë‘ 10EMA ìœ„
    if not all(low > ema10 for low in lows):
        return False

    # Higher Low 2íšŒ ì´ìƒ
    higher_low_count = 0
    for i in range(1, len(lows)):
        if lows[i] > lows[i-1]:
            higher_low_count += 1

    if higher_low_count < 2:
        return False

    # ì‹ ê·œ ê³ ì  ê°±ì‹ 
    current_high = candles[-1]["high_price"]
    prev_highs = [c["high_price"] for c in candles[-10:-1]]
    if current_high <= max(prev_highs):
        return False

    # RVOL >= 1.5
    volumes = [c["candle_acc_trade_volume"] for c in candles[-30:]]
    avg_volume = sum(volumes[:-1]) / 29 if len(volumes) > 1 else 1
    current_volume = candles[-1]["candle_acc_trade_volume"]
    rvol = current_volume / max(avg_volume, 1)

    if rvol < 1.5:
        return False

    return True


def probe_v2_check_failure(market, candles):
    """í”„ë¡œë¸Œ ì‹¤íŒ¨ ì¡°ê±´ ì²´í¬
    - ì ìˆ˜ <= -3
    - 10EMA ì¢…ê°€ 2ì—°ì† í•˜íšŒ
    - íƒ€ì„ì•„ì›ƒ (12ë¶„ë´‰)
    """
    with _PROBE_V2_LOCK:
        if market not in PROBE_V2_STATES:
            return False
        state = PROBE_V2_STATES[market]
        score = state["score"]
        entry_time = state["entry_time"]
        bars_since = state.get("bars_count", 0)

    # ì ìˆ˜ ì‹¤íŒ¨
    if score <= -3:
        return True

    # íƒ€ì„ì•„ì›ƒ
    if bars_since >= PROBE_V2_TIMEOUT_BARS:
        return True

    # 10EMA 2ì—°ì† í•˜íšŒ
    if len(candles) >= 2:
        closes = [c["trade_price"] for c in candles]
        ema10 = ema_last(closes, 10)
        if ema10:
            last2 = candles[-2:]
            if all(c["trade_price"] < ema10 for c in last2):
                return True

    return False


def probe_v2_manage_queue():
    """í”„ë¡œë¸Œ í ê´€ë¦¬
    - ìµœëŒ€ ë™ì‹œ í™œì„± í”„ë¡œë¸Œ ìˆ˜ ì œí•œ
    - ì ìˆ˜ ìµœí•˜ìœ„ ì œê±°
    """
    with _PROBE_V2_LOCK:
        if len(PROBE_V2_STATES) <= PROBE_V2_MAX_CONCURRENT:
            return

        # ì ìˆ˜ ìˆœ ì •ë ¬ (ë‚®ì€ ìˆœ)
        sorted_probes = sorted(PROBE_V2_STATES.items(), key=lambda x: x[1]["score"])

        # ì´ˆê³¼ë¶„ ì œê±°
        remove_count = len(PROBE_V2_STATES) - PROBE_V2_MAX_CONCURRENT
        for i in range(remove_count):
            market = sorted_probes[i][0]
            print(f"[PROBE_V2] í ê´€ë¦¬: {market} ì œê±° (ì ìˆ˜: {sorted_probes[i][1]['score']})")
            del PROBE_V2_STATES[market]


def probe_v2_add_state(market, trigger_type):
    """í”„ë¡œë¸Œ ìƒíƒœ ì¶”ê°€"""
    with _PROBE_V2_LOCK:
        PROBE_V2_STATES[market] = {
            "score": 0,
            "entry_time": time.time(),
            "trigger_type": trigger_type,
            "last_update": time.time(),
            "bars_count": 0,
        }
    probe_v2_manage_queue()


def probe_v2_remove_state(market):
    """í”„ë¡œë¸Œ ìƒíƒœ ì œê±°"""
    with _PROBE_V2_LOCK:
        if market in PROBE_V2_STATES:
            del PROBE_V2_STATES[market]


def probe_v2_increment_bars(market):
    """í”„ë¡œë¸Œ ë°” ì¹´ìš´íŠ¸ ì¦ê°€ (1ë¶„ë§ˆë‹¤)"""
    with _PROBE_V2_LOCK:
        if market in PROBE_V2_STATES:
            PROBE_V2_STATES[market]["bars_count"] += 1


# =========================
# â˜… ê·¸ë¼ì¸ë“œ(ê³„ë‹¨ì‹ ìƒìŠ¹) ì˜ˆì™¸
# =========================
# === PATCH: grind detector ===
def grind_break_ok(c1, ticks):
    """ê³„ë‹¨ì‹(ê·¸ë¼ì¸ë“œ) ìƒìŠ¹ ì˜ˆì™¸:
       - ìµœê·¼ 8ë´‰ ì¤‘ 7ë´‰ ì´ìƒì´ EMA5 ìœ„
       - ë§¤ìˆ˜ë¹„(15s) >= 0.56
       - ì²´ê²°ê°„ ê°„ê²© ë³€ë™ê³„ìˆ˜(CV, 30s) <= 0.95 (ë„ˆë¬´ ê³ ë¥¸ TWAP/ë´‡ ì œì™¸)
    """
    if len(c1) < 10 or not ticks:
        return False
    closes = [x["trade_price"] for x in c1]
    e5 = ema_series(closes, 5)
    last8 = list(zip(c1[-8:], e5[-8:]))
    above = sum(1 for c, e in last8 if c["trade_price"] >= e)
    ema_slope = (e5[-1] - e5[-4]) if len(e5) >= 4 else 0
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    ia = inter_arrival_stats(ticks, 30)
    return (above >= 7 and ema_slope > 0 and t15.get("buy_ratio", 0) >= 0.56
            and ia.get("cv", 9.9) <= 0.95)


# =========================
# ì»· ë¡œê¹…
# =========================
DEBUG_CUT = os.getenv("DEBUG_CUT", "0") == "1"
CUT_COUNTER = {
    k: 0
    for k in [
        "SURGE_LOW", "VOL_LOW", "SPREAD_HIGH", "PRICE_LOW", "ZSC_LOW",
        "VWAP_GAP_LOW", "UPTICK_FAIL", "FAKE_PUMP", "TICKS_LOW", "TURN_LOW",
        "BUY_WEAK", "BUY_WEAK_MANYT", "FRESH_FAIL", "BIDASK_WEAK",
        "IGNITION_OK", "BOT_PINGPONG", "BOT_WASH", "BOTACC_OK", "WICK_SPIKE",
        "ATR_OVERSHOOT", "EMA15M_DOWN", "BUY_DECAY", "EARLY_OK",
        "EARLY_LIGHT_FAIL", "PEAK_CHASE", "POSTCHECK_DROP", "MEGA_PASS",
        "NO_SIGNAL", "PROBE_TICK"  # ê°€ë…ì„± í–¥ìƒì„ ìœ„í•œ ì¶”ê°€ í‚¤
    ]
}


def cut(reason, detail):
    CUT_COUNTER[reason] = CUT_COUNTER.get(reason, 0) + 1
    if DEBUG_CUT:
        now_str = now_kst().strftime("%H:%M:%S")
        print(f"[FILTER][{now_str}] {reason:<16} | {detail}")


def cut_summary():
    parts = [
        f"{k}:{v}" for k, v in sorted(
            CUT_COUNTER.items(), key=lambda x: x[1], reverse=True) if v > 0
    ]
    if parts:
        print(f"[CUT_SUMMARY] {' , '.join(parts)}")


# =========================
# ë©”ê°€ ë¸Œë ˆì´í¬ì•„ì›ƒ íŒì •
# =========================
def is_mega_breakout(c1):
    if not ULTRA_RELAX_ON_MEGA or len(c1) < 6:
        return False
    cur = c1[-1]
    prev_high = max(x["high_price"] for x in c1[-6:-1])
    gap = cur["high_price"] / max(prev_high, 1) - 1
    chg_1m = cur["trade_price"] / max(c1[-2]["trade_price"], 1) - 1 if len(
        c1) >= 2 else 0
    z = zscore_krw_1m(c1, 30)
    abs_krw = cur.get("candle_acc_trade_price", 0)
    return (gap >= MEGA_BREAK_MIN_GAP) and (chg_1m >= MEGA_MIN_1M_CHG) and (
        (z >= MEGA_VOL_Z) or (abs_krw >= MEGA_ABS_KRW))


# =========================
# í—ˆìˆ˜ ë°©ì–´ / ì í™” / ì¡°ê¸° ë¸Œë ˆì´í¬
# =========================
def _turn_needed(ob_depth_krw):
    """ê·¸ë¼ì¸ë“œí˜• ìƒìŠ¹ í¬ì°©ì„ ìœ„í•œ íšŒì „ìœ¨ ìš”êµ¬ì¹˜ ì™„í™”"""
    if ob_depth_krw >= 30_000_000:
        return 0.020   # 0.022 â†’ 0.020
    elif ob_depth_krw >= 15_000_000:
        return 0.022   # 0.026 â†’ 0.022
    elif ob_depth_krw >= 8_000_000:
        return 0.020   # 0.025 â†’ 0.020
    else:
        return 0.018   # 0.023 â†’ 0.018

def is_fake_pump(m,
                 current_volume,
                 current_price,
                 ob_snapshot,
                 tape30,
                 ticks=None,
                 c1=None):
    # í˜¸ê°€ ê¹Šì´ ê³ ì • ê¸°ì¤€ (ì•¼ê°„ ì™„í™” ì‚­ì œ - í—ˆìˆ˜íŒí”„ ê·¸ëŒ€ë¡œ ì»·)
    min_depth = MIN_DEPTH_KRW
    if not ob_snapshot or ob_snapshot.get("depth_krw", 0) < min_depth:
        return True
    if tape30.get("n", 0) < MIN_REAL_TRADES:
        return True
    if ticks:
        if wash_trade_pattern(ticks, 30, BOT_WASH_REPEAT_VOL_N):
            cut("BOT_WASH", f"{m} wash-like repeat vol")
            return True
        pp = bot_pingpong_score(ticks, 20, BOT_PINGPONG_MAX_BAND)
        if pp >= BOT_PINGPONG_MIN_ALT:
            ia = inter_arrival_stats(ticks, 30)
            pstd = price_band_std(ticks, 30)
            buy = micro_tape_stats_from_ticks(ticks, 30).get("buy_ratio", 0)
            if (pstd <= 0.0009) and (ia["cv"] <= 0.35) and (buy < 0.45
                                                            or buy > 0.75):
                cut(
                    "BOT_PINGPONG",
                    f"{m} alt {pp:.2f} | buy {buy:.2f} | cv {ia['cv']:.2f} | pstd {pstd:.4f}"
                )
                return True
    if c1 is None:
        c1 = get_minutes_candles(1, m, 5)
    if len(c1) >= 3:
        v = [c["candle_acc_trade_price"] for c in c1[-3:]]
        if len(v) >= 2 and v[-1] < v[-2] * 0.3:
            return True
    return False


def ignition_trigger_ok(m, c1, ticks, ob):
    if not c1 or not ticks or not ob:
        return False, "IGN_INIT_FAIL"
    cur = c1[-1]
    try:
        prev_high = max(x["high_price"]
                        for x in c1[-(IGN_BREAK_LOOKBACK + 1):-1])
    except:
        prev_high = 0
    if cur["high_price"] <= prev_high:
        return False, "IGN_NO_BREAK"
    if body_ratio(cur) < IGN_MIN_BODY:
        return False, "IGN_BODY_SMALL"
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    turn = t15["krw"] / max(ob.get("depth_krw", 1), 1)
    if t15["buy_ratio"] < IGN_MIN_BUY:
        return False, "IGN_BUY_WEAK"
    if turn < _turn_needed(ob.get("depth_krw", 0)):
        return False, "IGN_TURN_LOW"
    if ob.get("spread", 999) > MAX_SPREAD_FAST:
        return False, "IGN_SPREAD"
    if not five_min_context_ok(m):
        return False, "IGN_5M_WEAK"
    return True, "IGNITION_OK"


def tick_breakout_ok(m, c1, ticks, ob, lookback=12):
    if not (USE_TICK_BREAK and c1 and ticks and ob): return False
    try:
        prev_high = max(x["high_price"] for x in c1[-(lookback + 1):-1])
    except:
        return False
    last_prices = [x["trade_price"] for x in ticks[:20]]
    if not last_prices: return False
    cur_max = max(last_prices)
    gap = cur_max / max(prev_high, 1) - 1
    t15 = micro_tape_stats_from_ticks(ticks, 15)
    depth_ok = ob.get("depth_krw", 0) >= 12_000_000
    return (gap >= TICK_BREAK_GAP) and (t15["buy_ratio"]
                                        >= 0.60) and uptick_streak_from_ticks(
                                            ticks, need=2) and depth_ok


def meets_volume_surge(current_volume, past_volumes):
    avg_past = statistics.mean(
        past_volumes) if past_volumes else current_volume / 8
    rel_x = current_volume / max(avg_past, 1)
    return (rel_x >= MIN_RELATIVE_KRW_X) or (current_volume >= ABS_SURGE_KRW
                                             and rel_x >= RELAXED_X)


# =========================
# ê°ì§€ / ê²€ì¦
# =========================
def detect_leader_stock(m, obc, c1, tight_mode=False):
    """
    í•˜ì´ë¸Œë¦¬ë“œ ì§„ì… íƒì§€ ì—”ì§„:
      - Probe(ì†Œì•¡): ì™„í™”ëœ early íë¦„ ê°ì§€ â†’ ì´ˆê¸° ì—¼íƒ ì§„ì…
      - Confirm(ì¶”ì„¸): ê°•í•œ ì í™”/ë§¤ì§‘/ëŒíŒŒ â†’ í™•ì • ì§„ì…
    """
    if len(c1) < 3:
        return None

    # === ë™ì¼ ì¢…ëª© ì¤‘ë³µ ì§„ì… ë°©ì§€ (probe ëª¨ë“œëŠ” 25ì´ˆë¡œ ë‹¨ì¶•, ì¼ë°˜ì€ 90ì´ˆ) ===
    cooldown_after_exit = 25 if ALWAYS_PROBE_FIRST else 90
    now_ts = time.time()

    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m)

    if pos:
        last_add_ts  = pos.get("last_add_ts", 0.0)
        last_exit_ts = pos.get("last_exit_ts", 0.0)  # ëª¨ë‹ˆí„°ë§ ìª½ì—ì„œ ê¸°ë¡ë  ìˆ˜ ìˆìŒ
        if (now_ts - max(last_add_ts, last_exit_ts)) < cooldown_after_exit:
            return None
    else:
        # í¬ì§€ì…˜ì´ ì—†ì–´ë„ ìµœê·¼ 'ì²­ì‚° ì™„ë£Œ' ë˜ëŠ” 'ì²­ì‚° ì‹œë„(ë¯¸ì²´ê²° í¬í•¨)'ê°€ ê°€ê¹Œìš°ë©´ ìŠ¤í‚µ
        with _POSITION_LOCK:
            last_exit_done    = LAST_EXIT_AT.get(m, 0.0)
            last_exit_attempt = LAST_EXIT_ATTEMPT.get(m, 0.0)
        last_block = max(last_exit_done, last_exit_attempt)
        if (now_ts - last_block) < cooldown_after_exit:
            return None

    # === Micro-Probe: ì´ˆê²½ëŸ‰ ì¦‰ì‹œ ì°Œë¥´ê¸° (ê°€ì¥ ë¨¼ì € í‰ê°€) ===
    ticks_now = get_recent_ticks(m, 80)
    if ticks_now:
        t6 = micro_tape_stats_from_ticks(ticks_now, 6)
        if (
            t6["n"] >= 2 and                    # ì²´ê²° 2ê°œ ì´ìƒ (3 â†’ 2, ì´ˆì™„í™”)
            t6["buy_ratio"] >= 0.48 and         # ë§¤ìˆ˜ë¹„ 48%+ (0.50 â†’ 0.48, ì´ˆì™„í™”)
            t6["krw_per_sec"] >= 8000 and       # ì†ë„ 8k KRW/s+ (4000 â†’ 8000, íƒ€ì´íŠ¸)
            last_two_ticks_fresh(ticks_now) and
            uptick_streak_from_ticks(ticks_now, need=1)
        ):
            ob_l = obc.get(m)
            if ob_l and ob_l.get("depth_krw", 0) >= 3_000_000 and ob_l.get("spread", 999) <= 2.0:  # 5M â†’ 3M, 1.5 â†’ 2.0, ì´ˆì™„í™”
                # VWAP ê³¼ì—´ ì¶”ê²©ë§Œ í”¼í•˜ê¸°
                vgap_mp = 0.0
                if c1:
                    v20 = vwap_from_candles_1m(c1, 20)
                    if v20:
                        vgap_mp = (ticks_now[0]["trade_price"]/v20 - 1.0)
                if vgap_mp <= 0.022:  # 0.018 â†’ 0.022, ì´ˆì™„í™”
                    cut("MICRO_PROBE", f"{m} ì´ˆê²½ëŸ‰ ì°Œë¥´ê¸° (ë§¤ìˆ˜ë¹„ {t6['buy_ratio']:.2f}, ì†ë„ {t6['krw_per_sec']:.0f})")

                    # changeì™€ volume_surge ê³„ì‚°
                    cur_price = ticks_now[0]["trade_price"]
                    price_change = 0.0
                    volume_surge = 1.0
                    if c1 and len(c1) >= 2:
                        price_change = (cur_price / max(c1[-2]["trade_price"], 1) - 1)
                    if c1:
                        current_volume = c1[-1].get("candle_acc_trade_volume", 0)
                        avg_past = avg_past_volume(c1, n=5, field="candle_acc_trade_volume")
                        if avg_past > 0 and current_volume > 0:
                            volume_surge = current_volume / max(avg_past, current_volume / 8, 1)

                    return {
                        "price": cur_price,
                        "change": price_change,
                        "volume_surge": volume_surge,
                        "current_volume": c1[-1].get("candle_acc_trade_volume", 0) if c1 else 0,
                        "ob": ob_l,
                        "ticks": ticks_now,
                        "tape": t6,
                        "early_ok": True,
                        "entry_mode": "probe"
                    }

    # === í‹± ê¸°ë°˜ ì´ˆë´‰(10ì´ˆ) ì„ í–‰ ì§„ì… ì‹œê·¸ë„ (ê°•í™”ëœ í•„í„°ë§) ===
    if not ticks_now:
        ticks_now = get_recent_ticks(m, 80)
    if ticks_now:
        t10s = micro_tape_stats_from_ticks(ticks_now, 10)
        t30s = micro_tape_stats_from_ticks(ticks_now, 30)

        # ì´ˆì… ì‹ í˜¸ ê°•í™”: ë” ê°•í•œ ë§¤ìˆ˜ë¹„ + ë” ë§ì€ í‹± + ì—°ì† ìƒìŠ¹
        sudden_burst = (
            t10s["krw_per_sec"] >= 2.0 * t30s["krw_per_sec"]  # 1.8 â†’ 2.0 (ë” ê°•í•œ ê°€ì†)
            and t10s["buy_ratio"] >= 0.60  # 0.58 â†’ 0.60 (ë” ê°•í•œ ë§¤ìˆ˜ì„¸)
            and t10s["n"] >= 5  # 3 â†’ 5 (ë” ë§ì€ í‹± í•„ìš”)
            and t10s["krw_per_sec"] >= 18000  # ì ˆëŒ€ ê±°ë˜ì†ë„ í•˜í•œ ì¶”ê°€
        )

        fresh = uptick_streak_from_ticks(ticks_now, need=2)  # need=1 â†’ need=2 (ì—°ì† ìƒìŠ¹ ê°•í™”)

        if sudden_burst and fresh:
            cut("PROBE_TICK", f"{m} í‹± ì´ˆì… ê°ì§€ â†’ probe ì‹ í˜¸ (ë§¤ìˆ˜ë¹„ {t10s['buy_ratio']:.2f})")

            # changeì™€ volume_surge ê³„ì‚°
            cur_price = ticks_now[0]["trade_price"]
            price_change = 0.0
            volume_surge = 1.0
            if c1 and len(c1) >= 2:
                price_change = (cur_price / max(c1[-2]["trade_price"], 1) - 1)
            if c1:
                current_volume = c1[-1].get("candle_acc_trade_volume", 0)
                avg_past = avg_past_volume(c1, n=5, field="candle_acc_trade_volume")
                if avg_past > 0 and current_volume > 0:
                    volume_surge = current_volume / max(avg_past, current_volume / 8, 1)

            pre = {
                "price": cur_price,
                "change": price_change,
                "volume_surge": volume_surge,
                "current_volume": c1[-1].get("candle_acc_trade_volume", 0) if c1 else 0,
                "ob": obc.get(m),
                "ticks": ticks_now,
                "tape": t10s,  # â† tape ì¶”ê°€ (final_check_leader í¬ë˜ì‹œ ë°©ì§€)
                "entry_mode": "probe",
                "early_ok": True,
            }
            return pre

    # === Probe-Lite: ê°€ë²¼ìš´ ì¡°ê±´ìœ¼ë¡œ ì´ˆì… ë¹ˆë„ ì¦ê°€ ===
    if PROBE_LITE_ON:
        ticks_lite = ticks_now if ticks_now else get_recent_ticks(m, 80)
        ob_lite = obc.get(m)
        if ticks_lite and ob_lite and c1:
            t10 = micro_tape_stats_from_ticks(ticks_lite, 10)
            vwap20 = vwap_from_candles_1m(c1, 20)
            vgap = (c1[-1]["trade_price"] / max(vwap20, 1) - 1.0) if vwap20 else 0.0

            # ì˜¤ë”ë¶ ìµœì†Œ ê¹Šì´ ê°€ë“œ ì¶”ê°€ (í—ˆìˆ˜ ë°°ì œ)
            if (ob_lite.get("depth_krw", 0) >= 8_000_000 and
                t10["buy_ratio"] >= PROBE_LITE_MIN_BUY and
                t10["krw_per_sec"] >= PROBE_LITE_MIN_KRWPSEC and
                uptick_streak_from_ticks(ticks_lite, need=1) and
                ob_lite.get("spread", 999) <= PROBE_LITE_MAX_SPREAD and
                abs(vgap) <= PROBE_LITE_MAX_VWAP_GAP):

                cut("PROBE_LITE", f"{m} probe-lite ì‹ í˜¸ (ë§¤ìˆ˜ë¹„ {t10['buy_ratio']:.2f}, ì†ë„ {t10['krw_per_sec']:.0f})")

                # changeì™€ volume_surge ê³„ì‚°
                cur_price = ticks_lite[0]["trade_price"]
                price_change = 0.0
                volume_surge = 1.0
                if c1 and len(c1) >= 2:
                    price_change = (cur_price / max(c1[-2]["trade_price"], 1) - 1)
                if c1:
                    current_volume = c1[-1].get("candle_acc_trade_volume", 0)
                    avg_past = avg_past_volume(c1, n=5, field="candle_acc_trade_volume")
                    if avg_past > 0 and current_volume > 0:
                        volume_surge = current_volume / max(avg_past, current_volume / 8, 1)

                return {
                    "price": cur_price,
                    "change": price_change,
                    "volume_surge": volume_surge,
                    "current_volume": c1[-1].get("candle_acc_trade_volume", 0) if c1 else 0,
                    "ob": ob_lite,
                    "ticks": ticks_lite,
                    "tape": t10,
                    "early_ok": True,
                    "entry_mode": "probe"
                }

    # (ì´í•˜ ê¸°ì¡´ detect_leader_stock ì½”ë“œ ê³„ì†)

    ob = obc.get(m)
    if not ob or not isinstance(ob.get("raw"), dict):
        return None
    raw_units = (ob.get("raw") or {}).get("orderbook_units") or []  # âœ…
    if not raw_units:  # âœ… í¬ê·€ ì¼€ì´ìŠ¤ ë°©ì§€
        cut("BIDASK_WEAK", f"{m} missing orderbook units")
        return None
    if ob.get("depth_krw", 0) <= 0:
        return None

    # ğŸ”µ ì í™”/ë¸Œë ˆì´í¬ íŒì • ì „ í—ˆìˆ˜ íŒí”„ ì»· (ìƒˆë²½ í—ˆìˆ˜ ê°ì†Œ)
    cur = c1[-1]
    ticks = get_recent_ticks(m, 100)
    t30 = micro_tape_stats_from_ticks(ticks, 30) if ticks else {"n": 0, "krw": 0}
    if is_fake_pump(m, cur.get("candle_acc_trade_price", 0), cur["trade_price"], ob, t30, ticks=ticks, c1=c1):
        cut("FAKE_PUMP", f"{m} fake/illiquid")
        return None

    mega = is_mega_breakout(c1)
    th = get_dynamic_thresholds()
    cur, prev = c1[-1], c1[-2]
    price_change = (cur["trade_price"] / max(prev["trade_price"], 1) - 1)

    # ìŠ¤í”„ë ˆë“œ ì»·
    if ob["spread"] > (MAX_SPREAD_FAST if mega else MAX_SPREAD_BASE):
        cut("SPREAD_HIGH", f"{m} spread {ob['spread']:.2f}%")
        return None

    # ê±°ë˜ëŸ‰ ì¡°ê±´
    current_volume = cur.get("candle_acc_trade_price", 0)
    if current_volume < MIN_VOLUME_KRW and not mega:
        cut("VOL_LOW", f"{m} vol {int(current_volume)}")
        return None

    # ê±°ë˜ ì¦ê°€ìœ¨ ì²´í¬
    past_volumes = [c["candle_acc_trade_price"] for c in c1[-7:-2] if c["candle_acc_trade_price"] > 0]
    if not meets_volume_surge(current_volume, past_volumes) and not mega:
        ticks_tmp = get_recent_ticks(m, 100)
        t15_tmp = micro_tape_stats_from_ticks(ticks_tmp, 15)
        t45_tmp = micro_tape_stats_from_ticks(ticks_tmp, 45)
        if not (t15_tmp["krw_per_sec"] >= max(55_000, 1.15 * t45_tmp["krw_per_sec"])):
            cut("SURGE_LOW", f"{m} vol_surge_fail")
            return None

    # ì•½ìƒìŠ¹ ì»·
    if price_change < th["min_change"] and not mega:
        cut("PRICE_LOW", f"{m} {price_change*100:.2f}%")
        return None

    # í‹± í™•ë³´
    ticks = get_recent_ticks(m, 100)
    if not ticks:
        cut("TICKS_LOW", f"{m} no ticks")
        return None

    # === í…Œì´í”„Â·EMA ê³µí†µ ì§€í‘œ ===
    tape_stats = {k: micro_tape_stats_from_ticks(ticks, k) for k in [10, 15, 30, 45]}
    closes_1m = [x["trade_price"] for x in c1]
    ema5 = ema_last(closes_1m, 5) if closes_1m else None
    dist_ema5 = (cur["trade_price"] / ema5 - 1.0) if ema5 else 0.0
    t10, t15, t30, t45 = tape_stats[10], tape_stats[15], tape_stats[30], tape_stats[45]
    last_upticks_ok = uptick_streak_from_ticks(ticks, need=2)

    # === ì í™”/ë¸Œë ˆì´í¬ì•„ì›ƒ ê³„ì—´ ===
    ign_ok, ign_reason = ignition_trigger_ok(m, c1, ticks, ob)
    tick_break = tick_breakout_ok(m, c1, ticks, ob)
    ign_ok = ign_ok or tick_break

    botacc_ok, botacc_reason = bot_accum_trigger_ok(m, ticks, ob, c1)
    two_green_and_break = (
        sum(1 for c in c1[-3:] if c["trade_price"] > c["opening_price"]) >= 2
        and c1[-1]["high_price"] > max(c["high_price"] for c in c1[-4:-1])
    )

    # === Early (Probe) ì§„ì… íŒë‹¨ ===
    r = relax_knob()
    twin = t15 if t15["krw_per_sec"] >= t45["krw_per_sec"] else t45
    vgap = (cur["trade_price"] / max(vwap_from_candles_1m(c1, 20), 1) - 1)
    turn = twin["krw"] / max(ob["depth_krw"], 1)
    flow_floor = int(EARLY_FLOW_MIN_KRWPSEC * (0.80 if r >= 1.0 else 1.0))

    # Early ì¡°ê±´: ê·¸ë¼ì¸ë“œí˜• í¬ì°© ìœ„í•´ ì™„í™”
    early_conds = [
        vgap >= max(th["vwap_gap"] - 0.0003, EARLY_MIN_VWAP_GAP),
        vgap <= EARLY_MAX_VWAP_GAP,
        price_change <= 0.020,
        (ema5 is None) or (dist_ema5 <= EARLY_MAX_EMA5_GAP),
        twin["buy_ratio"] >= max(EARLY_MIN_BUY, 0.53),  # 0.55 â†’ 0.53 (ê·¸ë¼ì¸ë“œ ëŒ€ì‘)
        twin["krw_per_sec"] >= max(flow_floor, 16000),  # ì ˆëŒ€ í•˜í•œ 16000
        turn >= max(EARLY_MIN_TURN, 0.018),  # íšŒì „ìœ¨
        twin["n"] >= max(EARLY_MIN_TICKS, 6),  # 8 â†’ 6 (ìµœì†Œ í‹± ìˆ˜ ì™„í™”)
        last_two_ticks_fresh(ticks),
        uptick_streak_from_ticks(ticks, need=2),  # ì—°ì† ìƒìŠ¹ 2í‹±
    ]

    early_ok = all(early_conds)

    # === Confirm (í™•ì • ì§„ì… íŒë‹¨) ===
    confirm_ok = (
        ign_ok or botacc_ok or mega or two_green_and_break
        or (early_ok and twin["buy_ratio"] >= 0.60 and uptick_streak_from_ticks(ticks, need=3))  # 0.58 â†’ 0.60
    )

    # === Probe/Confirm ê²°ê³¼ ===
    if not (early_ok or confirm_ok):
        cut("NO_SIGNAL", f"{m} no entry cond")
        return None

    entry_mode = "confirm" if confirm_ok else "probe"

    # === ê²°ê³¼ íŒ¨í‚¤ì§• ===
    pre = {
        "price": cur["trade_price"],
        "change": price_change,
        "current_volume": current_volume,
        "volume_surge": (current_volume / max(statistics.mean(past_volumes) if past_volumes else current_volume / 8, 1)),
        "ob": ob,
        "tape": twin,
        "ticks": ticks,
        "ema5_gap": dist_ema5,
        "ign_ok": ign_ok,
        "botacc_ok": botacc_ok,
        "two_green_break": two_green_and_break,
        "early_ok": early_ok,
        "entry_mode": entry_mode,
    }
    if mega:
        pre["mega_ok"] = True

    return pre

def final_check_leader(m, pre, tight_mode=False):
    # ì•ˆì „ ê°€ë“œ: tape ì—†ìœ¼ë©´ ticksë¡œ ì¦‰ì„ ê³„ì‚°
    if "tape" not in pre:
        ticks = pre.get("ticks") or []
        pre["tape"] = micro_tape_stats_from_ticks(ticks, 15) if ticks else {"n":0,"buy_ratio":0,"krw":0,"krw_per_sec":0}

    # í”„ë¡œë¸ŒëŠ” ì†Œì•¡ í…ŒìŠ¤íŠ¸ ì§„ì…: ì–‘ì§ˆì˜ ì´ˆì… ì‹ í˜¸ë§Œ í¬ì°© (ì ì ˆí•œ í•„í„°ë§)
    if pre.get("entry_mode") == "probe":
        t = pre.get("tape", {"n":0,"buy_ratio":0,"krw":0})
        ob = pre.get("ob", {"depth_krw":0,"spread":99})

        # ì‹¤ì œ ê°’ ê³„ì‚° (ì¡°ê±´ ì²´í¬ì— ì‚¬ìš©)
        price_change = pre.get("change", 0.0)
        volume_surge = pre.get("volume_surge", 0.0)
        turn = t.get("krw") / max(ob.get("depth_krw"), 1)

        # â˜… ì§„ì… ì¡°ê±´ ì™„í™”: ì´ˆì… ë¹ ë¥´ê²Œ í¬ì°© (ê³ ì  ë¬¼ë¦¼ ë°©ì§€)
        if (t.get("n",0) >= 3 and                          # 3ê°œ ì´ìƒ í‹± (4â†’3 ì™„í™”)
            t.get("buy_ratio",0) >= 0.53 and              # ë§¤ìˆ˜ë¹„ 53% ì´ìƒ (0.57â†’0.53 ì™„í™”)
            t.get("krw_per_sec",0) >= 10_000 and          # ê±°ë˜ì†ë„ 10,000ì›/ì´ˆ ì´ìƒ (14Kâ†’10K ì™„í™”)
            ob.get("depth_krw",0) >= 3_000_000 and        # ê¹Šì´ 300ë§Œì› (ìœ ë™ì„± í™•ë³´)
            ob.get("spread",99) <= 2.2 and                # ìŠ¤í”„ë ˆë“œ 2.2% (2.0â†’2.2 ì™„í™”)
            abs(price_change) >= 0.0015):                 # â˜… ìµœì†Œ 0.15% ê°€ê²© ë³€ë™ (0.3â†’0.15 ì™„í™”)

            return {
                "price": pre["price"],
                "chg": round(price_change * 100, 2),
                "current_volume": int(pre.get("current_volume", 0)),
                "volume_surge": round(volume_surge, 2),
                "buy": round(t.get("buy_ratio",0)*100,1),
                "n": t.get("n",0),
                "spread": round(ob.get("spread",0),2),
                "turn": round(turn * 100, 2)
            }
        return None  # ì¡°ê±´ ë¯¸ì¶©ì¡± ì‹œ ì§„ì… ì•ˆ í•¨

    # â˜…â˜…â˜… ì™„í™” ë…¸ë¸Œ ì ìš© (ì»¨íŒ ì‹ í˜¸ë§Œ)
    r = relax_knob()
    t = pre["tape"]
    ob = pre["ob"]
    ticks = pre["ticks"]
    MIN_TURNOVER_LOCAL = max(0.018, _turn_needed(ob.get("depth_krw", 0)))  # 0.020 â†’ 0.018
    if tight_mode:
        MIN_TURNOVER_LOCAL += 0.002  # 0.003 â†’ 0.002
    if 0 <= now_kst().hour < 6:
        MIN_TURNOVER_LOCAL = max(0.018, MIN_TURNOVER_LOCAL - 0.004)
    MIN_TURNOVER_LOCAL = max(0.020, MIN_TURNOVER_LOCAL - 0.002 * r)  # â˜… ì¶”ê°€

    TICKS_BUY_RATIO_LOCAL = max(
        0.55, TICKS_BUY_RATIO + (0.02 if tight_mode else 0.0))  # 0.56 â†’ 0.55
    TICKS_BUY_RATIO_LOCAL = max(0.53,
                                TICKS_BUY_RATIO_LOCAL - 0.015 * r)  # 0.54 â†’ 0.53 (ìµœì €ì¹˜ ë³´ì¥)

    if t["n"] < MIN_TICKS_COUNT:
        cut("TICKS_LOW", f"{m} {t['n']}")
        return None
    turn = t["krw"] / max(ob["depth_krw"], 1)
    if turn < MIN_TURNOVER_LOCAL:
        cut("TURN_LOW", f"{m} turn {turn:.3f}")
        return None
    if t["buy_ratio"] < TICKS_BUY_RATIO_LOCAL:
        cut("BUY_WEAK", f"{m} buy {t['buy_ratio']:.2f}")
        return None
    if t["n"] >= 10 and t["buy_ratio"] < 0.63:
        cut("BUY_WEAK_MANYT", f"{m} weak many")
        return None
    if not last_two_ticks_fresh(ticks):
        cut("FRESH_FAIL", f"{m} stale")
        return None

    th = get_dynamic_thresholds()
    raw_units = (ob.get("raw") or {}).get("orderbook_units") or []  # âœ…
    if not raw_units:
        cut("BIDASK_WEAK", f"{m} missing orderbook units")
        return None
    raw_ob = raw_units[:3]
    bid_sum = sum(u["bid_size"] * u["bid_price"] for u in raw_ob)
    ask_sum = sum(u["ask_size"] * u["ask_price"] for u in raw_ob)
    if bid_sum / max(ask_sum, 1) < th["bidask_min"]:
        cut("BIDASK_WEAK", f"{m} bidask weak")
        return None

    max_spread = MAX_SPREAD_FAST if t.get("rate",
                                          0) >= 0.7 else MAX_SPREAD_BASE
    if ob["spread"] > max_spread:
        cut("SPREAD_HIGH", f"{m} spread {ob['spread']:.2f}%")
        return None

    price_change = pre.get("change", 0.0)

    return {
        "price": pre["price"],
        "chg": round(price_change * 100, 2),
        "current_volume": int(pre["current_volume"]),
        "volume_surge": round(pre.get("volume_surge", 0.0), 2),
        "buy": round(t["buy_ratio"] * 100, 1),
        "n": t["n"],
        "spread": round(ob["spread"], 2),
        "turn": round((t['krw'] / max(ob['depth_krw'], 1)) * 100, 2)
    }


# =========================
# === [DL LOGGING]
# =========================
LOG_PATH = os.path.join(os.getcwd(), os.getenv("DL_LOG_PATH",
                                               "signals_log.csv"))
_CSV_LOCK = threading.Lock()

DL_FIELDS = [
    "ts", "market", "entry_price", "chg_1m", "chg_5m", "chg_15m", "zscore_1m",
    "vwap_gap", "t15_buy", "t15_n", "t15_rate", "t15_krw", "turn", "spread",
    "depth_krw", "bidask_ratio", "volume_surge", "btc_1m", "btc_5m", "hour",
    "dow", "two_green_break", "ignition_ok", "early_ok", "uptick_ok", "ret_3m",
    "ret_10m", "ret_15m", "maxdd_10m", "maxrun_10m", "label_win10",
    "label_fail10"
]


def append_csv(row: dict):
    with _CSV_LOCK:
        new = not os.path.exists(LOG_PATH)
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=DL_FIELDS)
            if new: w.writeheader()
            for k in DL_FIELDS:
                if k not in row: row[k] = ""
            w.writerow(row)


def snapshot_row(m, entry_price, payload, pre, c1, ob, t15, btc1m, btc5m,
                 flags):
    raw_units = (ob.get("raw") or {}).get("orderbook_units") or []
    if raw_units:
        raw_ob = raw_units[:3]
        bid_sum = sum(u.get("bid_size", 0) * u.get("bid_price", 0) for u in raw_ob)
        ask_sum = sum(u.get("ask_size", 0) * u.get("ask_price", 0) for u in raw_ob)
        bidask_ratio = bid_sum / max(ask_sum, 1)
    else:
        bidask_ratio = 0.0


    row = {
        "ts": now_kst_str(),
        "market": m,
        "entry_price": int(entry_price),
        "chg_1m": round(flags.get("chg_1m", 0.0), 4),
        "chg_5m": flags.get("chg_5m", ""),
        "chg_15m": flags.get("chg_15m", ""),
        "zscore_1m": flags.get("zscore", ""),
        "vwap_gap": flags.get("vwap_gap", ""),
        "t15_buy": round(t15.get("buy_ratio", 0.0), 4),
        "t15_n": t15.get("n", 0),
        "t15_rate": round(t15.get("rate", 0.0), 4),
        "t15_krw": int(t15.get("krw", 0)),
        "turn": flags.get("turn", ""),
        "spread": payload.get("spread", ""),
        "depth_krw": ob.get("depth_krw", ""),
        "bidask_ratio": round(bidask_ratio, 3),
        "volume_surge": payload.get("volume_surge", ""),
        "btc_1m": btc1m,
        "btc_5m": btc5m,
        "hour": now_kst().hour,
        "dow": now_kst().weekday(),
        "two_green_break": 1 if flags.get("two_green_break") else 0,
        "ignition_ok": 1 if flags.get("ign_ok") else 0,
        "early_ok": 1 if flags.get("early_ok") else 0,
        "uptick_ok": 1 if flags.get("uptick_ok") else 0,
        "ret_3m": "",
        "ret_10m": "",
        "ret_15m": "",
        "maxdd_10m": "",
        "maxrun_10m": "",
        "label_win10": "",
        "label_fail10": ""
    }
    return row


# =========================
# í¬ìŠ¤íŠ¸ì²´í¬ 6ì´ˆ
# =========================
from collections import deque


def postcheck_6s(m, pre):
    if not POSTCHECK_ENABLED:
        return True, "SKIP"
    if pre.get("ign_ok") or pre.get("two_green_break") or pre.get(
            "mega_ok", False):
        return True, "BYPASS_STRONG_BREAK"

    # â˜…â˜…â˜… ì¥ì„¸/ì•¼ê°„ ì™„í™” ë…¸ë¸Œ
    r = relax_knob()
    pc_min_buy = max(0.46, POSTCHECK_MIN_BUY - 0.05 * r)   # 0.48 -> 0.46, ì™„í™”í­ ì‚´ì§â†‘
    pc_min_rate = max(0.14, POSTCHECK_MIN_RATE - 0.09 * r) # 0.16 -> 0.14
    pc_max_pstd = POSTCHECK_MAX_PSTD + 0.0005 * r          # ì‚´ì§ ë” ê´€ëŒ€
    pc_max_cv = POSTCHECK_MAX_CV + 0.18 * r
    pc_max_dd = POSTCHECK_MAX_DD + 0.005 * r

    window = POSTCHECK_WINDOW_SEC
    start = time.time()
    acc = deque(maxlen=400)  # ëˆ„ìˆ˜ ë°©ì§€
    seen = set()  # ì¤‘ë³µ ì°¨ë‹¨

    last_fetch = 0.0
    net_calls = 0  # â˜… ì´ë²ˆ postcheckì—ì„œ ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜
    # ë°¤ì—ëŠ” ì¡°ê¸ˆ ëŠìŠ¨, ì£¼ê°„ì—” ì•½ê°„ ë¹ ë¥´ê²Œ
    fetch_interval = 2.0 if (0 <= now_kst().hour < 6) else 1.6
    ok_streak = 0

    base_price = pre["price"]
    peak = base_price
    trough_after_peak = base_price  # í”¼í¬ ì´í›„ ìµœì €ê°€ ì¶”ì 

    # â˜…â˜…â˜… postcheck ì¤‘ ìµœëŒ€ í—ˆìš© ê¸‰ë“± (probeëŠ” ë” ì™„í™”)
    entry_mode = pre.get("entry_mode", "confirm")
    if entry_mode == "probe":
        MAX_SURGE = 0.050  # probe: 5% í—ˆìš© (2.2â†’5%, ì§„ì§œ ìƒìŠ¹ ë†“ì¹˜ì§€ ì•Šê¸°)
    else:
        MAX_SURGE = 0.030  # confirm: 3% (1.5â†’3%, ì™„í™”)

    while True:
        now = time.time()
        if now - start > window:
            break

        # ìºì‹œ ì¬ì‚¬ìš© + ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ íšŸìˆ˜ ì œí•œ
        if (now - last_fetch >= fetch_interval) and (net_calls < 2):
            # ìµœëŒ€ 2ë²ˆê¹Œì§€ë§Œ ì‹¤ì œ API í˜¸ì¶œ
            ticks = get_recent_ticks(m, 100, allow_network=True)
            last_fetch = now
            net_calls += 1
        else:
            # ë‚˜ë¨¸ì§€ëŠ” ìºì‹œë§Œ ì‚¬ìš©
            ticks = get_recent_ticks(m, 100, allow_network=False)

        if not ticks:
            time.sleep(0.45)
            continue

        # accì— ìµœì‹  í‹±ë§Œ ì¤‘ë³µì—†ì´ ì¶•ì 
        for x in ticks[:12]:
            key = (x.get("timestamp"), x.get("trade_price"),
                   x.get("trade_volume"))
            if key in seen:
                continue
            seen.add(key)
            acc.appendleft(x)  # ìµœì‹ ì´ ì•

        curp = ticks[0].get("trade_price", base_price)

        # â˜…â˜…â˜… ê°€ê²© ê¸‰ë“± ì»· ì¶”ê°€
        if base_price > 0:
            surge = (curp / base_price - 1.0)
            if surge >= MAX_SURGE:
                return False, f"SURGE_IN_POST({surge*100:.2f}%)"

        if curp > peak:
            peak = curp
            trough_after_peak = curp  # ìƒˆ í”¼í¬ê°€ ìƒê¸°ë©´ íŠ¸ë¡œí”„ ë¦¬ì…‹
        else:
            trough_after_peak = min(trough_after_peak, curp)

        # âœ” DDëŠ” í”¼í¬ ëŒ€ë¹„ í•˜ë½ë¥ (ìŒìˆ˜)ë¡œ ì²´í¬
        dd = (curp / peak - 1.0)

        t10 = micro_tape_stats_from_ticks(list(acc), 10)
        ia = inter_arrival_stats(list(acc), 20)
        pstd = price_band_std(list(acc), 20)

        # â˜… ê°€ë³€ ì„ê³„ì¹˜ ì ìš©
        pass_now = (t10["buy_ratio"] >= pc_min_buy
                    and t10["rate"] >= pc_min_rate and pstd <= pc_max_pstd
                    and ia["cv"] <= pc_max_cv and dd >= -pc_max_dd)

        if pass_now:
            ok_streak += 1
            if ok_streak >= 2:
                return True, "OK_EARLY"
        else:
            ok_streak = 0

        # í‹±ì´ ì¶©ë¶„íˆ ëŠë¦¬ë©´ ìŠ¬ë¦½ì„ ë” ê¸¸ê²Œ
        time.sleep(0.6 if t10["rate"] >= 0.6 else 1.0)

    if not acc:
        return False, "POST_NO_TICKS"

    # ì¢…ë£Œ ì‹œì  ì¬í‰ê°€ (acc ê¸°ë°˜ìœ¼ë¡œ í”¼í¬/íŠ¸ë¡œí”„ ê³„ì‚°)
    prices = [x.get("trade_price", base_price) for x in list(acc)]
    if prices:
        peak2 = max(prices + [base_price])
        curp2 = prices[0]
        dd2 = (curp2 / peak2 - 1.0)
    else:
        dd2 = 0.0

    t10 = micro_tape_stats_from_ticks(list(acc), 10)
    ia = inter_arrival_stats(list(acc), 20)
    pstd = price_band_std(list(acc), 20)

    # â˜… ìµœì¢… íŒì •ë„ ê°€ë³€ ì„ê³„ì¹˜ë¡œ
    if t10["buy_ratio"] < pc_min_buy:
        return False, f"BUY_LOW({t10['buy_ratio']:.2f})"
    if t10["rate"] < pc_min_rate: return False, f"RATE_LOW({t10['rate']:.2f})"
    if pstd > pc_max_pstd: return False, f"PSTD_HIGH({pstd:.4f})"
    if ia["cv"] > pc_max_cv: return False, f"CV_HIGH({ia['cv']:.2f})"
    if dd2 < -pc_max_dd: return False, f"DD_TOO_DEEP({dd2:.4f})"
    return True, "OK"

# =========================
# ë™ì  ì†ì ˆ
# =========================
def dynamic_stop_loss(entry_price, c1, signal_type=None, current_price=None):
    atr = atr14_from_candles(c1, ATR_PERIOD)
    if not atr or atr <= 0:
        return entry_price * (1 - STOP_LOSS_PCT), STOP_LOSS_PCT

    pct = min(max((atr / max(entry_price, 1)) * ATR_MULT, DYN_SL_MIN), DYN_SL_MAX * 0.9)

    # ğŸš€ ì‹ í˜¸ ìœ í˜•ë³„ ì™„í™”
    if signal_type in ("early", "ign", "mega"):
        pct *= 1.3

    # ğŸ’ ìµì ˆ ì¤‘ì´ë©´ ì†ì ˆí­ ë” ì™„í™” (ëˆŒë¦¼ ë°©ì§€)
    if current_price and current_price > entry_price * 1.008:
        pct *= 1.5  # ìˆ˜ìµ ì¤‘ì—ëŠ” SLì„ ë” ë©€ë¦¬ ë‘ 

    return entry_price * (1 - pct), pct

# =========================
# ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì²­ì‚° ì ìˆ˜
# =========================
def context_exit_score(m, ticks, ob_depth_krw, entry_price, last_price, c1):
    """
    íœ˜í•‘ ë°©ì§€í˜• ì»¨í…ìŠ¤íŠ¸ ì ìˆ˜:
    - ë‹¨ì¼ ì‹ í˜¸ë¡œ ì²­ì‚° ìœ ë„ ê¸ˆì§€ (ë³µí•© ì¡°ê±´ ëˆ„ì )
    - ì¶”ì„¸ ì—­ì „(EMA5/VWAP ì´íƒˆ + uptick ë¶€ì¬) ìª½ì— ê°€ì¤‘ì¹˜
    """
    score = 0
    reasons = []

    # í…Œì´í”„ ë³€í™”
    w_now = _win_stats(ticks, 0, 10)
    w_early = _win_stats(ticks, 10, 30)
    decay, _ = buy_decay_flag(ticks)

    if w_now["krw_per_sec"] < w_early["krw_per_sec"] * 0.60:
        score += 1
        reasons.append("FLOW_DROP")
    if not uptick_streak_from_ticks(ticks, need=2):
        score += 1
        reasons.append("NO_UPTICK")
    if w_now["rate"] < 0.25:  # ë„ˆë¬´ ëŠë¦¬ë©´ 1ì 
        score += 1
        reasons.append("RATE_SLOW")

    # ê°€ê²©/ì»¨í…ìŠ¤íŠ¸
    vwap = vwap_from_candles_1m(c1, 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in c1], 5) if c1 else 0
    if vwap and last_price < vwap:
        score += 1
        reasons.append("VWAP_LOSS")
    if ema5 and last_price < ema5:
        score += 1
        reasons.append("EMA5_LOSS")

    # ğŸ’ ì•½ìƒìŠ¹/íš¡ë³´ ì‹œ ì²­ì‚° ì ìˆ˜ ì™„í™”
    gain_now = (last_price / entry_price - 1.0)
    if -0.004 <= gain_now <= 0.008:  # ì™„í™” ë²”ìœ„ í™•ëŒ€
        score = max(0, score - 1)
        reasons.append("MILD_GAIN_RELAX")

    # ìˆ˜ìµ êµ¬ê°„ì—ì„œì˜ ê¸‰ê°
    if last_price > entry_price * 1.008 and decay:
        score += 1
        reasons.append("DECAY_AFTER_GAIN")

    return score, reasons

# =========================
# â˜… ëª¨ë‹ˆí„°ë§ ì‹œê°„ ê²°ì • (ì‹ ê·œ ì¶”ê°€)
# =========================
def decide_monitor_secs(pre: dict, tight_mode: bool = False) -> int:
    """
    í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì´ ì‹œê°„(ì´ˆ)ì„ ìƒí™©ë³„ë¡œ ê²°ì •.
    - early_ok: ë¹„êµì  ì§§ê²Œ ì¶”ì„¸ í™•ì¸
    - ignition_ok / mega_ok: ìƒëŒ€ì ìœ¼ë¡œ ê¸¸ê²Œ (ì¶”ì„¸ ì´ì–´ì§ˆ ê°€ëŠ¥ì„±)
    - ì‹œì¥ ëª¨ë“œ(TIGHT), ì•¼ê°„, BTC ëª¨ë©˜í…€, ì˜¤ë”ë¶ ê¹Šì´ ë“±ì— ë”°ë¼ ê°€/ê°
    """
    try:
        r = relax_knob()  # 0.0 ~ 1.5
    except Exception:
        r = 0.0

    base = 150  # ê¸°ë³¸ê°’

    # ì‹ í˜¸ ìœ í˜• ê°€ì¤‘
    if pre.get("mega_ok"):
        base = 300
    elif pre.get("ign_ok"):
        base = 240
    elif pre.get("botacc_ok"):
        base = 210
    elif pre.get("early_ok"):
        base = 180
    elif pre.get("two_green_break"):
        base = 210

    # ì˜¤ë”ë¶ ê¹Šì´ ê¸°ë°˜ (ê¹Šìœ¼ë©´ ì—¬ìœ  ìˆê²Œ)
    ob_depth = 0
    try:
        ob_depth = pre.get("ob", {}).get("depth_krw", 0) or 0
    except Exception:
        pass
    if ob_depth >= 30_000_000:
        base += 30
    elif ob_depth <= 6_000_000:
        base -= 30

    # BTC 5ë¶„ ëª¨ë©˜í…€
    try:
        b5 = btc_5m_change()
    except Exception:
        b5 = 0.0
    if b5 >= 0.006:
        base += 30
    elif b5 <= -0.008:
        base -= 30

    # ì•¼ê°„(00~06 KST)ì—” í”ë“¤ë¦¼ ëŒ€ë¹„ ì•½ê°„ ë‹¨ì¶•
    h = now_kst().hour
    if 0 <= h < 6:
        base -= 15

    # ì¥ì„¸ ì™„í™” ë…¸ë¸Œ ë°˜ì˜
    base += int(10 * r)

    # íƒ€ì´íŠ¸ ëª¨ë“œ(ê¸‰ë½ ë°©ì–´)ë©´ ë‹¨ì¶•
    if tight_mode:
        base -= 30

    # í•˜í•œ/ìƒí•œ í´ë¨í”„
    base = max(90, min(base, 360))
    return int(base)


# =========================
# ëì•ŒëŒ ê¶Œê³  ìƒì„± (END RECO)
# =========================
def _end_reco(m, entry_price, last_price, ret_pct, c1, ticks, ob_depth_krw, ctx_thr=3):

    try:
        ctx_score, ctx_reasons = context_exit_score(
            m,
            ticks or [],
            ob_depth_krw or 10_000_000,
            entry_price,
            last_price,
            c1 or [],
        )
    except Exception:
        ctx_score, ctx_reasons = (0, [])

    # í…Œì´í”„(ìµœê·¼ 15s)
    t15 = micro_tape_stats_from_ticks(ticks or [], 15)
    buy = t15.get("buy_ratio", 0.0)
    n = t15.get("n", 0)

    # ì»¨í…ìŠ¤íŠ¸(EMA5 / VWAP)
    vwap = vwap_from_candles_1m(c1 or [], 20) if c1 else 0
    ema5 = ema_last([x["trade_price"] for x in (c1 or [])], 5) if c1 else 0
    vwap_ok = bool(vwap and last_price >= vwap)
    ema_ok = bool(ema5 and last_price >= ema5)

    # ğŸ’ ê±°ë˜ ë‘”í™” + ì•½ìƒìŠ¹ â†’ ë³¸ì ˆ ìµì ˆ ìœ ë„
    if -0.2 <= ret_pct <= 0.4 and t15.get("krw_per_sec", 0) < 12000 and ctx_score <= ctx_thr:

        action = "ë¶€ë¶„ ì²­ì‚°(ë³¸ì ˆ)"
        rationale = f"ê±°ë˜ë‘”í™” êµ¬ê°„ ë³¸ì ˆ ìµì ˆ ({ret_pct:+.2f}%)"
        return action, rationale

    # -----------------------------
    # 1) ì „ëŸ‰ ì²­ì‚° ê¶Œê³  ì¡°ê±´ (ê°•í•œ ì²­ì‚°)
    # -----------------------------
    full_exit = False
    why_full = []

    # (1) ì†ì‹¤ì´ ë§ì´ ì»¤ì¡Œì„ ë•Œ
    if ret_pct <= -2.0:
        full_exit = True
        why_full.append(f"ì†ì‹¤ {ret_pct:+.2f}%")

    # (2) ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì½”ì–´ê°€ ì„ê³„ì¹˜ë³´ë‹¤ ë§ì´ ë†’ê³ , VWAP/EMAë„ ê¹¨ì ¸ ìˆì„ ë•Œ
    if ctx_score >= (ctx_thr + 1) and not vwap_ok and not ema_ok:
        full_exit = True
        why_full.append(f"ì»¨í…ìŠ¤íŠ¸ {ctx_score}/{ctx_thr}")

    # (3) ì•½ì†ì‹¤ ìƒíƒœì—ì„œ ë§¤ìˆ˜ì„¸Â·í…Œì´í”„ê°€ ë§ì´ ì£½ì€ ê²½ìš°
    if ret_pct < -0.8 and buy < 0.50 and n >= 4:
        full_exit = True
        why_full.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    if full_exit:
        action = "ì „ëŸ‰ ì²­ì‚° ê¶Œê³ "
        rationale = " Â· ".join(why_full) if why_full else "ë¦¬ìŠ¤í¬ ìš°ìœ„"
        return action, rationale

    # -----------------------------
    # 2) ë¶€ë¶„ ì²­ì‚° ê¶Œê³  (ì• ë§¤/ê²½ê³  êµ¬ê°„)
    # -----------------------------
    partial_exit = False
    why_partial = []

    # ìˆ˜ìµì´ í¬ì§€ ì•Šì€ êµ¬ê°„
    if -0.8 < ret_pct < 0.8:
        partial_exit = True
        why_partial.append(f"ìˆ˜ìµ {ret_pct:+.2f}%")

    # ì»¨í…ìŠ¤íŠ¸ ê²½ê³  ë ˆë²¨
    if ctx_score == ctx_thr:
        partial_exit = True
        why_partial.append(f"ì»¨í…ìŠ¤íŠ¸ ê²½ê³  {ctx_score}/{ctx_thr}")

    # ë§¤ìˆ˜ë¹„ ì•½í•˜ê³  í‹±ì€ ë§ì€ ê²½ìš°
    if buy < 0.55 and n >= 6:
        partial_exit = True
        why_partial.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    # ğŸš€ ê±°ë˜ë‘”í™” ì‹œ ìë™ ë¶€ë¶„ìµì ˆ ê¶Œê³ 
    if ret_pct >= 1.5 and t15["krw_per_sec"] < 15000:
        partial_exit = True
        why_partial.append(f"ê±°ë˜ì†ë„ ë‘”í™” {t15['krw_per_sec']:.0f} KRW/s")

    # VWAP/EMA ë‘˜ ë‹¤ í•˜ë°©ì¼ ë•Œ
    if not vwap_ok and not ema_ok:
        partial_exit = True
        why_partial.append("VWAPÂ·EMA5 í•˜ë°©")

    if partial_exit:
        action = "ë¶€ë¶„ ì²­ì‚°(50%) ê¶Œê³ "
        rationale = " Â· ".join(why_partial) if why_partial else "ë¶ˆí™•ì‹¤ êµ¬ê°„"
        return action, rationale

    # -----------------------------
    # 3) ìœ ì§€ ê¶Œê³  (ì¶”ì„¸ ìœ ì§€)
    # -----------------------------
    why_keep = [f"ìˆ˜ìµ {ret_pct:+.2f}%"]
    if vwap_ok:
        why_keep.append("VWAP ìƒë°©")
    if ema_ok:
        why_keep.append("EMA5 ìƒë°©")
    if buy >= 0.60 and n >= 4:
        why_keep.append(f"ë§¤ìˆ˜ë¹„ {buy*100:.1f}% / í‹± {n}")

    rationale = " Â· ".join(why_keep)
    return "ìœ ì§€ ê¶Œê³ ", rationale


# =========================
# ëª¨ë‹ˆí„°ë§(ìµœì¢…í˜•)
# =========================
def monitor_position(m,
                     entry_price,
                     pre,
                     tight_mode=False,
                     horizon=None,
                     reentry=False):
    c1 = get_minutes_candles(1, m, 20)
    base_stop, eff_sl_pct = dynamic_stop_loss(entry_price, c1)

    # horizonì´ ì•ˆ ë“¤ì–´ì˜¤ë©´ ìë™ ê²°ì •, ë“¤ì–´ì˜¤ë©´ ê·¸ ê°’ ì‚¬ìš©
    if horizon is None:
        horizon = decide_monitor_secs(pre, tight_mode=tight_mode)
    start_ts = time.time()
    MAX_RUNTIME = horizon * 1.5  # ìµœëŒ€ í—ˆìš© ì‹¤í–‰ì‹œê°„ (ì •ìƒì‹œê°„ì˜ 1.5ë°°)


    # ë””ë°”ìš´ìŠ¤/íŠ¸ë ˆì¼ ìƒíƒœ
    # ì†ì ˆ ë””ë°”ìš´ìŠ¤ìš©
    stop_first_seen_ts = 0.0
    stop_hits = 0
    # ì»¨í…ìŠ¤íŠ¸ ì²­ì‚° ë””ë°”ìš´ìŠ¤ìš©
    ctx_first_seen_ts = 0.0
    ctx_hits = 0

    trail_armed = False
    trail_stop = 0.0

    # ìŠ¤ìº˜í”„ ë¯¸ì„¸ìµì ˆ ì œì–´ (ìˆœì´ìµ ë³´ì¥)
    micro_arm = False
    micro_floor = 0.0

    # ì´ìµë½ ì œì–´ (ê³ ì • ê°€ê²©, ìƒí–¥ë§Œ ê°€ëŠ¥)
    profit_lock_active = False
    profit_lock_price = 0.0

    # ìŠ¤íŒŒì´í¬/ê·¸ë ˆì´ìŠ¤ ê¸°ì¡´ ë¡œì§ ì¬í™œìš©
    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 10
    grace_used = False
    spike_recovery_used = False

    ob = pre.get("ob")
    ob_depth_default = ob.get("depth_krw", 10_000_000) if ob else 10_000_000

    last_price = entry_price
    best = entry_price
    worst = entry_price

    # â˜… ì •ì²´ ê°ì§€ìš© ìƒíƒœ ë³€ìˆ˜
    best_ts = time.time()        # ë§ˆì§€ë§‰ ì‹ ê³ ì  ì°ì€ ì‹œê°
    stall_arm_ts = None          # ì •ì²´ ì‹œì‘ í›„ë³´ ì‹œê°(ë””ë°”ìš´ì‹±ìš©)

    # ì‹¤ì œ ë³´ìœ  ìˆ˜ëŸ‰ í™•ë³´ (ìµì ˆ ì‹œ ë§¤ë„ìš©)
    with _POSITION_LOCK:
        entry_volume = OPEN_POSITIONS.get(m, {}).get("volume", 0.0)

    verdict = None
    outcome_extra = ""

    # === í¬ì§€ì…˜ ëª¨ë“œ (probe / confirm) ===
    with _POSITION_LOCK:
        pos = OPEN_POSITIONS.get(m, {})
    entry_mode = pos.get("entry_mode", "confirm")

    try:
        exit_reason = None  # âœ… ë£¨í”„ ë‚´ì—ì„œëŠ” ì‚¬ìœ ë§Œ ê¸°ë¡
        while time.time() - start_ts <= horizon:
            time.sleep(RECHECK_SEC)

            ticks = get_recent_ticks(m, 100)
            if not ticks or len(ticks) < 3:
                consecutive_failures += 1
                if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                    time.sleep(3)
                    ticks = get_recent_ticks(m, 100)
                    if not ticks:
                        verdict = "ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨"
                        break
                    consecutive_failures = 0
                continue
            consecutive_failures = 0

            # í˜„ì¬ê°€
            cur_js = safe_upbit_get("https://api.upbit.com/v1/ticker", {"markets": m})
            if not cur_js or len(cur_js) == 0:
                continue
            curp = cur_js[0].get("trade_price", last_price)

            # ğŸ”§ ì‹ ê³ ì /ì‹ ì €ì  'ê°±ì‹ ' ê°ì§€ë¥¼ ìœ„í•´ ì´ì „ê°’ ì €ì¥
            prev_best = best
            prev_worst = worst

            last_price = curp
            best = max(best, curp)
            worst = min(worst, curp)

            # â˜… ì‹ ê³ ì  ê°±ì‹  ì‹œ ì •ì²´ íƒ€ì´ë¨¸ ë¦¬ì…‹
            if best > prev_best:
                best_ts = time.time()
                stall_arm_ts = None

            # === 1) ì›œì—… êµ¬ê°„: ì†Œí­ ë˜ëŒë¦¼ ë¬´ì‹œ (ë‹¨, ê¸‰ë½ì€ ì¦‰ì‹œ ì»·)
            alive_sec = time.time() - start_ts
            dd_now = (curp / best - 1.0)
            if alive_sec < WARMUP_SEC:
                if (curp / entry_price - 1.0) <= -HARD_STOP_DD:
                    exit_reason = "HARD_STOP"  # â† finallyì—ì„œ ì‹¤ì²­ì‚°ë˜ë„ë¡ ì¶”ê°€
                    verdict = "ê¸‰ë½ ì¦‰ì‹œ ì†ì ˆ"
                    outcome_extra = f"(DD {dd_now*100:.2f}%)"
                    break  # ì²­ì‚°ì€ finallyì—ì„œ í•œ ë²ˆë§Œ
                # ì›œì—… ì¤‘ì—” ì†Œí”„íŠ¸ ìŠ¤íƒ‘ ë¯¸ì ìš©
                continue

            # === 2) íŠ¸ë ˆì¼ë§ ì†ì ˆ: ì´ìµì´ ë‚˜ì•¼ë§Œ ë¬´ì¥
            gain_from_entry = (curp / entry_price - 1.0)

            # === ğŸ“Š ìŠ¤ìº˜í”„ vs ì¶”ì„¸ ë¶„ê¸°: run_from_entry ê¸°ì¤€ ===
            run_from_entry = (best / entry_price - 1.0)

            # === PROBE â†’ CONFIRM ì „í™˜ ë¡œì§ ===
            with _POSITION_LOCK:
                pos = (OPEN_POSITIONS.get(m) or {}).copy()  # âœ… ì•ˆì „ ì½ê¸°

            if pos.get("entry_mode") == "probe":
                t15_now = micro_tape_stats_from_ticks(ticks, 15)

                gain_now = (float(curp) / float(entry_price) - 1.0)  # float í†µì¼

                c1m_ema = get_minutes_candles(1, m, 20)
                ema3_cross = ema_last([c["trade_price"] for c in c1m_ema], 3)
                ema8_cross = ema_last([c["trade_price"] for c in c1m_ema], 8)
                ema_crossover = (ema3_cross and ema8_cross) and (ema3_cross > ema8_cross)

                # â˜… ê°€ê²© ê²Œì´íŠ¸: +0.3% ì´ìƒ or ìµœê·¼ ì „ê³  ëŒíŒŒ (íš¡ë³´ í•„í„°)
                price_ok = False
                if gain_now >= 0.003:  # +0.3% ìµœì†Œ ìˆ˜ìµ
                    price_ok = True
                elif c1m_ema and len(c1m_ema) >= 6:
                    recent_high = max(c["high_price"] for c in c1m_ema[-6:])
                    if curp > recent_high:  # ìµœê·¼ 6ê°œ ë´‰ ì „ê³  ëŒíŒŒ
                        price_ok = True

                # â˜… í…Œì´í”„ ì¡°ê±´ (íœ©ì˜ ë°©ì§€ - í•„ìˆ˜)
                flow_ok = (
                    t15_now["buy_ratio"] >= 0.56  # ë§¤ìˆ˜ë¹„ 56% ì´ìƒ
                    and t15_now["krw_per_sec"] >= 14000  # ê±°ë˜ì†ë„ 14,000ì›/ì´ˆ ì´ìƒ
                )

                # â˜… íë¦„ + ê°€ê²© ê²Œì´íŠ¸ ì¡°í•© (ê°€ê²©ë§Œìœ¼ë¡œëŠ” ì „í™˜ ë¶ˆê°€)
                condition_original = price_ok and flow_ok
                condition_rebound = (ema_crossover and flow_ok)

                if condition_original or condition_rebound:
                    ok_add, new_entry = add_auto_position(m, curp)
                    if ok_add and new_entry:
                        with _POSITION_LOCK:
                            if m in OPEN_POSITIONS:
                                OPEN_POSITIONS[m].update({
                                    "entry_mode": "confirm",
                                    "entry_price": float(new_entry),
                                    "last_add_ts": time.time(),
                                })

                        tg_send_mid(
                            f"ğŸ”¥ {m} ìƒìŠ¹ í™•ì • â†’ probe âœ confirm ì „í™˜\n"
                            f"ì¶”ë§¤ í›„ í‰ë‹¨: {fmt_price(new_entry)}ì›"
                        )

                        # â˜… ì¶”ë§¤ í›„ ìŠ¤íƒ‘ì€ ì ˆëŒ€ ìœ„ë¡œ ë‹¹ê¸°ì§€ ì•ŠìŒ (ì •ìƒ ëˆŒë¦¼ ë³´í˜¸)
                        c1_for_sl = get_minutes_candles(1, m, 20)
                        old_stop = base_stop
                        new_stop, new_sl_pct = dynamic_stop_loss(new_entry, c1_for_sl)
                        base_stop = min(old_stop, new_stop)  # ìŠ¤íƒ‘ì€ ì ˆëŒ€ ìƒí–¥ ì•ˆë¨
                        eff_sl_pct = min(eff_sl_pct, new_sl_pct)
                        trail_armed = False

            if (not trail_armed) and gain_from_entry >= TRAIL_ARM_GAIN:
                trail_armed = True
                # ì´ˆê¸° íŠ¸ë ˆì¼: ATR ê¸°ì¤€ í˜¹ì€ ìµœì†Œê±°ë¦¬
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(TRAIL_DISTANCE_MIN,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = TRAIL_DISTANCE_MIN
                trail_stop = curp * (1.0 - trail_dist)

            # === PROBE ë¯¸ì„¸ìµì ˆ: +0.10% ì°ê³  ë°€ë¦¬ë©´ ì¦‰ì‹œ ë³¸ì ˆ-ì†Œìµ í™•ì • (ì´ˆì™„í™”) ===
            with _POSITION_LOCK:
                pos_probe = (OPEN_POSITIONS.get(m) or {})
            if pos_probe.get("entry_mode") == "probe":
                run_from_entry_probe = (best / entry_price - 1.0)
                drop_from_best = (curp / best - 1.0)
                # í”„ë¡œë¸Œê°€ +0.10% ì´ìƒ ì°ê³  -0.08% ë˜ë°€ë¦¬ë©´ ì¦‰ì‹œ ì²­ì‚° (0.15â†’0.10, 0.1â†’0.08, ì´ˆì™„í™”)
                if run_from_entry_probe >= 0.0010 and drop_from_best <= -0.0008:
                    exit_reason = "PROBE_MICRO_PROFIT"
                    verdict = f"probe ë¯¸ì„¸ìµì ˆ (ê³ ì  {run_from_entry_probe*100:.2f}%, í˜„ì¬ {gain_from_entry*100:.2f}%)"
                    break

            # === â˜… ì¶”ë§¤ ì§í›„ 45ì´ˆ ê²€ì¦ (ì‹¤íŒ¨í•˜ë©´ ì¶”ê°€ë¶„ë§Œ ë¡¤ë°±) ===
            with _POSITION_LOCK:
                p_check = OPEN_POSITIONS.get(m) or {}
            last_add_ts = p_check.get("last_add_ts", 0.0)
            last_add_vol = p_check.get("last_add_volume", 0.0)
            last_add_px = p_check.get("last_add_price", 0.0)

            if last_add_vol > 0 and (time.time() - last_add_ts) <= 45:
                t15_now = micro_tape_stats_from_ticks(ticks, 15)
                t30_now = micro_tape_stats_from_ticks(ticks, 30)
                made_new_high = curp >= best * 0.999  # ì‹ ê³ ì  ì¬ë„ì „
                reaccel = (t15_now["krw_per_sec"] >= 1.15 * max(t30_now["krw_per_sec"], 1)
                          and t15_now["buy_ratio"] >= 0.58)

                # ì‹¤íŒ¨ ì¡°ê±´: ì‹ ê³ ì  ë¯¸ê°±ì‹  + ì¬ê°€ì† ì‹¤íŒ¨ or ê°€ê²© ì´íƒˆ
                fail_add = (not made_new_high and not reaccel) or (curp <= last_add_px * 0.997)

                if fail_add:
                    # ì¶”ê°€ë¶„ë§Œ ë¡¤ë°± (ë¶€ë¶„ ë§¤ë„)
                    current_vol = p_check.get("volume", 1e-12)
                    rollback_ratio = min(1.0, last_add_vol / max(current_vol, 1e-12))
                    ok_rb, _, exec_rb = safe_partial_sell(m, sell_ratio=rollback_ratio, reason="ì¶”ë§¤ ì‹¤íŒ¨ ë¡¤ë°±")

                    if ok_rb and exec_rb > 0:
                        print(f"[ADD_ROLLBACK] {m} ì¶”ë§¤ ê²€ì¦ ì‹¤íŒ¨ â†’ {exec_rb:.6f} ë¡¤ë°±")
                        # ë¡¤ë°± ì™„ë£Œ í‘œì‹œ (ì¬ë¡¤ë°± ë°©ì§€)
                        with _POSITION_LOCK:
                            q = OPEN_POSITIONS.get(m)
                            if q:
                                q["last_add_volume"] = 0.0
                                OPEN_POSITIONS[m] = q

            # === â˜… ê³µí†µ STALL(ì •ì²´) ê°ì§€ ===
            # ìµœê·¼ 0~5ì´ˆ vs 5~20ì´ˆ ë¹„êµ + ì‹ ê³ ì  ì •ì§€ ì‹œê°„
            w_now = _win_stats(ticks, 0, 5)      # ìµœê·¼
            w_early = _win_stats(ticks, 5, 20)   # ì§ì „
            stall_age = time.time() - best_ts

            # ê±°ë˜ì†ë„/ë§¤ìˆ˜ë¹„ê°€ ì§ì „ ëŒ€ë¹„ ëª…í™•íˆ ë‘”í™” & ì‹ ê³ ì  ê°±ì‹  ì •ì§€
            flow_decel = (w_now["krw_per_sec"] <= w_early["krw_per_sec"] * 0.6)
            buy_drop   = (w_now["buy_ratio"]   <= w_early["buy_ratio"]   - 0.10)
            tick_slow  = (w_now["rate"]        <= max(0.25, w_early["rate"] * 0.6))

            is_stall_candidate = (stall_age >= 5.0) and (flow_decel or buy_drop or tick_slow)

            # 1ì´ˆ ë””ë°”ìš´ì‹±(ì—°ì† í™•ì¸)
            if is_stall_candidate and stall_arm_ts is None:
                stall_arm_ts = time.time()
            elif not is_stall_candidate:
                stall_arm_ts = None
            is_stall = bool(stall_arm_ts and (time.time() - stall_arm_ts >= 1.0))

            # === PROBE íƒ€ì„ì•„ì›ƒ + ì •ì²´ ì²­ì‚°: ì¶©ë¶„íˆ ê´€ì°° í›„ íŒë‹¨ ===
            if pos_probe.get("entry_mode") == "probe":
                if alive_sec >= PROBE_TIMEOUT_SEC:
                    gain_now = (curp / entry_price - 1.0)
                    # ë³¸ì ˆ ê·¼ì²˜ ë˜ëŠ” ì†ì‹¤ì´ë©´ ì •ë¦¬
                    if gain_now <= PROBE_BREAKEVEN_EXIT:  # -0.5% ì´í•˜ë©´ ì²­ì‚°
                        exit_reason = "PROBE_TIMEOUT_CUT"
                        verdict = "probe íƒ€ì„ì•„ì›ƒ ì†ì ˆ"
                        break

                # â˜… ì •ì²´ëŠ” ì†ì‹¤ì¼ ë•Œë§Œ ì²­ì‚° (ìˆ˜ìµì´ë©´ ìœ ì§€)
                if is_stall and alive_sec >= 30:  # ìµœì†Œ 30ì´ˆ ê²½ê³¼ í›„ì—ë§Œ ì •ì²´ íŒë‹¨
                    gain_now = (curp / entry_price - 1.0)
                    if gain_now < -0.003:  # -0.3% ì´í•˜ ì†ì‹¤ì´ë©´ ì •ì²´ ì‹œ ì²­ì‚°
                        exit_reason = "PROBE_STALL_CUT"
                        verdict = f"probe ì •ì²´ ì†ì ˆ ({gain_now*100:+.2f}%)"
                        break
                    # ìˆ˜ìµ ì¤‘ì´ë©´ ì •ì²´ì—¬ë„ ìœ ì§€ (ì¶”ì„¸ ê¸°ë‹¤ë¦¼)

            # === â˜… ìƒìŠ¹ì„¸ íŒì • (ì¶”ë§¤ìš©) ===
            strong_up = (
                uptick_streak_from_ticks(ticks, need=2)
                and w_now["buy_ratio"] >= 0.58
                and w_now["krw_per_sec"] >= max(14000, 0.7 * w_early["krw_per_sec"])
            )

            # === 2-1) í”¼ë¼ë¯¸ë”©(ì¶”ë§¤): ìƒìŠ¹ì„¸ë©´ ì¶”ë§¤ / ì •ì²´ë©´ ë¶€ë¶„ì²­ì‚° ===
            if pos_probe.get("entry_mode") != "probe":  # âœ… current_mode â†’ pos_probe.get() ì‚¬ìš©
                if strong_up and USE_PYRAMIDING and AUTO_TRADE:
                    t15_now = micro_tape_stats_from_ticks(ticks, 15)
                    t30_now = micro_tape_stats_from_ticks(ticks, 30)

                    # ë‹¨ê¸° EMA ìƒìŠ¹ ì „í™˜
                    c1m = get_minutes_candles(1, m, 20)
                    ema3 = ema_last([c["trade_price"] for c in c1m], 3)
                    ema8 = ema_last([c["trade_price"] for c in c1m], 8)
                    short_term_up = (ema3 is not None and ema8 is not None and ema3 > ema8)

                    with _POSITION_LOCK:
                        pos = OPEN_POSITIONS.get(m)
                        adds_used = pos.get("adds", 0) if pos else MAX_ADDS
                        last_add_ts = pos.get("last_add_ts", 0.0) if pos else 0.0

                    # â˜… VWAP ê³¼ì—´ ë°©ì§€ (ì¶”ë§¤ë§Œ ë” ë³´ìˆ˜ì )
                    vwap20 = vwap_from_candles_1m(c1m, 20)
                    vgap = (curp / max(vwap20, 1) - 1.0) if vwap20 else 0.0
                    vgap_ok = (vgap <= 0.015)  # VWAP ëŒ€ë¹„ 1.5% ì´ë‚´ë§Œ ì¶”ë§¤ í—ˆìš© (1.8â†’1.5 ê°•í™”)

                    # â˜… ë²„ìŠ¤íŠ¸ ì†Œì§„ ê°€ë“œ (ì†ë„ ì €í•˜ ì‹œ ì¶”ë§¤ ê¸ˆì§€)
                    t5_now = micro_tape_stats_from_ticks(ticks, 5)
                    burst_exhausted = (t5_now["krw_per_sec"] < t30_now["krw_per_sec"] * 0.85)  # 15% ì´ìƒ ë‘”í™”

                    # â˜…â˜…â˜… 1ì°¨ ì¶”ë§¤ (probeâ†’confirm): ì¡°ê±´ ì™„í™” (ì¶”ë§¤ ì‹¤íŒ¨ ê°ì†Œ)
                    if adds_used == 0:
                        first_add_ok = (
                            alive_sec >= 15 and  # ìµœì†Œ 15ì´ˆ ê´€ì°°
                            curp > entry_price * 1.003 and  # ì‹¤ì œ +0.3% ì´ìƒ ìƒìŠ¹ (0.5â†’0.3 ì™„í™”)
                            t15_now["krw_per_sec"] >= t30_now["krw_per_sec"] * 1.15 and  # ê±°ë˜ëŸ‰ 15% ê°€ì† (30â†’15 ì™„í™”)
                            t15_now["buy_ratio"] >= 0.54 and  # ë§¤ìˆ˜ë¹„ 54% ì´ìƒ (60â†’54 ì™„í™”)
                            short_term_up and
                            vgap_ok and  # â˜… VWAP ê³¼ì—´ ë°©ì§€
                            not burst_exhausted and  # â˜… ë²„ìŠ¤íŠ¸ ì†Œì§„ ì²´í¬
                            last_two_ticks_fresh(ticks)
                        )
                        flow_ok = first_add_ok
                    # â˜…â˜…â˜… 2ì°¨+ ì¶”ë§¤: ìƒìŠ¹ì„¸ ê³„ì†ë˜ë©´ ë¹ ë¥´ê²Œ (ì™„í™”)
                    else:
                        flow_ok = (
                            t15_now["krw_per_sec"] >= t30_now["krw_per_sec"] * 1.15 and  # ê°€ì†ë„ 15%+
                            t15_now["buy_ratio"]   >= 0.58 and                           # ë§¤ìˆ˜ë¹„ 58%+
                            last_two_ticks_fresh(ticks) and
                            short_term_up and
                            vgap_ok and  # â˜… VWAP ê³¼ì—´ ë°©ì§€
                            strong_up  # ìœ„ì—ì„œ ê³„ì‚°ëœ ë‹¨ê¸° ê°•ì„¸ í”Œë˜ê·¸
                        )

                    if flow_ok:
                        # ì¿¨ë‹¤ìš´: 1ì°¨ëŠ” ì—†ìŒ, 2ì°¨+ëŠ” 60% ë‹¨ì¶• (6ì´ˆ)
                        if adds_used == 0:
                            cooldown_ok = True  # 1ì°¨ ì¶”ë§¤ëŠ” ì¿¨ë‹¤ìš´ ì—†ìŒ
                        else:
                            cooldown_ok = (time.time() - last_add_ts) >= (PYRAMID_ADD_COOLDOWN_SEC * 0.4)  # 0.6â†’0.4 (ë” ë¹ ë¥´ê²Œ)

                        if pos and (adds_used < MAX_ADDS) and cooldown_ok:
                            ok_add, new_entry = add_auto_position(m, curp)
                            if ok_add and new_entry:
                                entry_price = new_entry
                                # â˜… ì¶”ë§¤ í›„ ìŠ¤íƒ‘ì€ ì ˆëŒ€ ìœ„ë¡œ ë‹¹ê¸°ì§€ ì•ŠìŒ (ì •ìƒ ëˆŒë¦¼ ë³´í˜¸)
                                c1_for_sl = get_minutes_candles(1, m, 20)
                                old_stop = base_stop
                                new_stop, new_sl_pct = dynamic_stop_loss(entry_price, c1_for_sl)
                                base_stop = min(old_stop, new_stop)  # ìŠ¤íƒ‘ì€ ì ˆëŒ€ ìƒí–¥ ì•ˆë¨
                                eff_sl_pct = min(eff_sl_pct, new_sl_pct)
                                tg_send_mid(
                                    f"â• <b>{m}</b> ìƒìŠ¹ì„¸ ì¶”ë§¤ ì²´ê²°<br>"
                                    f"ğŸ’µ ìƒˆ í‰ë‹¨ {fmt_price(entry_price)}ì›<br>"
                                    f"ğŸ§¯ ì†ì ˆ {fmt_price(base_stop)}ì› ({eff_sl_pct*100:.2f}%)"
                                )

                elif is_stall:
                    # â˜… ì •ì²´ë©´ ë¶€ë¶„ìµì ˆ â†’ ì¬ì •ì²´ë©´ ì „ëŸ‰
                    # ìˆ˜ìµì´ ì¶©ë¶„í•˜ë©´ 50%, ì• ë§¤í•˜ë©´ 30%
                    sell_ratio = 0.50 if gain_from_entry >= 0.012 else 0.30
                    ok, _, executed = safe_partial_sell(m, sell_ratio=sell_ratio, reason="stall ë¶€ë¶„ì²­ì‚°")
                    if ok and executed > 0:
                        # ì¶”ê°€ë¡œ ê³„ì† ì •ì²´ë©´ ì „ëŸ‰
                        if stall_age >= 10.0:
                            exit_reason = "STALL_FULL_EXIT"
                            verdict = "ì •ì²´ ì§€ì† ì „ëŸ‰ ì²­ì‚°"
                            break


            # íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸(ì´ìµ í™•ëŒ€ ì‹œì—ë§Œ ìƒí–¥) â€” 'ì‹ ê³ ì  ê°±ì‹ ' ê¸°ì¤€
            if trail_armed and best > prev_best:
                atr = atr14_from_candles(get_minutes_candles(1, m, 20), 14)
                if atr and atr > 0:
                    trail_dist = max(TRAIL_DISTANCE_MIN,
                                     (atr / max(curp, 1)) * TRAIL_ATR_MULT)
                else:
                    trail_dist = TRAIL_DISTANCE_MIN
                trail_stop = max(trail_stop, curp * (1.0 - trail_dist))


            # ìœ íš¨ ìŠ¤íƒ‘ = max(ê¸°ë³¸ ë™ì  SL, íŠ¸ë ˆì¼ë§)
            effective_stop = max(base_stop, trail_stop if trail_armed else 0.0)

            # === ğŸ¯ ìŠ¤ìº˜í”„ ëª¨ë“œ: run < 3%ë©´ ë¯¸ì„¸ìµì ˆ ìš°ì„  (ë‹¨, PROBEëŠ” ì œì™¸!) ===
            # í”„ë¡œë¸ŒëŠ” íƒìƒ‰ ëª¨ë“œì´ë¯€ë¡œ ë¹ ë¥¸ ì •ë¦¬ ì—†ì´ ì»¨íŒ ì „í™˜ ê¸°íšŒë¥¼ ì¤˜ì•¼ í•¨
            with _POSITION_LOCK:
                current_mode = (OPEN_POSITIONS.get(m) or {}).get("entry_mode", "confirm")

            if run_from_entry < TREND_THRESHOLD and current_mode != "probe":
                # ğŸ”’ ìµœì € ì²­ì‚°ê°€ (ìˆ˜ìˆ˜ë£Œ+ë§ˆì§„ ë³´ì¥)
                if micro_floor == 0.0:
                    micro_floor = entry_price * (1.0 + FEE_RATE + SCALP_MICRO_MARGIN + 0.0001)  # +0.01% ì¿ ì…˜


                # ëª©í‘œê°€ ë„ë‹¬ ì‹œ ë½ armed
                if curp >= micro_floor:
                    micro_arm = True

                # ğŸ¯ ë¯¸ì„¸ìµì ˆ ì²­ì‚° ì¡°ê±´ (ìˆœì´ìµ ë³´ì¥)
                if micro_arm:
                    drop_from_high = (best - curp) / max(best, 1)
                    # 1) í˜„ì¬ê°€ê°€ ìµœì € ì²­ì‚°ê°€ ì´í•˜ë¡œ ë‚´ë ¤ì˜¤ë©´ â†’ ì¦‰ì‹œ ì²­ì‚° (ìˆœì´ìµ í™•ì •)
                    # 2) ë˜ëŠ” ê³ ì ëŒ€ë¹„ 0.05% í•˜ë½ì´ë©´ì„œ ì—¬ì „íˆ ìµœì €ê°€ ì´ìƒ â†’ ì²­ì‚°
                    if (curp <= micro_floor) or (drop_from_high >= 0.0005 and curp >= micro_floor):
                        exit_reason = "SCALP_MICRO_EXIT"
                        verdict = f"ìŠ¤ìº˜í”„ ë¯¸ì„¸ìµì ˆ í™•ì • (gain={gain_from_entry*100:.2f}%, ìˆœìµë³´ì¥)"
                        break

                # ğŸ“‰ ìŠ¤ìº˜í”„ ëª¨ë“œ ì†ì ˆ: ì¼ë°˜ë³´ë‹¤ íƒ€ì´íŠ¸í•˜ê²Œ (-0.8%)
                if gain_from_entry <= -0.008:
                    exit_reason = "SCALP_STOP"
                    verdict = f"ìŠ¤ìº˜í”„ ì†ì ˆ (gain={gain_from_entry*100:.2f}%)"
                    break

                # â° ìŠ¤ìº˜í”„ íƒ€ì„ì•„ì›ƒ: 30ì´ˆ ë‚´ ëª©í‘œ ë¯¸ë‹¬ì„± ì‹œ ë³¸ì „ ê·¼ì²˜ë©´ ì²­ì‚°
                if alive_sec >= 30 and -0.002 <= gain_from_entry <= 0.002:
                    exit_reason = "SCALP_TIMEOUT"
                    verdict = f"ìŠ¤ìº˜í”„ íƒ€ì„ì•„ì›ƒ ë³¸ì „ì²­ì‚° (gain={gain_from_entry*100:.2f}%)"
                    break

                # ìŠ¤ìº˜í”„ ëª¨ë“œì—ì„œëŠ” ë³µì¡í•œ ìƒë‹¨ì¶”ì  ë¡œì§ ìŠ¤í‚µ
                continue

            # === ğŸ”¥ ì¶”ì„¸ ëª¨ë“œ: run â‰¥ 3%, ì‹¬í”Œë§¤ë„ ë¡œì§ (ìµì ˆ ìš°ì„  + ì´ìµë½ + ê±°ë˜ëŸ‰ê°ì†) ===
            t15 = micro_tape_stats_from_ticks(ticks, 15)
            t30 = micro_tape_stats_from_ticks(ticks, 30)
            avg_ref = (t15["krw_per_sec"] + t30["krw_per_sec"]) / 2
            drop_ratio = t15["krw_per_sec"] / max(t30["krw_per_sec"], 1)
            vdrop_trigger = drop_ratio < 0.65 and t15["buy_ratio"] < 0.55

            cur_gain = (curp / entry_price - 1.0)
            drop_from_high = (best - curp) / best

            # === ğŸ¯ Patch #2: ìˆ˜ì§ í™•ì¥ ìƒë‹¨ ìº¡ì²˜ (ê³ ì ì—ì„œ íŒŒê¸°) ===
            # ìŠ¤íŒŒì´í¬ ê°ì§€: EMA3/VWAP ê°­ ê³¼ë„ + ê°€ì†â†’ê°ì† ì „í™˜
            try:
                c1m_spike = get_minutes_candles(1, m, 20)
                vwap20_spike = vwap_from_candles_1m(c1m_spike, 20)
                ema3_spike = ema_last([c["trade_price"] for c in c1m_spike], 3)

                # VWAP ëŒ€ë¹„ ê°­, EMA3 ëŒ€ë¹„ ê°­
                vwap_gap = (curp / max(vwap20_spike, 1) - 1.0) if vwap20_spike else 0.0
                ema3_gap = (curp / max(ema3_spike, 1) - 1.0) if ema3_spike else 0.0

                # ìŠ¤íŒŒì´í¬ ì¡°ê±´: VWAP ê°­ â‰¥ 2.2% OR EMA3 ê°­ â‰¥ 2.5%
                spike_detected = (vwap_gap >= 0.022 or ema3_gap >= 0.025)

                # ê°ì† ì¡°ê±´: drop_ratio < 0.70 (ê±°ë˜ëŸ‰ 30% ì´ìƒ í•˜ë½)
                decel_detected = drop_ratio < 0.70

                # ìŠ¤íŒŒì´í¬ + ê°ì† â†’ ë¶€ë¶„ ìµì ˆ (30-50%)
                if spike_detected and decel_detected and cur_gain >= 0.015:
                    # ê°­ì´ í´ìˆ˜ë¡ ë” ë§ì´ ë§¤ë„ (2.2% â†’ 30%, 3.0%+ â†’ 50%)
                    sell_ratio = 0.30 if max(vwap_gap, ema3_gap) < 0.030 else 0.50
                    safe_partial_sell(m, sell_ratio=sell_ratio, reason=f"ìˆ˜ì§í™•ì¥ìƒë‹¨ìº¡ì²˜ {sell_ratio*100:.0f}%")

                    # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ì´ê¸° (0.6%)
                    if trail_armed:
                        tight_trail = curp * 0.994  # 0.6% íŠ¸ë ˆì¼
                        trail_stop = max(trail_stop, tight_trail)
                        print(f"[SPIKE_TOP] {m} ìŠ¤íŒŒì´í¬ ìƒë‹¨ ê°ì§€ â†’ íŠ¸ë ˆì¼ 0.6%ë¡œ ì¡°ì„ (vwap_gap={vwap_gap:.3f}, ema3_gap={ema3_gap:.3f})")
            except Exception as e:
                # ìŠ¤íŒŒì´í¬ ê°ì§€ ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
                pass

            # === ğŸ¯ Patch #4: ìˆ˜ìµ êµ¬ê°„ íŠ¸ë ˆì¼ ì¡°ì´ê¸° ===
            # ìˆ˜ìµ +1.2% ì´ìƒ & ê±°ë˜ëŸ‰ ê°ì†Œ ì‹œ â†’ íŠ¸ë ˆì¼ 0.6%ë¡œ íƒ€ì´íŠ¸í•˜ê²Œ
            if trail_armed and cur_gain >= 0.012 and drop_ratio < 0.75:
                tight_profit_trail = curp * 0.994  # 0.6% íŠ¸ë ˆì¼
                if tight_profit_trail > trail_stop:
                    trail_stop = tight_profit_trail
                    print(f"[PROFIT_TRAIL] {m} ìˆ˜ìµêµ¬ê°„ íŠ¸ë ˆì¼ ì¡°ì„ â†’ 0.6% (gain={cur_gain*100:.2f}%, drop_ratio={drop_ratio:.2f})")

            # â‘  ê¸‰ë½ ì¦‰ì‹œ ì†ì ˆ - ìµœì†Œ ë³´ìœ  ì‹œê°„ ì˜ˆì™¸ (í”„ë¡œíŒŒì¼ ì„¤ì • HARD_STOP_DD ì‚¬ìš©)
            if cur_gain <= -HARD_STOP_DD:
                exit_reason = "HARD_STOP"
                tg_send_mid(f"ğŸ©¸ {m} ê¸‰ë½ -{HARD_STOP_DD*100:.1f}% ì»·(ëŒ€ê¸°)")
                verdict = "HARD_STOP"
                break

            # === ìµœì†Œ ë³´ìœ  ì‹œê°„ 10ì´ˆ (ê¸‰ë½ ì™¸ì—ëŠ” ì ìš©) ===
            if alive_sec < 10:
                continue  # 10ì´ˆ ë¯¸ë§Œì€ ì²­ì‚° ë¡œì§ ìŠ¤í‚µ

            # â‘¡ ì¡°ê¸°ìµì ˆ: ê³ ì  ëŒ€ë¹„ -0.3% & ê±°ë˜ëŸ‰ê°ì†
            if drop_from_high >= 0.003 and vdrop_trigger:
                safe_partial_sell(m, sell_ratio=0.5, reason="ì¡°ê¸°ìµì ˆ 50%")
                verdict = "PARTIAL_EXIT"

            # â‘¡-2 ê±°ë˜ëŸ‰ ê¸‰ê° ì¡°ê¸° ì²­ì‚° (ê³ ì  í¬ì°©)
            if drop_ratio < 0.60 and t15["buy_ratio"] < 0.50 and cur_gain >= 0.005:
                # ê±°ë˜ëŸ‰ 40% ê°ì†Œ + ë§¤ìˆ˜ë¹„ 50% ë¯¸ë§Œ + ìµœì†Œ 0.5% ì´ìµ
                exit_reason = "VOLUME_DROP_EARLY"
                tg_send_mid(f"ğŸ“‰ {m} ê±°ë˜ëŸ‰ ê¸‰ê° ê°ì§€ â†’ ì¡°ê¸° ì²­ì‚° (gain={cur_gain*100:.2f}%)")
                verdict = "VOLUME_DROP_EXIT"
                break

            # â‘¢ ì „ëŸ‰ìµì ˆ: ê³ ì ëŒ€ë¹„ í•˜ë½ ì„ê³„ì¹˜(ë™ì ) - â˜… ì™„í™” (ì¼ì° ì²­ì‚° ë°©ì§€)
            dyn_drop_thr = 0.013  # ê¸°ë³¸ 1.3% (1.0â†’1.3 ì™„í™”)
            if t15["krw_per_sec"] >= 25000 and t15["buy_ratio"] >= 0.60:
                dyn_drop_thr = 0.018   # ê°•ì¶”ì„¸: ë” ì—¬ìœ  (1.6â†’1.8 ì™„í™”)
            elif t15["krw_per_sec"] <= 12000 or t15["buy_ratio"] < 0.52:
                dyn_drop_thr = 0.010   # ë‘”í™”: ë” íƒ€ì´íŠ¸ (0.8â†’1.0 ì™„í™”)

            # â† ì„ê³„ì¹˜ ì‚°ì •ê³¼ íŒì •ì„ ë¶„ë¦¬
            if drop_from_high >= dyn_drop_thr:
                exit_reason = "DROP_FROM_HIGH"
                tg_send_mid(f"ğŸš¨ {m} ê³ ì ëŒ€ë¹„ {drop_from_high*100:.2f}% í•˜ë½ â†’ ì „ëŸ‰ìµì ˆ(ëŒ€ê¸°)")
                verdict = "FULL_EXIT"
                break

            # â‘£ ì´ìµë½ (Profit Lock) â€” ê³ ì •ì‹ìœ¼ë¡œ ë¬´ì¥ & ìƒí–¥ë§Œ
            if not profit_lock_active and cur_gain >= 0.010:
                # ìˆ˜ìµ êµ¬ê°„ ì§„ì… ì‹œ ë½ ë¬´ì¥ (ì„ê³„ì— ë”°ë¼ ì—¬ìœ í­ ë‹¤ë¥´ê²Œ)
                lock_gap = 0.008 if cur_gain >= 0.015 else 0.006  # 0.8% or 0.6%
                profit_lock_price = best * (1.0 - lock_gap)
                profit_lock_active = True
            elif profit_lock_active:
                # ì‹ ê³ ì  ê°±ì‹  ì‹œì—ë§Œ 'ìƒí–¥' ì¡°ì • (ê²°ì½” í•˜í–¥ X)
                lock_gap = 0.008 if cur_gain >= 0.015 else 0.006
                profit_lock_price = max(profit_lock_price, best * (1.0 - lock_gap))

            # íŠ¸ë¦¬ê±° íŒì •ì€ 'ê³ ì •ëœ' ë½ ê°€ê²©ìœ¼ë¡œ
            if profit_lock_active and curp <= profit_lock_price:
                exit_reason = "PROFIT_LOCK"
                tg_send_mid(f"ğŸ’ {m} ì´ìµë½ ë°œë™ ({fmt_price(profit_lock_price)}ì›) â†’ ì²­ì‚°(ëŒ€ê¸°)")
                verdict = "PROFIT_LOCK"
                break

            # â‘¤ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ê³ ì  ëŒ€ë¹„ 0.5%) â€” 'ì‹ ê³ ì  ê°±ì‹ ' ì‹œë§Œ ìƒí–¥
            if trail_armed and best > prev_best:
                trail_stop = max(trail_stop, best * 0.995)
            if trail_armed and curp <= trail_stop:
                exit_reason = "TRAIL_EXIT"
                tg_send_mid(f"ğŸ“‰ {m} íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘({fmt_price(trail_stop)}ì›) í„°ì¹˜ â†’ ì²­ì‚°(ëŒ€ê¸°)")
                verdict = "TRAIL_EXIT"
                break


            # â‘¥ ì¬ì§„ì…ì€ remonitor_until_close()ê°€ ì²­ì‚° í›„ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¶ˆí•„ìš”

        if verdict is None:
            verdict = "ì‹œê°„ ë§Œë£Œ(ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ)"

    finally:
        # ================================
        # 1) ìµœì‹  ìƒíƒœ / ìˆ˜ìµë¥  ê³„ì‚°
        # ================================
        ticks = get_recent_ticks(m, 100)
        t15 = micro_tape_stats_from_ticks(ticks, 15) if ticks else {
            "buy_ratio": 0,
            "krw": 0,
            "n": 0,
            "krw_per_sec": 0
        }

        ob = pre.get("ob") or {}
        ob_depth_krw = ob.get("depth_krw", 10_000_000)

        try:
            ret_pct = ((last_price / entry_price - 1.0) - FEE_RATE) * 100.0
        except:
            ret_pct = 0.0

        maxrun = (best / entry_price - 1.0) * 100.0
        maxdd = (worst / entry_price - 1.0) * 100.0

        # ================================
        # 2) ëì•ŒëŒ ë¬¸êµ¬ ìƒì„±
        # ================================
        action, rationale = _end_reco(m,
                              entry_price,
                              last_price,
                              ret_pct,
                              c1,
                              ticks,
                              ob_depth_krw,
                              ctx_thr=CTX_EXIT_THRESHOLD)

        # ===========================================
        # ëì•ŒëŒ / ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™”
        #  (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ê³¼ë‹¤ ë°©ì§€)
        # ===========================================
        if not reentry:
            pass  # ëì•ŒëŒ ë¹„í™œì„±í™”
        else:
            pass  # ì¬ëª¨ë‹ˆí„°ë§ ìš”ì•½ ë¹„í™œì„±í™”

        # ===========================================
        # ì¬ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
        #  - ìµœì´ˆ ëª¨ë‹ˆí„°ë§ì—ì„œë§Œ í˜¸ì¶œ
        #  - remonitor_until_close()ì—ì„œ ì¬í˜¸ì¶œëœ ê²½ìš°(reentry=True)ëŠ” ë‹¤ì‹œ ì•ˆ ë“¤ì–´ê°
        # ===========================================
        # âœ… ì¬ëª¨ë‹ˆí„°ë§ ì•Œë¦¼ ë¹„í™œì„±í™” (ë¶ˆí•„ìš”í•œ ë°˜ë³µ ë©”ì‹œì§€ ë°©ì§€)
        # (ì‹¤ì œ ë¡œì§ì€ ìœ ì§€í•˜ì§€ë§Œ, ì•Œë¦¼ ë°œì†¡ë§Œ ì°¨ë‹¨)
        try:
            if AUTO_TRADE and exit_reason:
                with _POSITION_LOCK:
                    still_open = m in OPEN_POSITIONS and OPEN_POSITIONS[m].get("volume", 0) > 0
                if still_open:
                    close_auto_position(m, exit_reason)
        except Exception as _e:
            print("[SAFE_EXIT_ERR]", _e)

        if AUTO_TRADE and m in OPEN_POSITIONS and not reentry:
            remonitor_until_close(m, entry_price, pre, tight_mode)

        # ===========================================
        # 3) probe ì†ì ˆ í›„ ë¹ ë¥¸ ì¬ì§„ì… í—ˆìš© ë¡œì§
        # ===========================================
        if AUTO_TRADE and verdict and "ì†ì ˆ" in verdict:
            with _POSITION_LOCK:
                pos = OPEN_POSITIONS.get(m)
                if pos and pos.get("entry_mode") == "probe":
                    # probe ì†ì ˆ ì‹œ ì¬ì§„ì… ì¿¨ë‹¤ìš´ ìµœì†Œí™”
                    REMONITOR_QUICK_COOLDOWN_SEC = 120  # 2ë¶„ ì¿¨ë‹¤ìš´
                    REMONITOR_WINDOW_MINUTES = 10       # 10ë¶„ ë‚´ ë™ì¼ ì¢…ëª© ì¬ê¸°íšŒ í—ˆìš©

                    # ìµœê·¼ ì¢…ë£Œ ì‹œê° ê¸°ë¡
                    pos["last_exit_ts"] = time.time()
                    OPEN_POSITIONS[m] = pos

                    # ğŸŒ€ probe ì†ì ˆ ê°ì§€ â†’ ì¬ì§„ì… ëª¨ë“œ (ì•Œë¦¼ ë¹„í™œì„±í™”)

                    # ë¹ ë¥¸ ì¬ëª¨ë‹ˆí„°ë§ ì˜ˆì•½
                    time.sleep(REMONITOR_QUICK_COOLDOWN_SEC)
                    remonitor_until_close(m, entry_price, pre, tight_mode)

        # ğŸ‘‡ ì´ return ì€ if ë°”ê¹¥ì—ì„œ í•­ìƒ ì‹¤í–‰ë˜ê²Œ
        return (
            verdict,
            action,
            rationale,
            ret_pct,
            last_price,
            maxrun,
            maxdd,
        )


# =========================
# ì•Œë¦¼
# =========================
def tg_send(t, retry=1):
    # TG_TOKEN ì—†ê±°ë‚˜ CHAT_IDSê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì½˜ì†”ì—ë§Œ ì¶œë ¥
    if not TG_TOKEN or not CHAT_IDS:
        print(t)
        return True

    ok_any = False
    for cid in CHAT_IDS:
        payload = {
            "chat_id": cid,
            "text": t,
            "parse_mode": "HTML",
            "disable_web_page_preview": True,
        }
        for _ in range(retry + 1):
            try:
                with _session_lock:  # âœ… ì„¸ì…˜ ë™ì‹œì ‘ê·¼ ë³´í˜¸
                    r = SESSION.post(
                        f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                        json=payload,
                        timeout=4,
                    )
                js = r.json()
                if r.status_code == 200 and js.get("ok") is True:
                    ok_any = True
                    break
                # ok:false ë˜ëŠ” ë¹„ì •ìƒ status ëª¨ë‘ ë¡œê¹…
                print(f"[TG][{cid}] status={r.status_code} body={r.text}")
            except Exception as e:
                print(f"[TG][{cid}] exception: {e}")
            time.sleep(0.25 + rnd() * 0.25)
    return ok_any

# =========================
# ë©”ì¸ ë£¨í”„ ì¤€ë¹„
# =========================
last_signal_at = {}
recent_alerts = {}
last_price_at_alert = {}
last_reason = {}
ALERT_TTL = 1800

def cleanup_expired_last_signals(ttl_sec: int = None):
    ttl = ttl_sec or max(COOLDOWN, ALERT_TTL)
    now = time.time()
    drop = [m for m, ts in last_signal_at.items() if (now - ts) >= ttl]
    for m in drop:
        last_signal_at.pop(m, None)
        last_price_at_alert.pop(m, None)
        last_reason.pop(m, None)

# =========================
# ì‹œê°„ëŒ€ë³„ ì¿¨ë‹¤ìš´ ì„¤ì •
# =========================
def get_cooldown_sec(market: str) -> int:
    """
    ê°™ì€ ì¢…ëª© ì¬ì§„ì… ëŒ€ê¸° ì‹œê°„(ì´ˆ)
    - ìˆ˜ìµ ì²­ì‚° í›„: 60ì´ˆ (ë¹ ë¥¸ ì¬ì§„ì…)
    - 09ì‹œëŒ€: 3ë¶„
    - 10~14ì‹œ: 5ë¶„
    - ê·¸ ì™¸: ê¸°ë³¸ COOLDOWN(8ë¶„)
    """
    # === ğŸ¯ Patch #5: ìˆ˜ìµ ì²­ì‚° í›„ ì¬ì§„ì… ì¿¨ë‹¤ìš´ ë‹¨ì¶• (120s â†’ 60s) ===
    last_cause = LAST_EXIT_CAUSE.get(market)
    if last_cause == "profit":
        return 60  # 1ë¶„ (ìˆ˜ìµ ì²­ì‚° ì‹œ ë¹ ë¥¸ ì¬ì§„ì…)

    h = now_kst().hour

    if h == 9:
        return 180  # 3ë¶„
    elif 10 <= h <= 14:
        return 300  # 5ë¶„
    else:
        return COOLDOWN  # ì „ì—­ ê¸°ë³¸ê°’(480)

def cooldown_ok(market, price=None, reason=None):
    now = time.time()
    last = last_signal_at.get(market, 0)

    # âœ… ì‹œê°„ëŒ€ë³„ ë™ì  ì¿¨ë‹¤ìš´ ì ìš©
    cooldown = get_cooldown_sec(market)

    # ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì¡°ê±´
    if (now - last) >= cooldown:
        return True

    # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(ì¬ëŒíŒŒ/ë˜ëŒë¦¼ ì¬ì§„ì… í—ˆìš©)ëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
    if (now - last) >= REARM_MIN_SEC:
        lp = last_price_at_alert.get(market)
        rebreak = (price and lp and (price >= lp * (1.0 + REARM_PRICE_GAP)))
        reason_changed = (last_reason.get(market) != reason)
        rebreak_small = (price and lp
                         and (price >= lp * (1.0 + REARM_REBREAK_MIN))
                         and not reason_changed)
        pullback = (price and lp
                    and (price <= lp * (1.0 - REARM_PULLBACK_MAX)))
        if rebreak or rebreak_small or (pullback and reason_changed):
            return True
    return False

# --- [BUGFIX] ì¶”ê°€: cleanup_expired ---
def cleanup_expired(d: dict, ttl_sec: int):
    now = time.time()
    drop = [k for k, ts in d.items() if (now - ts) >= ttl_sec]
    for k in drop:
        d.pop(k, None)

# =========================
# ì„¤ì • ê²€ì¦
# =========================
def validate_config():
    errors = []
    warnings = []
    if TOP_N > 200: errors.append(f"TOP_N={TOP_N} ë„ˆë¬´ í¼ (â‰¤200 ê¶Œì¥)")
    if STOP_LOSS_PCT >= 0.05:
        warnings.append(f"STOP_LOSS_PCT={STOP_LOSS_PCT*100:.1f}% í¼ (<5%)")
    if PARALLEL_WORKERS > 30:
        warnings.append(f"PARALLEL_WORKERS={PARALLEL_WORKERS} ê³¼ë‹¤")
    if MIN_TURNOVER <= 0 or MIN_TURNOVER >= 1:
        errors.append(f"MIN_TURNOVER={MIN_TURNOVER} ë²”ìœ„ ì˜¤ë¥˜ (0~1)")
    if TICKS_BUY_RATIO < 0.5 or TICKS_BUY_RATIO > 1:
        errors.append(f"TICKS_BUY_RATIO={TICKS_BUY_RATIO} ë²”ìœ„ ì˜¤ë¥˜ (0.5~1)")
    if not TG_TOKEN or not CHAT_IDS: warnings.append("í…”ë ˆê·¸ë¨ ë¯¸ì„¤ì • - ì½˜ì†” ì¶œë ¥ë§Œ ì‚¬ìš©")
    if _BUCKET.get("rate", 0) <= 0: warnings.append("í† í°ë²„í‚· rate<=0 â†’ 0.1ë¡œ í´ë¨í”„")
    if _BUCKET.get("cap", 0) <= 0: warnings.append("í† í°ë²„í‚· cap<=0 â†’ 1.0ë¡œ í´ë¨í”„")
    if warnings:
        print("[CONFIG_WARNING]")
        for w in warnings:
            print("  âš ï¸", w)
    if errors:
        print("[CONFIG_ERROR]")
        for e in errors:
            print("  âŒ", e)
        sys.exit(1)
    print("âœ… ì„¤ì • ê²€ì¦ ì™„ë£Œ")


# =========================
# í—¬ìŠ¤ì²´í¬ ì„œë²„(ì˜µì…˜)
# =========================
from http.server import HTTPServer, BaseHTTPRequestHandler

bot_start_time = 0

class HealthHandler(BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        if self.path == "/health":
            with _req_lock:                 # âœ… ë™ì‹œì„± ì•ˆì „ ìŠ¤ëƒ…ìƒ·
                req_stats = dict(REQ_STATS)
            with _POSITION_LOCK:            # âœ… í¬ì§€ì…˜ ì¹´ìš´íŠ¸ ìŠ¤ëƒ…ìƒ·
                open_positions_count = len(OPEN_POSITIONS)

            with ACTIVE_MON_LOCK:
                running_monitors = sum(1 for f in ACTIVE_MONITORS.values() if f and not f.done())

            status = {
                "status": "running",
                "version": "3.2.7-hh+peakcut+perf+fix-final2+patch+postcheck6s+dynSL+ctxExit+netRetry",
                "uptime_sec": int(time.time() - bot_start_time),
                "uptime_str": str(timedelta(seconds=int(time.time() - bot_start_time))),
                "last_scan": now_kst_str(),
                "req_stats": req_stats,                         # âœ…
                "alerts_count": len(last_signal_at),
                "cache_size": len(_TICKS_CACHE.cache) if hasattr(_TICKS_CACHE, 'cache') else 0,
                "open_positions": open_positions_count,         # âœ… ì„ íƒ ì§€í‘œ
                "running_monitors": running_monitors,
                "max_concurrent": MAX_CONCURRENT,
                "max_open_positions": MAX_OPEN_POSITIONS,
                "config": {
                    "top_n": TOP_N,
                    "scan_interval": SCAN_INTERVAL,
                    "stop_loss_pct": STOP_LOSS_PCT
                }
            }
            self.send_response(200)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(json.dumps(status, ensure_ascii=False).encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_health_server(port=8080):
    """í—¬ìŠ¤ì²´í¬ ì„œë²„ ì‹œì‘ (ë¡œì»¬í˜¸ìŠ¤íŠ¸ë§Œ ë°”ì¸ë”©)"""
    for p in range(port, port + 5):
        try:
            server = HTTPServer(("127.0.0.1", p), HealthHandler)  # ë³´ì•ˆ: ì™¸ë¶€ ì ‘ê·¼ ì°¨ë‹¨
            thread = threading.Thread(target=server.serve_forever, daemon=True)
            thread.start()
            print(f"ğŸ¥ Health check server: http://localhost:{p}/health")
            return
        except OSError:
            continue
    print("[HEALTH_ERR] í¬íŠ¸ ì‚¬ìš© ë¶ˆê°€ (8080~8084)")

def start_monitor_watchdog():
    def _loop():
        while True:
            time.sleep(5)
            with _POSITION_LOCK:
                opens = list(OPEN_POSITIONS.keys())
            with ACTIVE_MON_LOCK:
                running = {k for k, f in ACTIVE_MONITORS.items() if f and not f.done()}
            for m in opens:
                if m not in running:
                    pre = LAST_PRE.get(m) or {
                        "ob": {},
                        "ticks": [],
                        "tape": {"n":0,"buy_ratio":0,"krw":0,"krw_per_sec":0},
                        "entry_mode": (OPEN_POSITIONS.get(m) or {}).get("entry_mode","confirm")
                    }

                    entry = (OPEN_POSITIONS.get(m) or {}).get("entry_price")
                    if entry and entry > 0:  # âœ… 0/None ë°©ì§€
                        # ğŸ”§ ëˆ„ë½ëœ price ë³´ì •
                        if "price" not in pre or not pre.get("price"):
                            pre["price"] = float(entry)
                        # â˜… force=True: ì²­ì‚°ì€ ë¬´ì¡°ê±´ ì‹¤í–‰ (í•œë„ ë¬´ì‹œ)
                        launch_monitor(m, pre, tight_mode=False, force=True)
                        print(f"[WATCHDOG] {m} ëª¨ë‹ˆí„° ì¬ì‹œì‘ (í¬ì§€ì…˜ ì²­ì‚° í•„ìš”)")




    threading.Thread(target=_loop, daemon=True).start()


def start_probe_v2_monitor():
    """í”„ë¡œë¸Œ 2.0 ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ: 1ë¶„ë§ˆë‹¤ ì ìˆ˜ ì—…ë°ì´íŠ¸ ë° ìŠ¹ê²©/ì‹¤íŒ¨ ì²´í¬"""
    def _probe_v2_loop():
        while True:
            try:
                time.sleep(60)  # 1ë¶„ë§ˆë‹¤

                if not PROBE_V2_ENABLED:
                    continue

                # í™œì„± í”„ë¡œë¸Œ 2.0 ìƒíƒœ ë³µì‚¬
                with _PROBE_V2_LOCK:
                    active_probes = list(PROBE_V2_STATES.keys())

                for m in active_probes:
                    try:
                        # 1ë¶„ë´‰ ê°€ì ¸ì˜¤ê¸°
                        c1 = get_minutes_candles(1, m, 30)
                        if not c1:
                            continue

                        # ë°” ì¹´ìš´íŠ¸ ì¦ê°€
                        probe_v2_increment_bars(m)

                        # ì ìˆ˜ ì—…ë°ì´íŠ¸
                        score_delta = probe_v2_update_score(m, c1)

                        with _PROBE_V2_LOCK:
                            if m not in PROBE_V2_STATES:
                                continue
                            current_score = PROBE_V2_STATES[m]["score"]

                        if score_delta != 0:
                            print(f"[PROBE_V2] {m} ì ìˆ˜ ë³€í™”: {score_delta:+d} (ì´ì : {current_score})")

                        # ì‹¤íŒ¨ ì²´í¬ (ìš°ì„  ì²˜ë¦¬)
                        if probe_v2_check_failure(m, c1):
                            print(f"[PROBE_V2] {m} ì‹¤íŒ¨ ì¡°ê±´ ì¶©ì¡± â†’ ì²­ì‚°")
                            probe_v2_remove_state(m)

                            # í¬ì§€ì…˜ì´ ìˆìœ¼ë©´ ì²­ì‚°
                            with _POSITION_LOCK:
                                if m in OPEN_POSITIONS:
                                    close_auto_position(m, reason="PROBE_V2_FAILURE")
                            continue

                        # ìŠ¹ê²© ì²´í¬
                        if probe_v2_check_upgrade(m, c1):
                            print(f"[PROBE_V2] {m} ìŠ¹ê²© ì¡°ê±´ ì¶©ì¡± â†’ 1ì°¨ ì¶”ë§¤")

                            with _POSITION_LOCK:
                                pos = OPEN_POSITIONS.get(m)
                                if not pos:
                                    probe_v2_remove_state(m)
                                    continue

                                entry_price = pos["entry_price"]
                                adds_used = pos.get("adds", 0)

                            # 1ì°¨ ì¶”ë§¤ ì‹¤í–‰
                            if adds_used == 0:
                                krw_bal = get_krw_balance()
                                add_size_krw = int(krw_bal * PROBE_V2_SIZE_ADD1)
                                add_size_krw = max(min(add_size_krw, 50000), 10000)  # 10k~50k

                                current_price = c1[-1]["trade_price"]
                                # â˜… override_krwë¡œ í”„ë¡œë¸Œ 2.0 ê¸ˆì•¡ ê°•ì œ (í‘œì‹œì™€ ì‹¤ì œ ì¼ì¹˜)
                                ok_add, new_entry = add_auto_position(m, current_price, override_krw=add_size_krw)

                                if ok_add and new_entry:
                                    tg_send(
                                        f"â• <b>í”„ë¡œë¸Œ 2.0 ìŠ¹ê²© (1ì°¨ ì¶”ë§¤)</b> {m}\n"
                                        f"ğŸ’µ <b>ìƒˆ í‰ë‹¨</b> {fmt_price(new_entry)}ì›\n"
                                        f"ğŸ’° <b>ì¶”ë§¤ê¸ˆì•¡</b> {add_size_krw:,}ì›\n"
                                        f"ğŸ“Š <b>ì ìˆ˜</b> {current_score}"
                                    )

                    except Exception as e:
                        print(f"[PROBE_V2] {m} ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
                        import traceback
                        traceback.print_exc()

            except Exception as e:
                print(f"[PROBE_V2] ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {e}")
                import traceback
                traceback.print_exc()

    threading.Thread(target=_probe_v2_loop, daemon=True).start()
    print("[PROBE_V2] ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘ (60ì´ˆ ì£¼ê¸°)")

# ===== ì˜¤ë”ë¶ ìºì‹œ =====
def fetch_orderbook_cache(mkts):
    cache = {}
    for i in range(0, len(mkts), 15):
        js = safe_upbit_get(
            "https://api.upbit.com/v1/orderbook",
            {"markets": ",".join(mkts[i:i + 15])},
            timeout=6
        )
        if not js:
            continue

        for ob in js:
            try:
                units = (ob.get("orderbook_units") or [])[:3]
                if not units:
                    # ìœ ë‹› ì—†ìœ¼ë©´ ì¡°ìš©íˆ ìŠ¤í‚µ
                    continue

                ask = units[0].get("ask_price", 0)
                bid = units[0].get("bid_price", 0)
                mid = (ask + bid) / 2 if (ask and bid) else 0
                # ìŠ¤í”„ë ˆë“œëŠ” % ë¡œ ì €ì¥(ê¸°ì¡´ ì„ê³„ê°’ê³¼ ì¼ê´€)
                spread = ((ask - bid) / mid * 100) if mid else 999.0

                askv = sum((u.get("ask_price", 0) * u.get("ask_size", 0)) for u in units)
                bidv = sum((u.get("bid_price", 0) * u.get("bid_size", 0)) for u in units)

                cache[ob.get("market", "?")] = {
                    "spread": float(spread),
                    "depth_krw": float(askv + bidv),
                    "raw": ob,
                }
            except Exception:
                # ë¹„ì •ìƒ ë°ì´í„°ëŠ” ê±´ë„ˆë›°ê³  ê³„ì†
                continue
    return cache

def launch_monitor(market, pre, tight_mode=False, force=False):
    """
    monitor_position()ì„ ìŠ¤ë ˆë“œí’€ì—ì„œ ì‹¤í–‰.
    - ê°™ì€ ì¢…ëª© ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    - ë™ì‹œ ì‹¤í–‰ ê°œìˆ˜ ì œí•œ(MAX_CONCURRENT)

    Args:
        force: Trueë©´ í•œë„ ë¬´ì‹œ (ì›Œì¹˜ë…/ì²­ì‚°ìš©)
    """
    with ACTIVE_MON_LOCK:
        # ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ìŠ¤í‚µ
        fut = ACTIVE_MONITORS.get(market)
        if fut and not fut.done():
            print(f"[MON_DUP] {market} ëª¨ë‹ˆí„° ì´ë¯¸ ì‹¤í–‰ ì¤‘ â†’ ìŠ¤í‚µ")
            return False

        # ë™ì‹œ ê°œìˆ˜ ì œí•œ ì²´í¬ (force=Trueë©´ ë¬´ì‹œ)
        running = sum(1 for f in ACTIVE_MONITORS.values() if f and not f.done())
        if not force and running >= MAX_CONCURRENT:
            print(f"[MON_LIMIT] ë™ì‹œ ëª¨ë‹ˆí„° í•œë„({MAX_CONCURRENT}) ë„ë‹¬ â†’ {market} ë³´ë¥˜")
            return False

        # ì œì¶œ
        f = MONITOR_POOL.submit(monitor_position, market, pre["price"], pre, tight_mode)
        ACTIVE_MONITORS[market] = f

        # ì™„ë£Œ ì‹œ ì •ë¦¬
        def _cleanup(_):
            with ACTIVE_MON_LOCK:
                ACTIVE_MONITORS.pop(market, None)
        f.add_done_callback(_cleanup)

        print(f"[MON_LAUNCH] {market} ëª¨ë‹ˆí„° ì‹œì‘")
        return True

# =========================
# ë©”ì¸
# =========================
SHARD_SIZE = TOP_N
_cursor = 0


def main():
    global _cursor
    # ğŸ”§ ì§„ë‹¨ ëª¨ë“œ í™œì„±í™” (í™˜ê²½ë³€ìˆ˜ë¡œ ì œì–´)
    DEBUG_MODE = os.getenv("DEBUG_CUT", "0") == "1"
    if DEBUG_MODE:
        print("[DEBUG] ì§„ë‹¨ ëª¨ë“œ í™œì„±í™”: ìƒì„¸ ë¡œê·¸ ì¶œë ¥")

    tg_send(
        f"ğŸš€ ëŒ€ì¥ì´ˆì… í—Œí„° v3.2.7 (Conservative-Balanced) ì‹œì‘ | TOP {TOP_N} | {now_kst_str()}"
    )
    # í…”ë ˆê·¸ë¨ ë°°ê´€ í™•ì¸
    tg_send("ğŸ”§ PING: ë´‡ ì•Œë¦¼ ê²½ë¡œ ì ê²€ ì™„ë£Œ")

    # â˜… í”„ë¡œë¸Œ 2.0 ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
    if PROBE_V2_ENABLED:
        start_probe_v2_monitor()
        print("[PROBE_V2] ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘ë¨")

    while True:
        try:
            # BTC_guard ì œê±° â€” í•­ìƒ ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰
            tight_mode = False

            for k in list(CUT_COUNTER.keys()):
                CUT_COUNTER[k] = 0

            cleanup_expired(recent_alerts, ALERT_TTL)
            cleanup_expired_last_signals()
            _TICKS_CACHE.purge_older_than(max_age_sec=2.5)
            _C5_CACHE.purge_older_than(max_age_sec=2.5)

            mkts_all = get_top_krw_by_24h(TOP_N)
            if not mkts_all:
                aligned_sleep(get_scan_interval())
                continue

            start = _cursor
            end = _cursor + SHARD_SIZE
            shard = mkts_all[start:end]
            if len(shard) < SHARD_SIZE:
                shard += mkts_all[:(SHARD_SIZE - len(shard))]
            _cursor = (end) % len(mkts_all)

            obc = fetch_orderbook_cache(shard)

            c1_cache = {}
            use_workers = min(PARALLEL_WORKERS, len(shard))
            with ThreadPoolExecutor(max_workers=use_workers) as exe:
                futures = {
                    exe.submit(get_minutes_candles, 1, m, 20): m
                    for m in shard
                }
                for f in as_completed(futures):
                    m = futures[f]
                    try:
                        c1_cache[m] = f.result() or []
                    except:
                        c1_cache[m] = []

            found = 0
            for m in shard:
                c1 = c1_cache.get(m, [])
                if not c1: continue

                # === í”„ë¡œë¸Œ 2.0 íŠ¸ë¦¬ê±° ì²´í¬ (ì˜µì…˜) ===
                if PROBE_V2_ENABLED:
                    # ì´ë¯¸ í¬ì§€ì…˜ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ
                    with _POSITION_LOCK:
                        if m in OPEN_POSITIONS:
                            continue

                    # ì´ë¯¸ í”„ë¡œë¸Œ 2.0 ìƒíƒœê°€ ìˆìœ¼ë©´ ìŠ¤í‚µ
                    with _PROBE_V2_LOCK:
                        if m in PROBE_V2_STATES:
                            continue

                    # ì„ í•„í„°
                    ob_data = obc.get(m)
                    if ob_data and probe_v2_prefilter(c1, ob_data):
                        # 3ê°€ì§€ íŠ¸ë¦¬ê±° ì¤‘ í•˜ë‚˜ë¼ë„ ë°œë™
                        trigger_type = None
                        if probe_v2_trigger_breakout(c1):
                            trigger_type = "A_BREAKOUT"
                        elif probe_v2_trigger_momentum(c1):
                            trigger_type = "B_MOMENTUM"
                        elif probe_v2_trigger_trend(c1):
                            trigger_type = "C_TREND"

                        if trigger_type:
                            # í”„ë¡œë¸Œ 2.0 ìƒíƒœ ì¶”ê°€
                            probe_v2_add_state(m, trigger_type)

                            # í”„ë¡œë¸Œ ì§„ì… ì‹¤í–‰
                            if AUTO_TRADE and m not in OPEN_POSITIONS:
                                # í”„ë¡œë¸Œ í¬ê¸° ê³„ì‚°
                                krw_bal = get_krw_balance()
                                probe_size_krw = int(krw_bal * PROBE_V2_SIZE_PROBE)
                                probe_size_krw = max(min(probe_size_krw, 10000), 5000)  # 5k~10k

                                # pre dict ìƒì„± (open_auto_position ì‹œê·¸ë‹ˆì²˜ ë§ì¶¤)
                                pre = {
                                    "price": c1[-1]["trade_price"],
                                    "entry_mode": "probe",  # probe_v2ê°€ ì•„ë‹Œ probeë¡œ (ê¸°ì¡´ ë¡œì§ í™œìš©)
                                    "ign_ok": False,
                                    "mega_ok": False,
                                    "early_ok": True,
                                    "ticks": [],
                                    "tape": {"n": 0, "buy_ratio": 0, "krw": 0, "krw_per_sec": 0},
                                    "ob": ob_data if ob_data else {"depth_krw": 0, "spread": 99},
                                }

                                # ë™ì  ì†ì ˆê°€ ê³„ì‚°
                                dyn_stop, eff_sl = dynamic_stop_loss(pre["price"], c1)

                                # ì§„ì… (override_krwë¡œ ì•ˆì „í•˜ê²Œ ì „ë‹¬)
                                open_auto_position(m, pre, dyn_stop, eff_sl, override_krw=probe_size_krw)

                                # ì•Œë¦¼ (ë‹¨ìˆœí™”)
                                tg_send(
                                    f"ğŸ”¬ <b>í”„ë¡œë¸Œ 2.0 ì§„ì…</b> {m} <code>#{trigger_type}</code>\n"
                                    f"ğŸ’° <b>ê¸ˆì•¡</b> {probe_size_krw:,}ì›\n"
                                    f"ğŸ“Š <b>ì ìˆ˜</b> 0 (ê´€ì°° ì‹œì‘)"
                                )
                                found += 1

                            continue  # í”„ë¡œë¸Œ 2.0 ì§„ì…í–ˆìœ¼ë©´ ê¸°ì¡´ ë¡œì§ ìŠ¤í‚µ

                # === ê¸°ì¡´ ë¡œì§ (í”„ë¡œë¸Œ 2.0 ë¯¸ì‚¬ìš© ë˜ëŠ” ë¯¸ë°œë™ ì‹œ) ===
                pre = detect_leader_stock(m, obc, c1, tight_mode=tight_mode)
                if not pre: continue

                # detect_leader_stock()ê°€ ì´ë¯¸ entry_modeë¥¼ ê²°ì •í–ˆìœ¼ë¯€ë¡œ ì¬íŒë‹¨ ê¸ˆì§€
                # (í”„ë¡œë¸Œ postcheck ìŠ¤í‚µ ë“±ì´ ë¬´íš¨í™”ë˜ëŠ” ì¹˜ëª…ì  ë²„ê·¸ ë°©ì§€)

                payload = final_check_leader(m, pre, tight_mode=tight_mode)
                if not payload: continue

                # === 6ì´ˆ í¬ìŠ¤íŠ¸ì²´í¬ (ì»¨íŒë§Œ ì ìš©, í”„ë¡œë¸ŒëŠ” íŒ¨ìŠ¤) ===
                if pre.get("entry_mode") == "probe":
                    ok_post, post_reason = True, "SKIP_FOR_PROBE"
                else:
                    ok_post, post_reason = postcheck_6s(m, pre)
                    if not ok_post:
                        cut("POSTCHECK_DROP", f"{m} postcheck fail: {post_reason}")
                        continue

                if m in recent_alerts and time.time(
                ) - recent_alerts[m] < ALERT_TTL:
                    continue

                reason = "ign" if pre.get("ign_ok") else (
                    "early" if pre.get("early_ok") else
                    ("mega" if pre.get("mega_ok") else "normal"))
                if not cooldown_ok(m, pre['price'], reason=reason):
                    continue

                last_signal_at[m] = time.time()
                recent_alerts[m] = time.time()
                last_price_at_alert[m] = pre['price']
                last_reason[m] = reason

                # ë™ì  ì†ì ˆê°€
                dyn_stop, eff_sl_pct = dynamic_stop_loss(pre['price'], c1)

                txt = (
                    f"âš¡ <b>ì´ˆì… ì‹ í˜¸</b> {m} <code>#{reason}</code>\n"
                    f"ğŸ’µ <b>í˜„ì¬ê°€</b> {fmt_price(pre['price'])}ì›\n"
                    f"ğŸ“Š ë“±ë½ {payload['chg']}% | ê±°ë˜ì¦ê°€ {payload['volume_surge']}ë°° | íšŒì „ {payload['turn']}%\n"
                    f"ğŸ”¸ë§¤ìˆ˜ {payload['buy']}% | í‹± {payload['n']} | ìŠ¤í”„ë ˆë“œ {payload['spread']}%\n"
                    f"ğŸ§¯ ì†ì ˆê°€: {fmt_price(dyn_stop)}ì› (ë™ì SL {eff_sl_pct*100:.2f}%)\n"
                    f"ğŸ§  ê·¼ê±°: {( 'ì í™”/5mëŒíŒŒ' if pre.get('ign_ok') else ('ì´ˆê¸°ëˆ„ì (TWAP)' if pre.get('botacc_ok') else ('ë©”ê°€ë¸Œë ˆì´í¬ì•„ì›ƒ' if pre.get('mega_ok') else ('ì´ˆê¸°íë¦„(early)' if pre.get('early_ok') else 'íŒ¨í„´ì¢…í•©'))) )}\n"
                    f"{link_for(m)}")

                sent = tg_send(txt, retry=2)

                if sent:
                    found += 1
                    # --- ë¡œê·¸ CSV ê¸°ë¡ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ) ---
                    try:
                        c5 = get_minutes_candles(5, m, 2) or []
                        c15 = get_minutes_candles(15, m, 2) or []
                        chg_1m = (c1[-1]["trade_price"] /
                                  max(c1[-2]["trade_price"], 1) -
                                  1) if len(c1) >= 2 else 0.0
                        chg_5m = (c5[-1]["trade_price"] /
                                  max(c5[-2]["trade_price"], 1) -
                                  1) if len(c5) >= 2 else ""
                        chg_15m = (c15[-1]["trade_price"] /
                                   max(c15[-2]["trade_price"], 1) -
                                   1) if len(c15) >= 2 else ""

                        cbtc1 = get_minutes_candles(1, "KRW-BTC", 2) or []
                        btc1m = (cbtc1[-1]["trade_price"] /
                                 max(cbtc1[-2]["trade_price"], 1) -
                                 1) if len(cbtc1) >= 2 else 0.0
                        cbtc5 = get_minutes_candles(5, "KRW-BTC", 2) or []
                        btc5m = (cbtc5[-1]["trade_price"] /
                                 max(cbtc5[-2]["trade_price"], 1) -
                                 1) if len(cbtc5) >= 2 else 0.0

                        t15_now = micro_tape_stats_from_ticks(pre["ticks"], 15)
                        ob = pre["ob"]
                        flags = {
                            "chg_1m":
                            chg_1m,
                            "chg_5m":
                            chg_5m,
                            "chg_15m":
                            chg_15m,
                            "zscore":
                            zscore_krw_1m(c1, 30),
                            "vwap_gap": (c1[-1]["trade_price"] /
                                         max(vwap_from_candles_1m(c1, 20), 1) -
                                         1) if len(c1) >= 1 else 0.0,
                            "turn":
                            round((t15_now["krw"] / max(ob["depth_krw"], 1)) *
                                  100, 2),
                            "two_green_break":
                            pre.get("two_green_break", False),
                            "ignition_ok":
                            pre.get("ign_ok", False),
                            "early_ok":
                            pre.get("early_ok", False),
                            "uptick_ok":
                            True
                        }
                        row = snapshot_row(m, pre["price"], payload, pre, c1,
                                           ob, t15_now, btc1m, btc5m, flags)
                        append_csv(row)
                    except Exception as e:
                        print("[LOG_ERR]", e)

                    # --- ğŸ”¥ ìë™ë§¤ìˆ˜ ì§„ì… ---
                    try:
                        open_auto_position(m, pre, dyn_stop, eff_sl_pct)
                    except Exception as e:
                        print("[AUTO_OPEN_ERR]", e)

                    # --- ğŸ§µ ëª¨ë‹ˆí„°ëŠ” ìŠ¤ë ˆë“œí’€ì—ì„œ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ ---
                    launched = False  # âœ… ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
                    try:
                        launched = launch_monitor(m, pre, tight_mode=tight_mode)
                        if not launched:
                            print(f"[MON_SKIP] {m} ëª¨ë‹ˆí„° ì‹œì‘ ë³´ë¥˜/ì¤‘ë³µ")
                    except Exception as e:
                        print("[MON_LAUNCH_ERR]", e)

                    # --- ëª¨ë‹ˆí„° ë¹„ë™ê¸° ì‹¤í–‰ (ë™ì‹œì„± ì œí•œ) ---
                    try:
                        LAST_PRE[m] = pre  # ì›Œì¹˜ë…ì—ì„œ ì¬ê¸°ë™ ì‹œ ì°¸ì¡°
                        if not launched:
                            print(f"[MONITOR_SKIP] {m} ëª¨ë‹ˆí„° ì‹œì‘ ë³´ë¥˜/ì¤‘ë³µ")
                    except Exception as e:
                        print("[MON_ERR]", e)


            cut_summary()
            if found == 0:
                req_summary()
            # ì‹œê°„ëŒ€ë³„ ë™ì  ìŠ¤ìº” ê°„ê²© ì ìš©
            aligned_sleep(get_scan_interval())

        except KeyboardInterrupt:
            print("Stopped by user.")
            break
        except Exception as e:
            print("[MAIN_ERR]", e)
            traceback.print_exc()
            print("[MAIN] 5ì´ˆ í›„ ì¬ì‹œì‘...")
            time.sleep(5)
            continue  # ğŸ’¡ ë‹¤ì‹œ ë£¨í”„ ì‹œì‘

if __name__ == "__main__":
    validate_config()
    if AUTO_TRADE:
        if not startup_selfcheck():
            print("â›” ì¸ì¦ ì‹¤íŒ¨ â†’ AUTO_TRADE ê°•ì œ OFF")
            AUTO_TRADE = False
    else:
        print("â„¹ï¸  AUTO_TRADE=0 â†’ Upbit selfcheck ìƒëµ")
    bot_start_time = time.time()
    start_health_server()
    start_monitor_watchdog()  # ì›Œì¹˜ë… ì‹œì‘
    start_probe_v2_monitor()  # í”„ë¡œë¸Œ 2.0 ëª¨ë‹ˆí„°ë§ ì‹œì‘

    try:
        main()
    finally:
        try:
            MONITOR_POOL.shutdown(wait=False, cancel_futures=True)
        except Exception:
            pass
